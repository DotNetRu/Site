0.00 11.68 "Анатолий Кулаков" Приветствую всех дорогие друзья, в эфире Радио.нет выпуск номер 47.
11.68 14.64 "Анатолий Кулаков" И сегодня, как всегда, в студии Анатолий Кулаков
14.64 15.64 "Игорь Лабутин" и Игорь Лабутин.
15.64 23.32 "Анатолий Кулаков" Всем привет. Большое спасибо за помощь нашим патронам – Александру, Сергею, Владиславу, Алексею, Шевченко Антону и Илье.
23.32 26.68 "Анатолий Кулаков" Большое спасибо, что помогаете и поддерживаете наш подкастик.
26.68 48.32 "Анатолий Кулаков" На этой неделе не так уж много новостей вышло, поэтому мы решили сегодня пробежаться по качественным статейчикам, которые давно у нас лежали в бэклоге, и немножко порассуждать, пофилософствовать о различных аспектах C#, .NET, объектно-ориентированного программирования и всего вокруг.
48.32 55.08 "Анатолий Кулаков" Но, опять же, далеко от темы уходить не будем, поэтому первая тема про свежий .NET 6.
55.08 116.52 "Игорь Лабутин" Да, Microsoft действительно потихонечку готовится, видимо, к следующему превью .NET 7, и пока его еще нету, мы немножко сегодня заглянем, что же там будет, но совсем-совсем чуть-чуть, поэтому пока вспомним, что же было в .NET 6, но не просто вспомним, мы хотим порекомендовать серию статей Андрю Лока под общим названием Exploring .NET 6, то есть он в 12 частях пробегается по разным кусочкам .NET 6, в основном те, которые там, конечно, поменялись, и рассказывает, на самом деле, что поменялось, почему поменялось, как оно работало раньше и как оно работает теперь с интересными картинками, объяснением каких-то внутренностей, приведением ссылок на GitHub и на кусочки кода прямо, так что если вам не просто там интересно, как, например, работает какая-то фича, а как прямо она устроена, то загляните в эту серию статей, возможно, вам будет интересно посмотреть взгляд Андрю Лока на эту тему.
116.52 126.36 "Анатолий Кулаков" Как всегда, прекрасные статейки у Андрю, меня единственное интересует просто, как он эти темы выбирал, то есть он выбрал 12 абсолютно несвязанных, разных тем и прокопал в них довольно-таки глубоко.
126.36 128.36 "Анатолий Кулаков" Интересно, как он этот список составлял.
128.36 148.32 "Игорь Лабутин" Непонятно, ну некоторые темы вполне ожидаемы, так скажем, то есть понятно, что minimal APIs были очень хайповыми и понятно, что там несколько статей посвящено разбору того, что же было сделано для того, чтобы minimal APIs стали возможными, то есть что такое publication builder и так далее.
148.32 165.60 "Игорь Лабутин" Ну а остальные, видимо, тоже какие-то большие изменения, то есть там source генераторы были затронуты, хотя не знаю, некоторые совсем маленькие, типа color argument expression, но видимо какие-то самые интересные на его взгляд вещи, которые ему было интересно покопаться, почему именно так.
165.60 169.76 "Анатолий Кулаков" Ну ладно, давай сначала списка пробежимся, и первым у нас тут про configuration manager.
169.76 206.48 "Игорь Лабутин" Да, configuration manager, если вы, ну а вы, конечно же, пользовались конфигурациями в старом, в старых дотнетах, пятом и раньше, там был такой класс называемый configuration builder, и как вы помните, вы можете туда накидать несколько провайдеров, сказать build, после чего configuration builder сходит по всем провайдерам, соберет конфигурацию, правильно там заверайдит, если один трудный ключ переопределяется в более поздних конфигурационных провайдерах, и выдается вам объект конфигурации, собственно, iConfiguration, который вы потом обычно раздаете дальше по кодам.
206.48 234.56 "Игорь Лабутин" Так вот, если вы используете, например, какой-нибудь провайдер конфигурации, настройкой которого содержится в самой же конфигурации, то вам приходилось делать некоторые приседания, то есть, например, одна из частых таких вещей, ну вот у нас, например, на проекте мы используем Azure App Configuration, и URL к этой конфигурации задается у нас в переменное окружение, ну при запуске приложения мы в переменное окружение передаем нужный URL в нужном окружении.
234.56 258.48 "Игорь Лабутин" Соответственно, как у нас выглядит код, мы создаем configuration builder, мы говорим туда addEnvironment variables, потом мы говорим build, потом мы этому же configuration builder говорим, собственно, add уже, точнее, не так, мы после build вытаскиваем из полученного объекта configurationConnectionString к Azure App Configuration, после чего говорим addAzureAppConfigurationProvider на том же builder.
258.48 271.84 "Игорь Лабутин" Ну, добавляем, понятно, всякие upsettings.json и upsettings.environment.json, и после чего говорим уже build для финальной конфигурации, то есть мы два раза вызываем build, и промежуточный, ну только ради того, чтобы вытащить какой-то промежуточный результат конфигурации.
271.84 291.52 "Игорь Лабутин" Вот, это было признано не очень правильным, что ли, вот, и поэтому теперь configuration manager на самом деле работает так, что как только вы говорите add для какого-то провайдера, он сразу подтягивает из провайдера все, что нужно, и вы можете как бы в последующих add использовать значения из прошлых.
291.52 304.88 "Игорь Лабутин" Вот, то есть не нужно теперь вот этого промежуточной сборки конфигурации, это первое, а второе, configuration manager немножко переписан внутри, так что он оптимизирован для именно вот прям добавления этих провайдеров.
304.88 315.76 "Игорь Лабутин" Старый билдер, он был, насколько я помню, статью, не могу ошибаться, но по-моему он был типа такой, где мы можем было и удалять провайдеры, хотя непонятно зачем удалять, ну может зачем-то надо.
315.76 326.68 "Игорь Лабутин" Вот, этот сейчас вот прям оптимизирован под добавление и решает проблему конфигурации, грубо говоря, вам не нужно делать никаких больше промежуточных шагов, просто накидываете сюда все провайдеры, говорите build, все, у вас конфигурация готова целиком.
326.68 339.44 "Игорь Лабутин" Вот, это, собственно, первая статья, поэтому посмотрите, что поменялось, посмотрите, что нужно поменять в вашем коде для того, чтобы поработать с конфигурацией по-новому, и пользуйтесь новыми фичами.
339.44 347.60 "Анатолий Кулаков" Вот, ну насколько я помню, что они полностью соблюли интерфейс старого, и поэтому ничего в вашем коде, по идее, менять не нужно, у вас просто заработает.
347.60 350.72 "Анатолий Кулаков" Да, просто заработает, но если хотите, то можно.
350.72 360.76 "Анатолий Кулаков" Ну да, просто работает вот в этом самом частом случае, если вы опять же хотите удалять или передобавлять, или очень часто билдите наоборот, то вот тут уже может быть нюанс.
360.76 365.88 "Анатолий Кулаков" То есть если вы используете по дефолту, как положено, то для вас останется все как и было.
365.88 374.56 "Игорь Лабутин" Да, дальше, соответственно, появилась такая штука как Web Application Builder, и ей посвящено на самом деле несколько статей.
374.56 387.24 "Игорь Лабутин" Одна из них это сравнение с Generic Custom, и по большому счету это просто сравнение и история того, как развивались эти вещи, начиная с ранних .NET Core, и заканчивая тем, к чему мы сейчас пришли.
387.24 391.68 "Игорь Лабутин" Отдельная статья посвящена тому, как этот Web Application Builder построен внутри.
391.68 401.12 "Игорь Лабутин" Отдельная статья после этого посвящена тому, как же строить Middleware Pipeline с помощью этого Web Application, и как это сейчас устроено.
401.12 409.32 "Игорь Лабутин" И абсолютно отдельная статья посвящена EF Core миграциям, как же эти EF Core миграции вызывать при построении вашего приложения.
409.32 426.60 "Игорь Лабутин" Соответственно, поскольку Web Application Builder - это теперь центральная часть нового подхода к тому, как мы собираем приложение, особенно если вы используете Minimal API, то вот эти 4 статьи будут наверняка полезны, чтобы понять, как это теперь все работает и как к этому подходить.
426.60 443.12 "Игорь Лабутин" В дополнение, кстати, к статье, ну точнее, это даже не статья, а такой набор хинтов от Дэвида Фаулера, да, по-моему, на GitHub писал какую-то такую статейку, типа как сконвертировать ваше текущее приложение в новое, в Minimal API.
443.12 449.48 "Игорь Лабутин" Мы как-то обозревали в каком-то подкасте в прошлых, вот, короче, это примерно в ту же степень.
449.48 472.84 "Игорь Лабутин" Дальше у нас есть Web Application Factory, это штука, которая позволяет вам попроще писать integration тесты, то есть в integration тестах как бы запускать ваше приложение, но не собирая его полностью Web Application Builder, а именно вот как бы делая такой factory, который как будто бы запустит приложение, ну или запустит его внутри теста.
472.84 495.88 "Игорь Лабутин" И поверх всех этих вот Web Application Builder, точнее, для того, чтобы пользователи, разработчики более правильно писали все эти новые конструкции в новых видах API, команда S/Penet Core выкатила некоторое количество новых аналайзеров, розли аналайзеров, которые подсказывают, что вот здесь вот лучше другой теперь метод использовать, здесь вот такой набор аргументиков более оптимальный и так далее.
495.88 499.76 "Игорь Лабутин" И вот обзор этих аналайзеров как раз это отдельная статья.
499.76 501.48 "Игорь Лабутин" Так, смотрим, что дальше.
501.48 507.28 "Игорь Лабутин" Дальше, ну, не могло обойтись без Source Generators, две статьи посвящены Source Generators.
507.28 509.44 "Игорь Лабутин" Это улучшение перформанса.
509.44 518.48 "Игорь Лабутин" Мы много говорили про то, насколько логинг может быть тормозной, почему он может быть тормозной, как это улучшить разными способами, в том числе с Source Generators.
518.48 521.52 "Игорь Лабутин" Ну вот, Andrew Log как раз это еще раз обозревает.
521.52 532.68 "Игорь Лабутин" Ну и после того, как он написал эту статью, у него вышла еще после этого еще одна статья, где он описывает incremental генераторы, то, что тоже мы до некоторой степени обозревали.
532.68 543.20 "Игорь Лабутин" И если вы пользуетесь Source Generators, освежите память, или если вы не пользуетесь, но хотите еще раз про это вспомнить, освежите память и посмотрите эти две статьи.
543.20 551.60 "Анатолий Кулаков" Я тебе даже больше скажу, что в выпуске в 39-м мы именно эту статью подробно разбирали, именно про Source Generators от Andrew Log.
551.60 553.28 "Игорь Лабутин" То есть это прям ровно она.
553.28 554.28 "Игорь Лабутин" Окей.
554.28 555.28 "Анатолий Кулаков" Да, это именно она.
555.28 556.28 "Анатолий Кулаков" Он пишет такое количество...
556.28 557.28 "Игорь Лабутин" Там про логинг, перформанс.
557.28 562.56 "Игорь Лабутин" Он пишет такое количество статей, что иногда я пудаюсь, честно говоря, что мы смотрели, что не смотрели.
562.56 563.56 "Игорь Лабутин" Так и есть.
563.56 566.56 "Игорь Лабутин" Итак, и еще есть несколько статей.
566.56 578.08 "Игорь Лабутин" Это новые фичи для dependency injection, то есть это всякая поддержка IOSync Disposables, как в новом вот этом подходе с Web Application Builder использовать кастомный DI-контейнер.
578.08 581.80 "Игорь Лабутин" Мы про это немножко говорили раньше, но можно почитать еще раз.
581.80 589.84 "Игорь Лабутин" И кучка улучшений вокруг DI, это что можно теперь узнать, зарегистрирован сервис или нет более простым способом.
589.84 592.40 "Игорь Лабутин" Есть некоторое количество новых диагностик-каунтеров.
592.40 605.72 "Игорь Лабутин" Ну и performance всяких методов типа try-add, когда вы пытаетесь зарегистрировать еще одну, например, реализацию интерфейса, но ее нужно регистрировать только если не было зарегистрации до этого.
605.72 608.24 "Игорь Лабутин" Раньше performance немножко страдал, теперь стал побольше.
608.24 609.24 "Игорь Лабутин" Побольше, получше.
609.24 610.24 "Игорь Лабутин" Вот.
610.24 611.24 "Игорь Лабутин" Тоже посмотрите.
611.24 618.84 "Игорь Лабутин" DI в принципе штука важная и ценная, возможно вы там найдете что-то интересное для вашего кода.
618.84 622.80 "Игорь Лабутин" Отдельная статья про color argument expression.
622.80 633.84 "Игорь Лабутин" Это такой забавный атрибут, мы его много раз упоминали, он был реализован очень давно как атрибут, но его поддержка именно действия стала работать только в шестом дотнете.
633.84 652.84 "Игорь Лабутин" Он, напомню, передает в качестве аргумента, в тот аргумент, который помечен вот этим атрибутом, будет передано выражение, которое собственно в вызов функции было передано прямо в текстовом виде, то есть он строчкой передается, и он обычно используется во всяких там assertions удобно использовать и так далее.
652.84 659.84 "Игорь Лабутин" Вот как раз таки Microsoft использовал этот атрибут в новых хелперах для выкидывания exceptions.
659.84 683.60 "Игорь Лабутин" То есть если раньше вы писали в коде if argument is not, ну не равен null, то throw new argument null exception, или throw argument exception, или out of range exception, или еще что-нибудь, то теперь вы можете написать argument out of range exception .throwifnull и передать туда, например, имя аргумента, ну или что-нибудь.
683.60 691.20 "Игорь Лабутин" И вам выкинется exception, а в тексте exception будет собственно вот то выражение, которое вы передали в эту функцию.
691.20 694.72 "Игорь Лабутин" И тут добиваются на самом деле двух вещей.
694.72 704.32 "Игорь Лабутин" Во-первых, ну сокращается кусочек кода, вместо четырех строчек вы получаете одну, а во-вторых, такая функция кода становится меньше, и она с большей вероятностью, например, будет заинлайнена.
704.32 706.80 "Игорь Лабутин" Ну и в принципе код не разрастается.
706.80 711.28 "Игорь Лабутин" То есть приложение занимает меньше памяти, быстрее работает, вот это все.
711.28 712.88 "Игорь Лабутин" Так что в целом полезные изменения.
712.88 725.20 "Игорь Лабутин" Ну и последняя статья это, что делать если у вас есть приложение на пятом дотнете, вот то как мы привыкли, то есть класс стартов.cs, вот это все, в файл в смысле.
725.20 729.00 "Игорь Лабутин" И вы хотите его мигрировать на новый дотнет, то есть в минимум API.
729.00 730.00 "Игорь Лабутин" Что нужно сделать?
730.00 734.16 "Игорь Лабутин" Ну есть отдельная прям статья, по шагам рассматривающая этот процесс.
734.16 747.00 "Игорь Лабутин" Вот такие дела, набор статей, то есть он действительно как есть разных немножко может быть несвязанных углов, но он, наверное, действительно покрывает основные большие такие заметные изменения, которые произошли в шестом дотнете.
747.00 762.20 "Анатолий Кулаков" Да, Иван Андреевич, как всегда, прекрасный блог, если вас интересует ISP или в принципе вообще развитие дотнет фреймворка, вот Андрей про это подробно хорошо пишет, если вы вдруг не помните, то у него вышла прекрасная книга на английском языке и на русском тоже.
762.20 771.96 "Анатолий Кулаков" Поэтому если вам нравится, как пишет автор, он пишет довольно интересно, практично, всегда с множественными эскизами, прямо, красиво, то на книгу тоже посмотрите, она прекрасна.
771.96 774.40 "Анатолий Кулаков" Ну что ж, давай продолжим.
774.40 820.08 "Анатолий Кулаков" Я тут наткнулся на интересную статейку про то, как сделать HTTP Client, вот и не просто как сделать, в общем, а так рассмотрение нескольких подходов, насмотрение нескольких уровней и так как в нашем мире все больше и больше становится таких распределенных сейкас приложений, всяких микросервисов и всем микросервисам нужно с друг другом, конечно же, общаться, в изоляции они стоять никогда не будут и не хотят, вот, и соответственно повышается необходимость в написании различных HTTP Client для того, чтобы какому-то другому приложению заинсталлировать SDK-шку, дать строго типизированный нормальный дотнетовский клиент и он бы им стал общаться с нашим сервисом, а не писал бы руками какой-нибудь JSON и еще какую-нибудь глупость.
820.08 834.96 "Анатолий Кулаков" В общем, проблема, по-моему, понятна, она не менее важна, чем, опять же, запускать generic хосты, делать endpoints, программировать minimal API, но почему-то вот про другую сторону, про потребителя, про клиентов мало кто говорит.
834.96 839.56 "Анатолий Кулаков" Мне кажется, сейчас как раз хорошая статья для того, чтобы эту тему поднять.
839.56 846.72 "Анатолий Кулаков" И так, на самом деле у HTTP Client не так уж много задач.
846.72 854.80 "Анатолий Кулаков" Представим, что у нас сервис уже написан самый главный, у него наружу выставлен API, общаемся мы через JSON и через HTTP.
854.80 860.20 "Анатолий Кулаков" Вот, теперь нам нужно, от HTTP Client нужны элементарные шаги.
860.20 870.00 "Анатолий Кулаков" Во-первых, это засервизовать некий request, то есть некоторые данные, с помощью которых мы сможем обратиться к сервису и достать необходимые нам значения.
870.00 874.16 "Анатолий Кулаков" Далее, отослать это куда-то, по какому-то адресу.
874.16 880.64 "Анатолий Кулаков" Потом децерализовать данные, которые пришли от нашего сервиса, это может быть ответ или может быть какая-нибудь ошибка.
880.64 896.28 "Анатолий Кулаков" И, соответственно, проанализировать этот ответ и сгенерить какой-то вменяемый выхлоп от этого клиента для того, чтобы потребитель понял, что произошло или достал свои значения и как-то их обработал.
896.28 907.12 "Анатолий Кулаков" Вот такие банальные шаги, типа сделать респонс, отослать, получить, сделать реквест, отослать, получить респонс и как-то обработать, если были какие-то ошибки.
907.12 913.00 "Анатолий Кулаков" Вот, в принципе, и все, что требуется от HTTP Client, но когда мы начинаем это реализовать, все становится не так уж и просто.
913.00 926.36 "Анатолий Кулаков" Есть куча подводных камней, куча сложностей и сейчас мы вместе с автором статьи попробуем все это обойти, разобраться и посмотреть, какие же у нас подходы есть и какие выборы мы можем сделать для того, чтобы упростить себе жизнь.
926.36 929.12 "Анатолий Кулаков" Для начала, зачем вообще нужны клиенты?
929.12 939.76 "Анатолий Кулаков" Ну, во-первых, как я и сказал, это все-таки предоставить какой-то строго типизируемой удобную оболочку, которая позволяет ускорить время интеграции с другими микросервисами.
939.76 952.60 "Анатолий Кулаков" Допустим, если вы отдаете уже строго типизированное SDK клиента какому-то второму микросервису, то ему уже не нужно думать о том, как сформировать URL и как отформитировать значения, он просто берет и вызывает ваши методы.
952.60 954.84 "Анатолий Кулаков" Времени на это уходит в разы меньше.
954.84 970.68 "Анатолий Кулаков" Соответственно, этот SDK вы можете распространять с помощью банального Nuget и для того, чтобы установить пакет и начать общаться с вашим сервисом, практически ничем не отличается от того, что он будет общаться просто с каким-то классиком, который также из пакета мог бы получить.
970.68 980.68 "Анатолий Кулаков" Далее, с помощью HTTP клиента мы можем предоставить какой-то консистентный и понятный подход к общению с вашим сервисом.
980.68 995.96 "Анатолий Кулаков" То есть, вам не нужно думать, какие методы за какими вызывать, что вообще можно вызвать, а у нас есть понятные интерфейсы, понятный IntelliSense и уже какая-то документация может быть к этим методам, ясно, как с этим сервисом будет работать.
995.96 1004.60 "Анатолий Кулаков" Второе, это, соответственно, получение хоть какого-то контроля и управления тем, как с вашим сервисом будут общаться.
1004.60 1025.20 "Анатолий Кулаков" Опять же, если вам нужно добавить авторизацию, то вы в клиенте делаете понятные методы, которые требуют API-ключи и уже какая-то предсказуемость того, что будущие клиенты будут приходить к вам с правильными ключами, с правильными юзернеймами, она уже как-то более-менее начинает маячить на горизонте.
1025.20 1036.16 "Анатолий Кулаков" И, соответственно, для того, чтобы получить все эти преимущества, давайте подумаем, каким образом начинают писать обычно HTTP клиента.
1036.16 1045.16 "Анатолий Кулаков" Ну, скорее всего, вам нужен интерфейс, так как клиент это какой-то сервис, внутри которого есть логика, соответственно, для него должен быть какой-то интерфейс.
1045.16 1055.52 "Анатолий Кулаков" В общем, обычно этот интерфейс заканчивается на слово «клайент», и в данном случае автор статьи пишет для примера клиента к сервису «шуток».
1055.52 1066.04 "Анатолий Кулаков" В общем, есть какой-то API в интернете, который выдает шутки, у него есть понятные методы взять шутку по ее идентификатору, поискать шутку и так далее.
1066.04 1067.04 "Анатолий Кулаков" Банальные геты.
1067.04 1075.92 "Анатолий Кулаков" Соответственно, когда вы пишете HTTP клиент, у вас будет какой-нибудь метод, например, «серч» поискать какую-нибудь шутку по какому-то определению.
1075.92 1081.28 "Анатолий Кулаков" Соответственно, в аргументах он примет все необходимые параметры.
1081.28 1085.72 "Анатолий Кулаков" Из интересного в аргументы очень удобно передавать cancellation token.
1085.72 1096.36 "Анатолий Кулаков" Не то чтобы это была очень часто используемая штука, потому что cancellation token в HTTP клиенте единственное, что может сделать, это закрыть TCP соединение.
1096.36 1100.76 "Анатолий Кулаков" Никакой канцеляции HTTP протокол, естественно, не поддерживает и стандартом не предусмотрено.
1100.76 1113.52 "Анатолий Кулаков" Но закрытие TCP соединения это довольно дорогая операция, потому что установка нового соединения, это всегда требует кучу времени и ресурсов.
1113.52 1119.32 "Анатолий Кулаков" Поэтому этот способ признан мега плохим, но другого у нас, к сожалению, нет.
1119.32 1134.24 "Анатолий Кулаков" Если мы будем общаться, если у нас имплементация будет через какой-нибудь сигнал R или веб-сокет или еще что-нибудь, то у них там уже есть какие-то способы, каким образом хорошо можно практически бесплатно закрыть соединение, отменить запрос.
1134.24 1139.40 "Анатолий Кулаков" Но, к сожалению, в HTTP его нет, но то, что есть, этим и пользуемся.
1139.40 1143.20 "Анатолий Кулаков" Поэтому cancellation token всегда желательно передавать.
1143.20 1154.44 "Анатолий Кулаков" Второй особенностью является то, что мы возвращаем не просто объект, как результат запроса, а таск от объекта, потому что очевидно, что все запросы у нас будут ходить по сети.
1154.44 1164.28 "Анатолий Кулаков" Соответственно, у нас есть какой-то сетевой input и input output, и это должно быть асинхронно, это должны быть таски.
1164.28 1170.80 "Анатолий Кулаков" И, соответственно, можно вернуть какой-то децерализованный объект в виде строго типизированного классика.
1170.80 1178.00 "Анатолий Кулаков" В этом классике мы можем использовать какие-то примитивные вещи, и обычно такие классики называются DTO.
1178.00 1182.40 "Анатолий Кулаков" То есть это специальный класс, который соответствует некоторым критериям.
1182.40 1198.28 "Анатолий Кулаков" У них не должно быть конструкторов с параметрами, и у них должны быть примитивные свойства, которые обычно с публичным GET и с публичным set для того, чтобы децерализатор любой мог поставить туда необходимые значения, которые он достанет из JSON.
1198.28 1208.72 "Анатолий Кулаков" Да, как я уже сказал, мы используем JSON против HTTP для того, чтобы соблюсти более-менее стандарты, которые там всеми вообще приняты.
1208.72 1211.96 "Анатолий Кулаков" И чем примечательен .NET 5?
1211.96 1221.72 "Анатолий Кулаков" Тем, что у него добавилась поддержка System.txt JSON, напрямую в HTTP Client.
1221.72 1234.60 "Анатолий Кулаков" Для этого вам нужно подключить на Namespace System.net HTTP JSON, который сейчас входит в стандартный PCL, и, соответственно, там у вас появится куча экстенсионных методов для HTTP Client и HTTP Context.
1234.60 1244.68 "Анатолий Кулаков" И вы можете, непосредственно во время реквеста децерализовывать уже возвращаемые значения в JSON.
1244.68 1252.12 "Анатолий Кулаков" Раньше нам приходилось как-то отличать эти два процесса, то есть мы отдельно получали респонс, как-то его анализировали, а потом отдельно децерализовывали.
1252.12 1253.96 "Анатолий Кулаков" Сейчас же это все можно сделать одним методом.
1253.96 1265.16 "Анатолий Кулаков" Если у вас все хорошо, все вернулось, все децерализовалось, все статусы правильные, все коды хорошие, то это просто одна строка, которая читабельная, красивая, которая сама сходит и сама же децерализует.
1265.16 1268.92 "Анатолий Кулаков" Соответственно, имплементация клиентов будет совсем простая.
1268.92 1274.68 "Анатолий Кулаков" Вам достаточно взять HTTP Client и сходить по указанному урлу и децерализовать все, что нужно децерализовать.
1274.68 1286.92 "Анатолий Кулаков" Еще один интересный подход автор предлагает – это хранить все урлы в определенном статическом классе отдельно от клиента, просто собрать вот такую коллекцию урлов.
1286.92 1302.76 "Анатолий Кулаков" Все эти урлы, естественно, будут с строчками, но так как они находятся в одном месте, очень удобно их обозревать, менять и поддерживать, если вдруг они не поменяются или вам нужно перейти на какой-нибудь новый урл, на какую-нибудь новую версию этого урла.
1302.76 1315.40 "Анатолий Кулаков" Соответственно, могут возникнуть проблемы, если урлы вам нужно конструировать каким-то образом сложно, то есть добавлять там какие-то пути, добавлять ID-шники, может быть, какие-то параметры еще туда засовывать, query аргументы и так далее.
1315.40 1322.72 "Анатолий Кулаков" В общем, если у вас есть сложные урлы, то можно обратиться к библиотеке, которая называется Flourle.
1322.72 1342.32 "Анатолий Кулаков" Это библиотека, которая позволяет вам удобно форматировать вот эти урлы, добавлять сегменты, экранировать, скейпить и, в общем, хороший такой урл-билдер, по сути, получается, но не тот стандартный, который есть, который очень сильно ограничен, а более гибкий, более продвинутый.
1342.32 1345.04 "Анатолий Кулаков" Удобная библиотечка, посмотрите, если вам это актуально.
1345.04 1351.52 "Анатолий Кулаков" Еще, в общем, полезно для ваших HTTP клиентов, оставлять точки конфигурации.
1351.52 1361.64 "Анатолий Кулаков" Это могут быть какие-нибудь обязательные хедра, которые вы туда прописываете, это может быть какая-то конфигурация ограничений, лимитов.
1361.64 1377.92 "Анатолий Кулаков" Например, вы можете прописать туда какие-то credentials или какой-нибудь API-токен, который должен быть для вашего сервиса обязательным, или прописать какие-нибудь общепринятые accept хедра, то есть в каком формате вы можете вернуть ответы.
1377.92 1388.00 "Анатолий Кулаков" В общем, вот такая точка, которая принимает в качестве аргумента HTTP клиента и потом этого клиента каким-то образом настраивает, ее тоже очень полезно вынести отдельно.
1388.00 1390.88 "Анатолий Кулаков" Зачем вынести отдельно, это мы сейчас рассмотрим.
1390.88 1397.76 "Анатолий Кулаков" Теперь давайте посмотрим на время жизни, соответственно, нашего HTTP клиента.
1397.76 1412.72 "Анатолий Кулаков" У любого клиента должен быть конструктор, и в этом конструкторе нам приходится принимать HTTP клиент, то есть наш API клиент для определенного сервиса должен принять к себе HTTP клиент.
1412.72 1420.92 "Анатолий Кулаков" HTTP клиент это как раз-таки та центральная точка, которая будет делать непосредственно всю эту работу, ходить куда-то, лукапить что-то, децерализовывать как-то.
1420.92 1424.08 "Анатолий Кулаков" В общем, точка HTTP клиента нам в любом случае нужна.
1424.08 1437.40 "Анатолий Кулаков" HTTP клиент имплементирует Disposable интерфейс, соответственно, вы должны обязательно его в конце концов диспозить, если сами его создавали, потому что у него есть Unmanaged ресурсы, он как раз-таки держит TCP соединения.
1437.40 1446.76 "Анатолий Кулаков" И в старых версиях HTTP клиента, ну в принципе, наверное, и в новых на этом можно напороться, но в общем, существует такой распространенный ошибка.
1446.76 1457.04 "Анатолий Кулаков" Когда вы создаете кучу-кучу HTTP клиентов, у вас постепенно на одной машине выедаются все TCP коннекции, потому что TCP коннекции на одной машине, они ограничены.
1457.04 1459.92 "Анатолий Кулаков" И ограничены не так сильно, как вам всем кажется.
1459.92 1473.08 "Анатолий Кулаков" В общем, очень легко можно сожрать все порты, все коннекции, и просто-напросто больше у машины не будет возможности создавать никакие соединения, и они будут отваливаться прямо даже не начавшись.
1473.08 1486.40 "Анатолий Кулаков" Вот, и это более-менее ответ на очень частый в интернете вопрос, а должен ли я сам создавать HTTP клиенты на каждый запрос, или мне нужно его один раз создать во время старта приложения, и вот один раз его везде использовать.
1486.40 1494.04 "Анатолий Кулаков" В общем, создавать каждый раз его точно нельзя, вы поняли почему, потому что это отъедает все HTTP коннекции.
1494.04 1504.12 "Анатолий Кулаков" И обычно рекомендуют создавать единственный экземпляр, но в принципе не на весь аппликейшен, а более-менее на какие-то сервисы, на какие-то контроллеры.
1504.12 1508.92 "Анатолий Кулаков" Ну в общем, несколько HTTP клиентов на приложение создавать это вполне нормально.
1508.92 1514.00 "Анатолий Кулаков" Чем же плохо создавать HTTP клиент просто на все время жизни приложения?
1514.00 1525.48 "Анатолий Кулаков" С этим тоже связан интересный баг, который в принципе починили только в свежих версиях дот-нета, и баг этот заключался в том, это даже не баг, это такой дизайн-просчет.
1525.48 1543.88 "Анатолий Кулаков" Баг заключался в том, что так же точно во время жизни всего HTTP клиента кэшировались имена DNS, то есть DNS TTL он не учитывался, и соответственно DNS никогда не апдейтился.
1543.88 1557.32 "Анатолий Кулаков" И если вдруг у вас какой-то сервис, с которым вы общаетесь упал и переподнялся на другом адресе, ну с микросервисами это нормально, потому что там адреса могут быть абсолютно динамическими, и как они называются, неважно.
1557.32 1563.40 "Анатолий Кулаков" Для него важно, что он обновил в DNS свою запись, что теперь к нему нужно ходить по другому адресу.
1563.40 1576.12 "Анатолий Кулаков" Но так как у вас HTTP клиент может быть синглтоном и жить вечно, и поэтому он ничего не знает о том, что поменялся адрес этого сервиса, и продолжает долбиться по старому адресу, естественно ничего там не находит.
1576.12 1584.24 "Анатолий Кулаков" Вот поэтому подход с единственным клиентом на весь аппликейшн это тоже не очень правильно, есть свои минусы.
1584.24 1595.56 "Анатолий Кулаков" Вот и соответственно желательно, чтобы все эти TCP соединения они иногда пересоздавались.
1595.56 1603.68 "Анатолий Кулаков" То есть вам нужен некий пул TCP соединений для того, чтобы иногда их диспозировать, для того, чтобы иногда обновлялся список DNS.
1603.68 1610.72 "Анатолий Кулаков" И вот как раз это именно то, что и делает HTTP Client Factory, которая появилась в последних версиях фреймворка.
1610.72 1624.12 "Анатолий Кулаков" HTTP Client Factory она и нужна как раз таки для того, чтобы не задумываться над этим вопросом, создавать вам HTTP Client или не создавать, или как часто создавать, или сколько его нужно сделать на приложение.
1624.12 1629.72 "Анатолий Кулаков" И это теперь рекомендованный путь для того, чтобы общаться по HTTP.
1629.72 1643.44 "Анатолий Кулаков" И каждый раз, когда вы вызываете у HTTP Client Factory создать нового HTTP Client, на самом деле она создает вам новый объект HTTP Client и возвращает для использования.
1643.44 1650.88 "Анатолий Кулаков" Но внутри HTTP Client переиспользует HTTP Message Handler, а уже HTTP Message Handler он пулится.
1650.88 1656.16 "Анатолий Кулаков" То есть он таки как раз переюзывается и именно он держит TCP коннекцию.
1656.16 1659.24 "Анатолий Кулаков" Именно этот handler обрабатывает открытие и закрытие.
1659.24 1668.36 "Анатолий Кулаков" И уже внутри эта фабрика уже сама знает не пора ли нам обновить DNS, не пора ли нам пересоздать эти коннекции и прочие оптимизации на уровне коннекции.
1668.36 1671.28 "Анатолий Кулаков" Она ими уже сама управляет, она уже сама ими жонглирует.
1671.28 1674.92 "Анатолий Кулаков" Вам об этом ни о чем задумываться не надо.
1674.92 1678.44 "Анатолий Кулаков" Соответственно вернемся к нашей теме.
1678.44 1687.76 "Анатолий Кулаков" Для того, чтобы вам заиспользовать нормального API Client, custom API Client, то есть создать своего, вам в конструкторе необходимо принять HTTP Client.
1687.76 1698.88 "Анатолий Кулаков" И соответственно если вдруг вы работаете под старыми фреймворками или еще где-то, или по каким-то другим причинам вы хотите напрямую создать HTTP Client, то вы тоже можете это сделать.
1698.88 1708.64 "Анатолий Кулаков" Создать обычного HTTP Client, вызвать метод Configure, который я описал выше, который поднастроит все наши custom хидра, настройки, оптимизации, сжатия и прочее.
1708.64 1713.76 "Анатолий Кулаков" И вернуть соответственно пользователю, который будет дальше использовать строго типизированный клиент.
1713.76 1719.28 "Анатолий Кулаков" Но в последних версиях фреймворка у нас есть более легкий путь, который связан с Dependency Ejection.
1719.28 1728.72 "Анатолий Кулаков" И там у нас есть такие удобные параметры, такие удобные методы, как создание именованных API Client и строго типизированных API Client.
1728.72 1736.48 "Анатолий Кулаков" В общем, мне кажется именовые API Client это такая промежуточная прослойка между чем-то старым и чуть ли не до новым.
1736.48 1744.48 "Анатолий Кулаков" Потому что все есть этот подход на основании строчек, сделать как зарегистрировать какого-то клиента, потом на основании строчек его как-то вызывать.
1744.48 1747.08 "Анатолий Кулаков" В общем, все это какие-то полумеры.
1747.08 1749.72 "Анатолий Кулаков" Нормальный подход это конечно же Typeit Client.
1749.72 1752.88 "Анатолий Кулаков" Это примерно похоже на то, что мы сейчас с вами и делаем.
1752.88 1758.76 "Анатолий Кулаков" То есть это строго типизированный клиент с понятными какими-то аргументами, методами, параметрами.
1758.76 1768.52 "Анатолий Кулаков" И единственное чем он отличается от всего остального, он в конструкторе принимает HTTP Client, который ему любезно сообщит в DI Container.
1768.52 1771.32 "Анатолий Кулаков" Соответственно в DI Container такие штуки регистрируются довольно просто.
1771.32 1781.08 "Анатолий Кулаков" Вы напросто делаете add HTTP Client и в этот generic метод передаете ваш клиент и ваш интерфейс, который вы хотите зарегистрировать.
1781.08 1797.00 "Анатолий Кулаков" И соответственно после регистрации вы также можете легко у DI запросить required service по вашему интерфейсу и он вам вернет строго типизированный, понятный, красивый интерфейсик, который вы только что заимплементировали.
1797.00 1801.92 "Анатолий Кулаков" Тут хочется подчеркнуть отдельно, что весь этот подход никак не зависит от ISP.NET.
1801.92 1806.44 "Анатолий Кулаков" Вы это вполне можете делать в консольном приложении регистрировать, это в винформах можно регистрировать.
1806.44 1809.00 "Анатолий Кулаков" В общем везде, где вам только заблагорассудится.
1809.00 1817.80 "Анатолий Кулаков" Желательно конечно, чтобы у вас был стандартный Microsoft с HDI Container, потому что там очень много вот этих полезных утилит для регистрации именно HTTP клиентов.
1817.80 1825.60 "Анатолий Кулаков" Очень часто проблемой, задачей, когда мы пишем HTTP клиенты, получается кросс-катинг консерны.
1825.60 1832.12 "Анатолий Кулаков" То есть это то, о чем мы с вами беседовали, когда в прошлых выпусках обсуждали месседжинг.
1832.12 1864.16 "Анатолий Кулаков" Соответственно, если вы принимаете какой-то запрос и как-то его обрабатываете, вам очень хотелось бы сделать обычно такие банальные вещи, как залогировать там допустим начало и конец, замерить время выполнения этого запроса, произвести аутентификацию, сделать какие-нибудь кэширования, часто каких-нибудь долгих или тяжелых каких-нибудь запросов, может быть переписать каким-то образом хидра, может быть сделать аудит тех записей, которые приходят и тех значений, которые возвращаются.
1864.16 1866.48 "Анатолий Кулаков" То есть что-то общее для каждого запроса.
1866.48 1869.44 "Анатолий Кулаков" И при этом писать в каждом запросе было бы это глупо.
1869.44 1870.84 "Анатолий Кулаков" Такие повторяющиеся вещи.
1870.84 1875.08 "Анатолий Кулаков" Можно забыть, пропустить и вообще это загромождает бизнес логику.
1875.08 1884.00 "Анатолий Кулаков" Поэтому существует такая вещь как кросс-катинг консерн, то есть те штуки, которые вы хотите делать на каждый запрос.
1884.00 1887.64 "Анатолий Кулаков" И у HTTP клиента есть такая прекрасная вещь, которая называется Message Handler.
1887.64 1898.24 "Анатолий Кулаков" Message Handler это банальный очень интерфейс, который просто-напросто принимает HTTP request по интерфейсу и возвращает HTTP response.
1898.24 1907.64 "Анатолий Кулаков" Что он сделает в промежутке, вызовет ли он вообще следующий метод, как-то он переделает request или response, это уже полностью на его ответственности.
1907.64 1913.08 "Анатолий Кулаков" Соответственно, когда вы создаете новый HTTP клиент, вы можете передать туда список каких-нибудь хендлеров.
1913.08 1921.64 "Анатолий Кулаков" Также точно через DI-контейнер вы можете зарегистрировать у клиента билдера с помощью метода HTTP Message Handler, зарегистрировать какие-то хендлеры.
1921.64 1925.44 "Анатолий Кулаков" В общем хендлеры это есть вот эти своеобразные middleware.
1925.44 1935.16 "Анатолий Кулаков" Те кто из вас, кто писал middleware для ISP.NET Core, соответственно с этой концепцией уже знакомы и понимают каким образом она работает и для чего ее можно писать.
1935.16 1939.84 "Анатолий Кулаков" Это те же самые middleware, только немножко на другом уровне, на уровне HTTP клиентов.
1939.84 1956.16 "Анатолий Кулаков" Вот прекрасно в них то, что у них очень примитивный интерфейс, как я уже сказал, там буквально из одного метода и сторонние компании, сторонние фирмы, сторонние разработчики могут этот интерфейс имплементировать и добавлять вам кучу всего полезного для вашего HTTP клиента.
1956.16 1960.08 "Анатолий Кулаков" Например, рассмотрим парочку самых, наверное, полезных расширений.
1960.08 1962.08 "Анатолий Кулаков" Прежде всего это Polly.
1962.08 1972.88 "Анатолий Кулаков" Полли устанавливается как отдельный пакет из Nuget Store и из коробки имеет интеграцию с HTTP Client Factory, то есть он просто одним методом можете его добавить.
1972.88 1981.36 "Анатолий Кулаков" И самые популярные вещи, которые умеют делать Полли это retry и circuit breaker.
1981.36 1997.16 "Анатолий Кулаков" Проблема, которую он решает, состоит в том, что у вас сеть может падать, она ненадежна, у вас могут там замедляться пинги, у вас может на другом конце сервер быть очень занят или вообще сейчас рестартовать и хочется эти ситуации обрабатывать как-то стандартно.
1997.16 2000.48 "Анатолий Кулаков" Ну самое банальное это перезапрашивать несколько раз.
2000.48 2010.96 "Анатолий Кулаков" Вот если не банально, то перезапрашивать несколько раз с различными периодами ожидания, с различными алгоритмами повтора и так далее.
2010.96 2018.80 "Анатолий Кулаков" То есть это стандартный такой retry pattern и этот retry pattern надеется на то, что сервис рано или поздно каким-то образом восстановится.
2018.80 2030.64 "Анатолий Кулаков" То есть проявит какую-то сел диагностику или может быть перезагрузится или может быть переконфигурится, но теория состоит в том, что если его подождать, попытаться снова, то у вас когда-нибудь что-нибудь получится.
2030.64 2052.72 "Анатолий Кулаков" Вот, если например у вас в системе очень много ошибок и ошибки из одного сервиса ведут к ошибкам другого сервиса и вот такая лавина ошибок бывает настолько сильна, что сервис не может подняться только потому, что в него пытаются постоянно приходят новые запросы.
2052.72 2057.64 "Анатолий Кулаков" То есть мы пытаемся сто раз с помощью retry перезайти в один и тот же метод.
2057.64 2064.04 "Анатолий Кулаков" Вот от этого у сервиса начинают заканчиваться ресурсы и он от этого начинает плохо себя чувствовать.
2064.04 2068.52 "Анатолий Кулаков" В общем, чтобы решить эту проблему существует еще такой pattern как circuit breaker.
2068.52 2078.44 "Анатолий Кулаков" Это когда сервис просто-напросто, даже не сервис, а клиент, клиент просто-напросто выключает все запросы к этому сервису и дает ему какое-то время отдохнуть.
2078.44 2087.80 "Анатолий Кулаков" Вот и локально, если даже мы и будем просить этого клиента сходить к сервису, то ничего не происходить не будет до тех пор, пока там не произойдет какой-то определенный треш-холд.
2087.80 2090.68 "Анатолий Кулаков" И после этого треш-холда мы попытаемся еще один раз.
2090.68 2091.68 "Анатолий Кулаков" Но только один раз.
2091.68 2097.88 "Анатолий Кулаков" Если там ответ вернется, что сервис все еще недоступен, мы опять будем ждать и отклонять локально все запросы.
2097.88 2105.96 "Анатолий Кулаков" Таким образом мы можем дать ему там продышаться, можем дать ему какое-то время на освоение дополнительных ресурсов и дальше продолжить работу.
2105.96 2118.44 "Анатолий Кулаков" И вот соответственно библиотека Poly, она не только имеет вот эти два паттерна, которые я рассказал, в ней внутри есть вообще куча всего интересного, что можно сделать, каким образом можно увеличить стабильность вашего соединения.
2118.44 2128.04 "Анатолий Кулаков" Кроме Retriever и Silky Bracket, там есть обработка Fallback на какие-то другие сервисы, если вдруг первый сервис у нас недолго не отвечает.
2128.04 2135.08 "Анатолий Кулаков" Есть Bulkhead Isolation, обработка Timeout, там же можно встроить туда кэширование очень удобно.
2135.08 2143.32 "Анатолий Кулаков" В общем библиотека очень мощная и полезная, про нее можно говорить долго, может быть если будет интересно, мы разберем ее отдельно.
2143.32 2151.80 "Анатолий Кулаков" Вот второй интересный пакет, который можно подключить к нашему HTTP клиенту, это Identity Module ISP.net Core.
2151.80 2158.68 "Анатолий Кулаков" Этот пакет вам будет полезен, если вы хотите обрабатывать пользователи и их аксесс токены.
2158.68 2173.08 "Анатолий Кулаков" С помощью этого пакета можно как бы получать, парсить, кэшировать и ротировать токены для вашего приложения, если вы вдруг хотите сделать какую-то security, какую-то проверку под подписи, проверку сертификатов и так далее.
2173.08 2176.24 "Анатолий Кулаков" То есть тоже очень удобная клиентская библиотека.
2176.24 2180.60 "Анатолий Кулаков" Дальше нам нужно как-то нашего HTTP клиента протестировать.
2180.60 2185.40 "Анатолий Кулаков" И здесь нам на помощь приходит как раз таки HTTP Message Handler.
2185.40 2192.88 "Анатолий Кулаков" Как я уже говорил, он очень примитивный и может делать абсолютно все, что угодно и с реквестами, и с респонсами.
2192.88 2207.48 "Анатолий Кулаков" Соответственно идея простая, мы просто-напросто берем HTTP Message Handler и настраиваем его таким образом, чтобы на определенный реквест, допустим по определенному урлу, у нас отдавался замоканный, захардкоженный какой-то респонс.
2207.48 2219.60 "Анатолий Кулаков" И если мы такой HTTP Handler добавим в нашего клиента, то мы сможем без похода на какой-то удаленный сервис возвращать себе определенные респонсы.
2219.60 2230.08 "Анатолий Кулаков" Это даст нам возможность протестировать то, как наш клиент работает с аргументами, какие он заголовки туда проставляет, как он обрабатывает респонсы, может ли он правильно обрабатывать ошибки, правильно ли он децерализует.
2230.08 2234.04 "Анатолий Кулаков" То есть все эти вещи мы можем проверить без фактического сервера.
2234.04 2235.24 "Анатолий Кулаков" То есть никуда нам ходить не надо.
2235.24 2236.88 "Анатолий Кулаков" Вот тоже удобная штука.
2236.88 2249.72 "Анатолий Кулаков" Но это тест такой, можно в принципе назвать его более-менее юнит тестом, но вся мощь, вся сила HTTP клиентов, она как раз и заключается в таких сквозных функциональных интеграционных end-to-end тестах.
2249.72 2254.64 "Анатолий Кулаков" То есть мы все-таки должны были бы по идее сходить до контроллера, там все отработать, вернуть его назад.
2254.64 2259.56 "Анатолий Кулаков" В общем это тоже нужно делать, но здесь просто никаких особенностей о которых нужно говорить нет.
2259.56 2262.44 "Анатолий Кулаков" То есть берете, ходите и делаете.
2262.44 2269.08 "Анатолий Кулаков" И если кратко подвести итог такому подходу, который мы с вами описали, у него есть куча плюсов и куча минусов.
2269.08 2281.80 "Анатолий Кулаков" Из плюсов - это конечно же полный контроль над тем, каким образом у нас формируются запросы, каким образом децерализуются ответы, все структуры данных, которые мы туда передаем и которые получаем.
2281.80 2287.00 "Анатолий Кулаков" Вот это мы все полностью контролируем, полностью поддерживаем и очевидно, что там происходит.
2287.00 2289.52 "Анатолий Кулаков" Также у нас полный контроль над сервизацией и децерализацией.
2289.52 2294.84 "Анатолий Кулаков" Мы можем подменить сервизаторы, какие-то их поднастроить, все это полностью в наших руках.
2294.84 2300.88 "Анатолий Кулаков" Этот подход очень хорош для дебага и решения каких-то проблем, если что-то не получается.
2300.88 2307.60 "Анатолий Кулаков" Потому что весь код у нас под руками, ставим точку останова на http-клайнте, видим все респонсы, видим все http-коды.
2307.60 2310.88 "Анатолий Кулаков" Все очевидно, понятно и просто.
2310.88 2316.84 "Анатолий Кулаков" Но также здесь очень много, даже не много, а очень большие минусы есть.
2316.84 2323.84 "Анатолий Кулаков" Дело в том, что для того, чтобы создать такой http-клайнт и заимплементировать, вам нужно писать очень много кода.
2323.84 2326.20 "Анатолий Кулаков" И часто этот код будет повторяющимся.
2326.20 2332.40 "Анатолий Кулаков" То есть составить там URL, отправить его клиенту, обработать ошибки, децерализовать и так далее.
2332.40 2338.96 "Анатолий Кулаков" Конечно, все это как-то постепенно уходит во всякие методы хелперы, во всякие методы расширения.
2338.96 2351.72 "Анатолий Кулаков" Но то, что этот код довольно скучен, однообразен и его много, особенно если у вас большие сервисы, очень много контроллеров, очень много методов, от этого никуда не уйти.
2351.72 2356.88 "Анатолий Кулаков" И поэтому написание таких клиентов бывает не всегда самым веселым занятием.
2356.88 2364.32 "Анатолий Кулаков" И соответственно, вам нужно каким-то образом поддерживать эту кодовую базу, потому что API они постоянно живут, они обычно расширяются.
2364.32 2373.48 "Анатолий Кулаков" Будет хорошо, если они все-таки не меняются в breaking change сторону, то есть будем рассчитывать только на хорошие, они улучшаются, добавляются и изменяются.
2373.48 2375.60 "Анатолий Кулаков" И это все вам нужно поддержать ручками.
2375.60 2383.92 "Анатолий Кулаков" То есть опять же, писать новые сигнатуры, писать новые константы с URL, каким-то образом обрабатывать новые исключения, если они появятся.
2383.92 2385.72 "Анатолий Кулаков" Все это довольно непросто.
2385.72 2394.76 "Анатолий Кулаков" Из-за этих проблем появились и другие подходы, каким образом нам писать HTTP клиенты.
2394.76 2397.16 "Анатолий Кулаков" Давайте на них остановимся подробнее.
2397.16 2400.76 "Анатолий Кулаков" Самый первый - это декларативный подход.
2400.76 2407.92 "Анатолий Кулаков" Соответственно, декларативный подход нам не говорит, каким образом мы должны ходить к серверу, как должны мы это делать.
2407.92 2409.36 "Анатолий Кулаков" Он нам говорит, что надо сделать.
2409.36 2412.96 "Анатолий Кулаков" Соответственно, у нас уже получается намного меньше кода.
2412.96 2414.76 "Анатолий Кулаков" А чем меньше кода, тем меньше багов.
2414.76 2418.28 "Анатолий Кулаков" Поэтому такой подход тоже имеет право на жизнь.
2418.28 2423.36 "Анатолий Кулаков" И типичным представителем библиотеки, которая позволяет такое чудо реализовать является Refit.
2423.36 2431.32 "Анатолий Кулаков" Refit - это специальная библиотека, которая превращает ваш интерфейс клиента в настоящего клиента.
2431.32 2448.96 "Анатолий Кулаков" То есть вы пишете ровно интерфейс, который мы с вами обсуждали в начале, какой-нибудь custom API-клиент, обозначаете ему сигнатуры, которые вы хотите, чтобы этот интерфейс имплементировал, например, сходить за шуткой, найти шутку, скачать шутку и все.
2448.96 2451.32 "Анатолий Кулаков" И вы не занимаетесь имплементацией.
2451.32 2460.40 "Анатолий Кулаков" Самое прекрасное, что всю имплементацию, все создания HTTP-клиентов, обработка респонсов, формирование реквестов - Refit берет на себя.
2460.40 2463.52 "Анатолий Кулаков" Он полностью имплементирует вам этот интерфейс.
2463.52 2470.72 "Анатолий Кулаков" Для того, чтобы помочь ему правильно это сделать, на методы этого интерфейса необходимо навесить несколько атрибутиков.
2470.72 2474.36 "Анатолий Кулаков" Прежде всего, это атрибут, который определяет метод и URL.
2474.36 2481.40 "Анатолий Кулаков" То есть вы говорите GET по такому-то URL будет мне вызывать вот search joke.
2481.40 2486.48 "Анатолий Кулаков" Далее соответственно Refit генерирует вам полностью имплементацию этого клиента.
2486.48 2490.08 "Анатолий Кулаков" Вы можете этого клиента очень легко создать с помощью специальной статической фабрики.
2490.08 2500.52 "Анатолий Кулаков" Можете также точно зарегистрировать его в DI-контейнере с помощью одной команды addRefitClient, который тоже входит в пакет и в принципе чувствует себя великолепно.
2500.52 2503.20 "Анатолий Кулаков" Надо признать, что у Refit довольно отличные настройки.
2503.20 2510.64 "Анатолий Кулаков" То есть вы можете кастомизировать сервис, вы можете кастомизировать какую-то кастомную обработку ошибок, еще что-то делать.
2510.64 2513.64 "Анатолий Кулаков" То есть настройки довольно гибкие, довольно хорошие и довольно полезные.
2513.64 2518.12 "Анатолий Кулаков" И соответственно этот подход убирает у вас большую часть вашей боли.
2518.12 2519.88 "Анатолий Кулаков" То есть никакой имплементации писать не надо.
2519.88 2526.48 "Анатолий Кулаков" Просто напишите интерфейс, определите URL, определите HTTP методы и все остальное Refit сделает за вас.
2526.48 2533.60 "Анатолий Кулаков" Это довольно зрелый проект, который давно уже показывает хорошие результаты, написан довольно качественно, хорошо.
2533.60 2540.48 "Анатолий Кулаков" Соответственно из плюсов можно выделить, что теперь поддержка и создание HTTP Client становится намного проще.
2540.48 2544.60 "Анатолий Кулаков" Никакой имплементации, просто напишите интерфейс с теми методами, которые нужны и все.
2544.60 2547.28 "Анатолий Кулаков" Высокая конфигурация, как я уже сказал, этого проекта.
2547.28 2554.76 "Анатолий Кулаков" Он довольно гибкий, хорошо настраивается и соответственно нет необходимости в каких-то дополнительных тестированиях.
2554.76 2570.36 "Анатолий Кулаков" То есть сквозное тестирование вам в любом случае будет нужно и оно будет тестировать все ваше приложение, но никаких unit-тестов здесь производить не нужно, потому что методы полностью декларативные, здесь нет никакой логики, ничего подобного проверять вам не нужно.
2570.36 2573.12 "Анатолий Кулаков" Минусы у этого подхода тоже, к сожалению, есть.
2573.12 2578.68 "Анатолий Кулаков" Во-первых, это очень сложно выявлять какие-то ошибки, если вдруг что-то работает не так.
2578.68 2587.96 "Анатолий Кулаков" Потому что код сгенерированный и, насколько я знаю, сейчас еще он сгенерирован не на Source-генераторах, то есть это runtime-генерация или генерация.
2587.96 2595.40 "Анатолий Кулаков" То есть дебажить такое чудо, если вдруг что-то не так, бывает весьма проблематичным.
2595.40 2613.44 "Анатолий Кулаков" Другой минус, соответственно, это какая-то внешняя библиотека и необходимо, чтобы все члены команды, которые используют эту библиотеку, которые ее поддерживают, понимали, как она работает, умели с ней работать, ну и хотели с ней работать, иначе кто-то придет для того, чтобы расширить какие-то новые API и не будет понимать, что же ему делать.
2613.44 2616.32 "Анатолий Кулаков" В общем, какой-то новый порог вхождения сюда тоже нужно иметь в виду.
2616.32 2634.00 "Анатолий Кулаков" И, соответственно, если мы все-таки говорим про большие API, про огромные API, когда вам нужно писать там 200 клиентов у каждого по 100-500 методов, этот подход все еще проблематичен, потому что вам все еще руками нужно обозначать все сигнатуры и описывать все урлы.
2634.00 2637.92 "Анатолий Кулаков" Казалось бы, от этого никуда не деться, но на самом деле нет.
2637.92 2651.36 "Анатолий Кулаков" Существует еще третий подход, который позволяет вам сгенерировать полностью автоматически всего клиента и вместе с урлами, и вместе с интерфейсами, и вместе с синтаксисом и имплементацией, просто вместе со всем.
2651.36 2656.04 "Анатолий Кулаков" Конечно же я говорю об OpenAPI, также известном в народе как Swagger.
2656.04 2670.72 "Анатолий Кулаков" Swagger - это специальная спецификация, которая имеет свою схему, свой стандарт и описывает в JSON полностью все ваши API-вызовы, все ваши API-точки, все ваши endpoints, контроллеры.
2670.72 2683.64 "Анатолий Кулаков" В общем, у нее есть знание о адресах, о методах, о документации, о всех параметрах, аргументах и даже о тех ошибках, о тех статус-кодах, которые могут эти endpoints вернуть.
2683.64 2700.16 "Анатолий Кулаков" В стандартном шаблоне ASP.Core Swagger включен по умолчанию, то есть OpenAPI у вас сгенерируется, с этим нет никаких проблем, поэтому единственное, что вам остается, это просто-напросто по этой спецификации сгенерить клиента.
2700.16 2707.60 "Анатолий Кулаков" Существует довольно много инструментов, которые позволяют делать такое чудо, наверное, одним из самых популярных является NSwag.
2707.60 2715.84 "Анатолий Кулаков" NSwag - это проект, который позволяет вам в том числе, кроме всего остального, и генерить клиентов на основании спецификации.
2715.84 2727.44 "Анатолий Кулаков" Также можно упомянуть AfterEffects, Visual Studio Connected Service, они работают по такому же принципу, они умеют по какой-то спецификации генерить клиентов.
2727.44 2743.16 "Анатолий Кулаков" Соответственно, обычно такие инструменты распространяются в виде каких-нибудь command-line tools, которые можно поставить независимо через NuGet и вызвать для определенной спецификации.
2743.16 2758.64 "Анатолий Кулаков" Спецификацию очень легко получить, если вы запустите ваше приложение и зайдете по определенному url, там /swagger, вы увидите какой-нибудь UI, наверняка, который поможет протестировать ваш API, и у этого UI там будет ссылочка специально именно на файл спецификации.
2758.64 2768.60 "Анатолий Кулаков" Его можно или скачать и отдать его в определенный инструмент, или же просто инструмент отравить на этот url, и тот сам вытащит всю необходимую информацию.
2768.60 2772.88 "Анатолий Кулаков" Соответственно, плюсы у такого подхода очевидны.
2772.88 2783.24 "Анатолий Кулаков" У вас получается полностью автоматизированный клиент, и вам не нужно писать практически ни строчки кода.
2783.24 2794.08 "Анатолий Кулаков" Он генерируется по общей принятой спецификации, и соответственно, эта спецификация поддерживается не только для генерации клиентов, но и в множестве других инструментов.
2794.08 2805.00 "Анатолий Кулаков" Например, для составления документации, для гибкого тестирования, для описания схемы взаимодействия между различными сервисами.
2805.00 2807.88 "Анатолий Кулаков" В общем, очень много где используется Swagger.
2807.88 2812.08 "Анатолий Кулаков" Это реально мощная вещь, потому что ее все-таки догадались стандартизировать.
2812.08 2816.12 "Анатолий Кулаков" Далее у нас получается очень большая автоматизация.
2816.12 2831.60 "Анатолий Кулаков" То есть, новые SDK, например, вот новые SDK с клиентами, они могут генериться каждый раз, когда вы, допустим, собираете ваш SDK в Continuous Integration, и эти клиенты никогда не будут устаревать.
2831.60 2838.56 "Анатолий Кулаков" Тот SDK, который вы сейчас собираете, он будет опираться непосредственно на те контроллеры, которые вы только что запрограммировали.
2838.56 2851.00 "Анатолий Кулаков" Если вы там добавили какой-то параметр, то прямо как только вы закоммитите этот кусок кода, соберется новый SDK именно с этими параметрами, и выпустится версия именно конкретно для этого контроллера.
2851.00 2853.00 "Анатолий Кулаков" В общем, что не может не радовать.
2853.00 2856.88 "Анатолий Кулаков" То есть, поддерживать вручную все эти сигнатуры вам уже больше не нужно.
2856.88 2866.92 "Анатолий Кулаков" Еще одна прелесть стандарта этой спецификации заключается в том, что вы можете генерировать клиентов не только для .NET, не только для C#, но абсолютно для любого языка.
2866.92 2870.96 "Анатолий Кулаков" И соответственно, существует огромное количество инструментов, которые позволяют вам это сделать.
2870.96 2875.24 "Анатолий Кулаков" Вы один раз пишете свои контроллеры и получаете клиентов там для миллиона языков.
2875.24 2878.84 "Анатолий Кулаков" И с вашим сервисом уже может общаться не только .NET, но и все, кто угодно.
2878.84 2885.40 "Анатолий Кулаков" И соответственно, все эти клиенты, они поддерживаются автоматически, сигнатуры обновляются автоматически, и все происходит автоматически.
2885.40 2887.88 "Анатолий Кулаков" Вам практически ни о чем не нужно заботиться.
2887.88 2899.80 "Анатолий Кулаков" И довольно легкий troubleshooting, то есть довольно легко понять, в чем проблема, потому что весь код, который генерируется инструментами, он складывается рядом в виде исходного кода.
2899.80 2907.56 "Анатолий Кулаков" Он не перепаривается, у него есть символы, его можно распространять в source-link'ах и очень легко искать любые проблемы.
2907.56 2912.08 "Анатолий Кулаков" Казалось бы, все мега радужно, мега оптимистично и только так нужно и пользоваться.
2912.08 2915.60 "Анатолий Кулаков" Но давайте посмотрим на минусы.
2915.60 2919.56 "Анатолий Кулаков" Все-таки этот подход полностью опирается на спецификацию.
2919.56 2922.88 "Анатолий Кулаков" Соответственно, у вас должна быть OpenAPI спецификация.
2922.88 2931.32 "Анатолий Кулаков" Если ее нет, то соответственно, у инструментов нет исходного кода, из которого он берет все знания и пользоваться таким подходом нельзя.
2931.32 2936.72 "Анатолий Кулаков" Здесь, однако, стоит заметить, что подобную спецификацию не обязательно получать напрямую из сервиса.
2936.72 2938.44 "Анатолий Кулаков" Вы ее можете описать вручную.
2938.44 2946.44 "Анатолий Кулаков" И для этого существуют различные студии, различные DE, которые позволяют вам описывать OpenAPI именно ручками.
2946.44 2965.56 "Анатолий Кулаков" Соответственно, если у вас есть какой-то сторонний сервис, который не собирается вам ничего предоставлять в виде сваги спецификации, но вы хотите к нему как-то обращаться с помощью клиентов, вы всегда можете руками описать этот файлик и скормить его тулзам, которые любезно сгенерят вам клиента.
2965.56 2969.08 "Анатолий Кулаков" Этот подход довольно сложно кастомизировать.
2969.08 2980.84 "Анатолий Кулаков" В общем, все те контракты, вся эта генерация, все те параметры, которые там творятся внутри, они очень мощные, очень универсальные, но очень не гибкие.
2980.84 2986.32 "Анатолий Кулаков" Поэтому, если вам нужна какая-то сложная логика, какие-то сложные обработки, то, скорее всего, это не ваш аргумент.
2986.32 2993.60 "Анатолий Кулаков" И для меня самая большая проблема была, автор почему-то этого не учитывает, но для меня это вообще была критика.
2993.60 2998.40 "Анатолий Кулаков" Уязвимость этого подхода в том, что код очень-очень безобразен.
2998.40 3000.32 "Анатолий Кулаков" То есть он ужасен, он отвратителен.
3000.32 3006.40 "Анатолий Кулаков" Ни один нормальный разработчик в своем уме такую чушь не напишет, как написано в этих сгенерированных клиентах.
3006.40 3010.64 "Анатолий Кулаков" Если вы не собираетесь туда заглядывать, то, в принципе, может быть, это и сойдет.
3010.64 3020.96 "Анатолий Кулаков" Если вы любите красивый, понятный, предсказуемый и читабельный код, то лучше туда не смотреть, иначе этот подход вам никогда не подойдет.
3020.96 3024.44 "Анатолий Кулаков" Ну что ж, давайте подведем итоги.
3024.44 3027.08 "Анатолий Кулаков" Соответственно, мы рассмотрели с вами три подхода.
3027.08 3029.96 "Анатолий Кулаков" У каждого подхода есть плюсы, у каждого подхода есть минусы.
3029.96 3050.68 "Анатолий Кулаков" И если подводить общую черту, то, в целом, если вы хотите полностью контролировать весь ваш процесс, все ваши HTTP-клайенты, интеграции, сериализации, структуры, то вам нужно использовать подход с ручным написанием кастомного HTTP-клайента и, соответственно, с ручным контролем всех этих процессов.
3050.68 3068.60 "Анатолий Кулаков" Если вы мега занятой чувак и, соответственно, вам нужно все-таки создать клиентов с более-менее средним контролем того, что происходит внутри, то вам нужно использовать декларативный подход, тот, что я рассказывал про Refit.
3068.60 3090.40 "Анатолий Кулаков" Если же вы мега ленив и вам вообще все равно, что там происходит внутри, и вы не хотите ничего контролировать, вам нужно просто получить клиента и все, то тогда как раз автоматический подход с автогенерацией всего и вся с помощью NSWAG или подобных инструментов, наверное, вот это тот выбор, который будет идеален именно для вас.
3090.40 3093.12 "Анатолий Кулаков" Ну что, Игорь, ты какие подходы используешь?
3093.12 3095.28 "Анатолий Кулаков" Что тебе больше нравится?
3095.28 3103.92 "Игорь Лабутин" Мы используем ручные клиенты в части API и в части SDK, а частично мы генерируем свагером.
3103.92 3125.92 "Игорь Лабутин" Но мы не используем NSWAG, мы до сих пор пока живем на старом OpenAPI свагер, как он правильно называется, генераторе, который, к сожалению, еще использует REST#, и из-за этого там есть определенные проблемы, поэтому мы как раз недавно провели исследование, на что бы переключиться, выбрали NSWAG, ну вот теперь, видимо, будем в какой-то момент переходить на него.
3125.92 3132.12 "Анатолий Кулаков" А как вы определяете, какие клиенты у вас идут под NSWAG, а какие вы вручную пишете?
3132.12 3172.44 "Игорь Лабутин" Вручную мы пишем те, которые требуют, например, не JSON, то есть у нас есть несколько API, которые общаются с Message Pack, там ради перформанса было сделано и так далее, и там приходится просто, там по большому счету нужно послать дополнительный хетер, чтобы мы accepted Message Pack, и нужно написать правильную десериализацию, в самом деле только десериализацию, мы только на прием получаем Message Pack сериализованные данные, и это в NSWAG, ну и в тот генератор, который мы сейчас пользуемся, вообще не вписывалось, мы сгенерили код один раз, а дальше его уже руками правим, так как нам надо.
3172.44 3199.64 "Анатолий Кулаков" Я, в общем, обычно писал все клиенты вручную, потому что мне именно нравилась эстетика и продуманность каждого клиента, но надо признать, что у меня обычно было не так уж много API, чтобы этим загоняться, сейчас есть планы как-то писать намного больше клиентов, под много больше сервисов, под больше клиентов, поэтому скорее всего придется каким-то образом донастраивать естественным зубы, использовать это убожество в виде NSWAG.
3199.64 3221.56 "Игорь Лабутин" Ну у нас действительно довольно много API, у нас не так много для них есть SDK, то есть API многие public, но мы для них не делаем каких-то официальных SDK, прям вот в таком виде, то есть SDK сделаны только для тех случаев, когда мы точно знаем, что конечные кастомеры захотят именно из каких-то своего приложения использовать API.
3221.56 3224.60 "Анатолий Кулаков" Обычно кто использует ваши API, если не конечные
3224.60 3235.32 "Игорь Лабутин" кастомеры? Фронт, ну фронт и какие-то наши внутренние же сервисы, но из других команд, например, то есть другие продукты, экосистемы, назовем это так.
3235.32 3237.56 "Игорь Лабутин" Ну этим же сервисам нужны клиенты.
3237.56 3246.28 "Игорь Лабутин" Этим сервисам нужны клиенты, но не все эти сервисы написаны на интернете, они могут быть написаны вообще на чем угодно, и поэтому там на всех SDK не напишешь.
3246.28 3249.20 "Анатолий Кулаков" Ну да, да, опять же здесь наверное NSVAG вам может
3249.20 3256.36 "Игорь Лабутин" помочь. Да, то есть мы просто публикуем MSpec и пожалуйста берите соответственно на SFGер описание, генерите под свой родной язык, что хотите.
3256.36 3257.36 "Игорь Лабутин" Вот.
3257.36 3263.80 "Игорь Лабутин" А для дотнетчиков автосгенеренные есть SDK, собранные в Nugetik, которые соответственно можно просто завязать и использовать.
3263.80 3267.00 "Анатолий Кулаков" Ну отлично, я думаю, тему мы раскрыли хардшомом,
3267.00 3269.00 "Игорь Лабутин" пойдем дальше. Да, пойдем дальше.
3269.00 3280.04 "Игорь Лабутин" Дальше давайте затронем тот самый кусочек про дотнет7, который я немножко ранее обещал, а именно делегаты и метод групп конвершен, чтобы это не значило.
3280.04 3283.60 "Игорь Лабутин" Наверняка вы с этим сталкивались, конечно, но может быть не задумывались.
3283.60 3294.24 "Игорь Лабутин" Смотрите, предположим у нас есть функция, которая принимает какой-нибудь делегат, ну то есть там action.t или там func.t или еще что-нибудь в таком духе.
3294.24 3304.40 "Игорь Лабутин" И вы туда передаете, например, какую-нибудь функцию другую, ну то есть вы туда передаете какой-нибудь статический метод.
3304.40 3324.16 "Игорь Лабутин" Ну как пример, вы вызываете какой-нибудь select и в качестве вот этого не ляпочку туда пишите, x, стрелочка, что-нибудь, а прямо какой-нибудь статический метод этого же класса, который будет делать выборку того, что вам надо из объектов, которые лежат в списке, ну в коллекции.
3324.16 3334.60 "Игорь Лабутин" Если вы такое сделаете через лямбдочку, то ReSharper, например, вам подскажет, типа давайте использовать метод групп конвершен, чтобы вы не писали x, стрелочка, дальше имя функции, круглые скобочки.
3334.60 3339.72 "Игорь Лабутин" Ну то есть по сути вы как бы просто вызвали метод, от x причем.
3339.72 3347.44 "Игорь Лабутин" А давайте мы просто передадим имя этого метода и это будет называться метод групп, то что называется в дотунете.
3347.44 3362.24 "Игорь Лабутин" И все бы хорошо, так в принципе можно делать, но надо понимать, что если вы передаете метод групп, то есть просто имя метода указываете в качестве аргумента, то в этом случае при каждом вызове будет анноцироваться новый делегат.
3362.24 3372.48 "Игорь Лабутин" То есть если у вас этот код находится на каком-нибудь хот-пад, то на локациях делегатов вы можете довольно много набрать себе memory-трафика.
3372.48 3392.84 "Игорь Лабутин" Если же вы пишете туда лямбдочку, пусть даже вида x, стрелочка, имя метода и передать тот же самый x, казалось бы, ну действие какое-то странное, но тем не менее в этом случае, поскольку лямбда не использует внешних никаких зависимостей, то есть не капчирует ничего из внешних контекстов, такая лямбда будет закэширована.
3392.84 3398.24 "Игорь Лабутин" И соответственно будет создаваться только один раз и не будет никакого memory-трафика.
3398.24 3403.20 "Игорь Лабутин" И долгое время этого было поменять никак нельзя, почему?
3403.20 3415.52 "Игорь Лабутин" Потому что в спецификации якма 3.3.4 было написано, что при передаче с помощью метод групп обязательно нужно анноцировать каждый раз новый делегат.
3415.52 3417.16 "Игорь Лабутин" Это прям было написано в спецификации.
3417.16 3427.40 "Анатолий Кулаков" Ну тут и смешной момент состоит в том, что уже как бы кэшируются и локальные функции, и статические локальные функции, и что только там уже не кэшируется, вот кроме этой единственного метода группы.
3427.40 3429.60 "Анатолий Кулаков" Наверное именно из-за этой строчки в спецификации.
3429.60 3431.28 "Игорь Лабутин" Именно так, backward compatibility.
3431.28 3442.52 "Игорь Лабутин" Поэтому когда появился .NET Core версии 1.x, то вот в GitHub .NET Core в 2015 году появился issue.
3442.52 3446.92 "Игорь Лабутин" А давайте мы все-таки будем кэшировать статические вот эти методы группы.
3446.92 3454.44 "Игорь Лабутин" То есть если вы в метод группы передаете какой-нибудь статический метод, то есть он точно ничего не захватывает из контекста, то давайте мы его будем кэшировать.
3454.44 3463.20 "Игорь Лабутин" И как бы разработчики сказали, ну можно, но блин, спецификация же ну как-то не очень здорово.
3463.20 3475.32 "Игорь Лабутин" В итоге процесс небыстрый, поэтому к концу 2017 года, то есть прошло примерно 2 года, спецификация была обновлена и она теперь позволяет кэширование.
3475.32 3482.12 "Игорь Лабутин" Она не говорит, что там строго нельзя кэшировать, она говорит можно кэшировать, можно не кэшировать, как хотите.
3482.12 3495.40 "Игорь Лабутин" И наконец-таки в марте 2022 года, то есть прошло еще 4 года, в следующей версии Visual Studio 17.2 Preview 2 это будет реализовано.
3495.40 3502.08 "Игорь Лабутин" Ну в смысле это уже реализовано и оно сейчас уже замерзло в мастер, и оно выйдет в ближайшем превьюшке Preview 2.
3502.08 3507.96 "Игорь Лабутин" То есть прошло всего 6,5 лет и фичу мы наконец-таки сделали.
3507.96 3518.84 "Анатолий Кулаков" Да-да, интересно как раз только тот случай, что они в имплементации, не в сложности какой-то реализации, а в сложности договориться и сделать так, чтобы не нарушить спецификацию.
3518.84 3525.56 "Игорь Лабутин" Да, ну соответственно очень забавно посмотреть на ISH и там довольно длинное обсуждение с плюсами и минусами.
3525.56 3538.68 "Игорь Лабутин" И таким как бы между всеми этими комментариями обсуждений периодически появляются служебные изменения, типа поменяли, как там это называется, не релиз, а milestone.
3538.68 3555.28 "Игорь Лабутин" Поменяли milestone с 1x на 2x, с 2x на 3x, с 3x на 4x, ну на 4x не было, на 5x, и наконец-таки все, 7x поменяли и по-моему на 7.0 Preview 2, типа milestone все поменено и closed.
3555.28 3556.88 "Игорь Лабутин" Так что да, забавно.
3556.88 3567.72 "Игорь Лабутин" Но на самом деле забавно, что вот спека была поменена в конце 17-го года, то есть вроде все, готово, сделай, но почему-то вот оно ждало 7-го дотнета.
3567.72 3574.96 "Анатолий Кулаков" Ну наверное дали отстояться, чтобы по спеке все перешли альтернативные реализации на новый подход, изменили это у себя, все такое.
3574.96 3578.04 "Игорь Лабутин" А у нас можно сказать много альтернативных реализаций.
3578.04 3582.88 "Анатолий Кулаков" Не важно, может какие-то мы не знаем, это же спецификация, она ничего не знает об имплементации.
3582.88 3583.88 "Анатолий Кулаков" Это правда.
3583.88 3599.72 "Анатолий Кулаков" Ну вообще новость шикарная, я в принципе мега рад, потому что это как раз-таки был один из последних вот этих кругов ада в лямбдах, которые не давали закешироваться нормальным метод группам, который используется все-таки довольно часто, потому что они имеют компактный синтаксис.
3599.72 3605.20 "Анатолий Кулаков" Ну теперь мы наконец решили эту проблему и будем пользоваться красивым синтаксисом дальше.
3605.20 3606.20 "Игорь Лабутин" Да.
3606.20 3608.84 "Игорь Лабутин" Ну что, пойдем дальше.
3608.84 3612.88 "Игорь Лабутин" Дальше я немножко посмотрел в сторону EF Core.
3612.88 3634.24 "Игорь Лабутин" Мы в прошлый раз упоминали про превью 1.7 дотнета, там действительно не так много новостей про EF Core, они анонсировали какие-то планы, какой-то roadmap, но пока он довольно размытый и прям каких-то конкретных интересных штук из него вытащить мне не удалось, поэтому будем ждать появления новых превьюшек и уже обсуждения каких-то конкретных фич.
3634.24 3643.96 "Игорь Лабутин" А пока я решил вернушка вернуться назад, в каком-то смысле, обратиться к, страшно сказать, официальной документации EF Core.
3643.96 3653.24 "Игорь Лабутин" В этот раз мы обсуждаем не статью, а прям официальную документацию Microsoft про EF Core, про то, как же писать код, чтобы все работало быстро с EF Core.
3653.24 3679.44 "Игорь Лабутин" То есть, ну, многие знают, да, что под EF Core живет реальная база данных, как правило, и там довольно много чего может пойти не так, и поэтому у Microsoft есть прям отдельный большой набор разделов, статей на тему того, как правильно, о чем нужно думать, когда вы пишете код для работы с базой данных, чтобы все работало быстро.
3679.44 3682.84 "Игорь Лабутин" И там есть, естественно, некоторая специфика EF Core.
3682.84 3689.68 "Игорь Лабутин" Давайте пробежимся по тому, что Microsoft рекомендует, если вы пишете вдруг код с EF Core, возможно, какие-то рекомендации будут вам интересны.
3689.68 3695.60 "Игорь Лабутин" Первое, естественно, рекомендация неудивительная.
3695.60 3699.20 "Игорь Лабутин" Поймите, где тормозит, и измеряйте, измеряйте, измеряйте.
3699.20 3701.00 "Игорь Лабутин" То есть без измерения не надо ничего оптимизировать.
3701.00 3710.04 "Игорь Лабутин" Это как бы первый пункт, который нужно помнить, и про который мы не будем уставать напоминать в каждой статье, в обсуждении каждой статьи, где говорится про перформанс.
3710.04 3725.60 "Игорь Лабутин" Дальше, если мы говорим про доступ к базам данных, то общий перформанс того, как у вас работают базы данных и запросы к ней из кода, складываются из кучки факторов.
3725.60 3728.36 "Игорь Лабутин" Фактор первый, непосредственно скорость запроса самого.
3728.36 3735.28 "Игорь Лабутин" Вы можете написать очень тормозной запрос, или у вас база данных может очень тормозить, потому что ей мало памяти, диска или еще чего-нибудь.
3735.28 3738.68 "Игорь Лабутин" Но тем не менее, это первая штука.
3738.68 3751.24 "Игорь Лабутин" Вторая штука, если вы получили в результате запроса какие-то данные, или наоборот, вы отправляете в базу данных какие-то данные, которые нужно в нее положить, то время тратится на то, чтобы эти данные передать через сеть.
3751.24 3762.08 "Игорь Лабутин" Как мы помним в распределенных системах, это один из, то что называется file-assessor distributed computing, что сеть она обладает бесконечной пропускной способностью.
3762.08 3763.08 "Игорь Лабутин" Это не так.
3763.08 3774.52 "Игорь Лабутин" Сеть тормозит, в сети бывают потери, поэтому чем дальше ваша база данных физически находится от вашего backend хода приложения, тем потенциально это время больше.
3774.52 3777.80 "Игорь Лабутин" Следующий момент, связанный, это roundtrips.
3777.80 3803.96 "Игорь Лабутин" То есть то, сколько раз вы входите в базу данных, на самом деле важно, потому что, опять же, каждый раз это нужно найти свободный connection, что-то с ним сделать, вернуть его потом обратно и потратить время на чисто физическое, пусть даже вы передаете очень мало данных, но чисто физически сбегать на другую машинку и вернуться, это уже некоторое время и дает какой-то latency.
3803.96 3812.04 "Игорь Лабутин" Ну и последнее, поскольку мы говорим про EF Core, то runtime самого EF Core тоже добавляет некоторый overhead, и он местами очень немаленький.
3812.04 3816.28 "Игорь Лабутин" Мы обсудим это чуть дальше.
3816.28 3832.04 "Игорь Лабутин" Из общих рекомендаций, там есть понятная рекомендация, знайте, что у вас происходит внутри, то есть не просто верьте, что EF Core все сделает хорошо, а знайте, как он на самом деле работает, какие фичи в нем есть, и когда какие нужно применять, и где что отключать, если вдруг оно вам не нужно.
3832.04 3838.56 "Игорь Лабутин" Ну и рекомендация, если вам нужна совсем суперскорость, то смотрите на кэширование.
3838.56 3853.16 "Игорь Лабутин" То есть кэшируйте, кэшируйте, еще раз кэшируйте, скорее всего это будет чуть-чуть быстрее, чем если вы просто будете пытаться оптимизировать прям совсем-совсем последние соки из базы данных, хотя, конечно, это тоже надо делать.
3853.16 3861.84 "Игорь Лабутин" Итак, есть несколько углов, под которыми можно посмотреть на то, как работать быстро с EF Core.
3861.84 3868.00 "Игорь Лабутин" И первое, с чего начать, поскольку мы сказали, что нам нужно измерять, то первое, нужно понять, как нам нужно измерять.
3868.00 3872.48 "Игорь Лабутин" Во-первых, нам нужно понять, есть ли у нас какие-то медленные запросы.
3872.48 3875.16 "Игорь Лабутин" Это сделать можно несколькими способами.
3875.16 3877.52 "Игорь Лабутин" Во-первых, можно в самом EF Core включить логин.
3877.52 3891.04 "Игорь Лабутин" Это делается при настройке вашего db-контекста, либо вы вызываете метод log2 и дальше туда передаете какую-нибудь лямбдочку, которая принимает строчку, и, соответственно, на каждое логирование такая лямбда будет вызываться.
3891.04 3906.64 "Игорь Лабутин" Либо вы говорите useLoggerFactory, передаете туда iLoggerFactory, и тогда все это будет подцепляться к стандартному Microsoft Extensions Logging логированию, и, соответственно, с loglevel и всякими прочими настройками будет налогироваться.
3906.64 3921.48 "Игорь Лабутин" На инфо-уровне как раз логируется информация, как правило, при дефолтных настройках о всех выполненных запросах, и в каждом запросе будет написано, собственно, что за запрос был выполнен и сколько это заняло времени.
3921.48 3934.08 "Игорь Лабутин" Там не будет информации во всех параметрах, может не быть, там не будет информации прям точной о экзекьюшн-планах и так далее, но, по крайней мере, там будет точное время в миллисекундах, сколько выполнялся запрос.
3934.08 3950.92 "Игорь Лабутин" И общая рекомендация от Microsoft, в целом такой логинг лучше не оставлять в продакшене, ну потому что сам логинг требует времени, и там случайно могут все-таки попасться какие-нибудь private данные, sensitive данные, которые попадут в логи, и, в общем, это будет не очень здорово.
3950.92 3954.76 "Игорь Лабутин" Поэтому от Microsoft рекомендуют включать только тогда, когда надо.
3954.76 3971.52 "Игорь Лабутин" Ну, хорошо, допустим, вы включили логи, у вас теперь в логах валится сообщение про то, что вот такой-то селект исполнен, ну, селект там того-то, того-то из такой-то таблички исполнен, но вы же в коде такие селекты не пишете, в коде вы пишете link_you, если вы используете ее в core в большинстве случаев.
3971.52 3977.44 "Игорь Лабутин" И надо как-то понять, какой из ваших link_you запросов соответствует реальный запрос в базе.
3977.44 3987.56 "Игорь Лабутин" Особенно если у вас там какой-нибудь highly concurrent код, когда куча параллельных реквестов идет, то все это смешивается в логах, и надо как-то понимать.
3987.56 3999.32 "Игорь Лабутин" Ну, конечно, корреляция есть, но все-таки, особенно если вы начнете смотреть performance, допустим, в самой базе данных, там, каким-нибудь SQL профайлером или еще чем-то, то вот там точно надо будет понимать, что это за запрос и откуда он пришел.
3999.32 4012.60 "Игорь Лабутин" Такая фича в core есть, то есть, когда вы говорите какой-нибудь там db_context.имя вашей коллекции, там, какой-нибудь people, вы можете использовать метод расширения .tag_width и передать туда строчку любую.
4012.60 4018.72 "Игорь Лабутин" И эта строчка будет добавлена в исполняемый SQL код в качестве SQL комментария первой строкой.
4018.72 4023.00 "Игорь Лабутин" И таким образом у вас эти запросы будут отличаться.
4023.00 4040.04 "Игорь Лабутин" Единственное, что я хочу предупредить, это то, что комментарии SQL серверам, если я правильно помню, тоже считаются частью запроса и используются при определении того, подходит ли этот запрос под какой-нибудь закашированный execution plan.
4040.04 4056.40 "Игорь Лабутин" Поэтому, если вы вдруг проявите креатив и в этот тег, например, будете добавлять значение какого-нибудь параметра, который вы передаете в этот запрос, то велика вероятность, что у вас это будут каждый раз, база данных будет считать это новым запросом и каждый раз строить новый execution plan.
4056.40 4059.44 "Игорь Лабутин" Поэтому для query тегов выбирайте фиксированный текст и не меняйте его.
4059.44 4100.76 "Игорь Лабутин" Ну, понятно, что есть базоданческие тулы для проверки performance, то есть, если это SQL сервер, то там есть всякие activity monitor, extended events и сам EF Core, соответственно, позволяет вытащить из себя некоторое количество event counters, то есть, если вы подключите, допустим, .NET Monitor, либо еще похожий тул, то EF Core будет репортить некоторое количество полезных event counters, как то количество активных дб контекстов, сколько запросов в секунду делается, сколько раз safe changes было сделано и так далее.
4100.76 4106.08 "Игорь Лабутин" И кроме того, Microsoft рекомендует использовать Benchmark.NET.
4106.08 4119.88 "Игорь Лабутин" Я как-то никогда не сталкивался с использованием Benchmark.NET с запросами в базу данных, потому что это не такая прям микрооперация, чтобы ее бенчмаркать, но действительно в принципе можно, почему нет.
4119.88 4134.60 "Игорь Лабутин" Единственное, что надо понимать, что в типичном бенчмарке у вас внутри бенчмарка будет инсценироваться дб контекст, и поэтому это не будет чистое время выполнения запроса, это будет все-таки время на дб контекст, надо достать connection из pool, открыть connection, вот это все.
4134.60 4153.08 "Игорь Лабутин" Но это нормально, если вы используете этот бенчмарк для того, чтобы сравнить два подхода, например, два варианта запроса, потому что и там, и там дб контекст будет одинаково тратить, ну а на запрос время, соответственно, будет какое-то разное уходить, вы будете видеть эту разницу, но вы не будете знать, сколько запрос занял в общем объеме.
4153.08 4155.24 "Игорь Лабутин" Тут, к сожалению, так.
4155.24 4170.68 "Игорь Лабутин" Так что эта часть была про диагностику, то есть включайте логи EF Core, смотрите, что происходит, тегируйте ваши запросы, и если не помогает понять, то дальше смотрите execution plan и смотрите уже со стороны базы данных, что происходит.
4170.68 4171.68 "Игорь Лабутин" Дальше интереснее.
4171.68 4180.16 "Игорь Лабутин" То, для чего мы используем EF Core, это, конечно же, доставать данные из базы, то есть исполнять запросы.
4180.16 4191.80 "Игорь Лабутин" Тут начинается все с достаточно банальных советов, там используйте индексы, найдите, значит, медленный запрос, займите на execution plan, поймите, где не хватает индексов, добавьте индексы, profit.
4191.80 4198.96 "Игорь Лабутин" Но тут есть тонкости с добавлениями, мы про них немножко скажем позднее.
4198.96 4218.48 "Игорь Лабутин" С индексами есть еще, да, напоминание, что вам иногда могут помочь так называемые композитные индексы, то есть когда у вас ключом является несколько колонок, и такие индексы могут сработать даже если вы в условии указали не все колонки, а только некоторые, но только в том случае, когда вы указываете колонки, которые в начале индекса находятся.
4218.48 4224.16 "Игорь Лабутин" Ну, в общем, композитный индекс, это тоже бывает полезно.
4224.16 4225.52 "Игорь Лабутин" Дальше следующий совет.
4225.52 4229.04 "Игорь Лабутин" Забирайте из базы только те properties, которые вам нужны.
4229.04 4257.76 "Игорь Лабутин" То есть понятно, что у вас есть, например, какой-нибудь большой объект юзера, и если вам нужны только ID-шники и его там имя, но, например, не нужен там ни адрес, ни email, ни еще что-то, используйте анонимные типы в C#, пишите select new и, соответственно, только нужные вам properties этого объекта, и тогда запрос, который будет сгенерен, не будет вытаскивать все колонки из базы, и таким образом уменьшит объем данных, которые передаются с сервера на клиент.
4257.76 4264.84 "Игорь Лабутин" Это поможет сделать запрос, сам запрос-то может и не будет сильно быстрее, но вычитывание всех данных будет работать быстрее.
4264.84 4275.00 "Игорь Лабутин" И это работает хорошо для запросов, но это не очень здорово, если вы результат, объект, который получен в результате запроса хотите поменять и сохранить обратно.
4275.00 4278.16 "Игорь Лабутин" Понятно, что с анонимным объектом вы этого так просто не сделаете.
4278.16 4291.36 "Игорь Лабутин" Есть способы, как это обойти, через всяких attach объектов и помечания, что же в них поменялось, то есть как дать понятие в Core, что же поменялось в объекте, но это такая advanced техника, в принципе, в большинстве случаев не очень надо.
4291.36 4304.60 "Игорь Лабутин" В основном мы все-таки очень часто много читаем, и только тогда, когда мы готовимся к апдейту, мы там можем уже нормально получить нужный нам объект, тем более, что как правило для апдейта мы получаем не так много объекта.
4304.60 4323.04 "Игорь Лабутин" Дальше советы, понятно, если есть возможность, используйте всякие лимиты, то есть не забирайте все, а говорите там, какими-то take в linq только от определенного количества, плюс используйте постраничный вывод, что тоже поможет для объема данных.
4323.04 4359.24 "Игорь Лабутин" Если вы используете загрузку дочерних сущностей, то есть у вас есть, например, классический пример, у вас есть блог, в блоге есть посты, в постах есть комменты, так вот если вы грузите посты и к ним комменты, то посмотрите в сторону такой фичи как split queries, иначе если вы напишете просто классический join, ну классический join в linq или будете использовать include, то EF Core может написать квельку, сгенерить квельку, которая будет просто джойнить табличку постов на табличку комментов, и таким образом для каждого коммента будет возвращать еще и все колонки про пост.
4359.24 4370.60 "Игорь Лабутин" Оно конечно в результате схлопнется в нормальный один объект, но зачем вам куча лишних данных, вам достаточно, вообще говоря, id поста только для, при возврате набора комментов.
4370.60 4393.76 "Игорь Лабутин" Современный EF Core умеет такое, и называется это split queries, но там есть несколько тонкостей, во-первых, сейчас для split queries на каждую квельку делается отдельно round trip, это конечно не один +n, но тоже возможно будет вам важно, так что меряйте и бенчмаркайте, тут как раз вот то, где надо бенчмаркать, что важнее, round trip или много данных в одном запросе в широкой таблице.
4393.76 4419.84 "Игорь Лабутин" Все загруженные данные, точнее не так, загружайте все связанные данные по возможности жадно, то есть lazy loading это прям клевая фича, когда на нее смотришь на поверхности, но на самом деле внизу, внутри каждое обращение к объекту, который загружен как lazy loaded, будет вызывать round trip в базу, и это на самом деле не очень здорово, поэтому лучше избегать lazy loading.
4419.84 4435.68 "Игорь Лабутин" С данными, которые вы получили в результате запроса, как правило вам возвращается какой-нибудь i-нумерабл, с ними можно сделать что, вы можете на нем вызвать to list или to array, или вы можете по нему начать делать forage, то есть тридж.
4435.68 4447.64 "Игорь Лабутин" Тут есть несколько моментов, если вам нормально обрабатывать данные последовательно, лучше итерируйтесь, то есть не пытайтесь делать to list.
4447.64 4448.64 "Игорь Лабутин" Почему?
4448.64 4476.28 "Игорь Лабутин" Потому что, например, если вы определенным образом сконфигурите эти framework, например, смотрите выше, split query используется, то EF будет на самом деле буферитировать результаты внутри, то есть он вам вернул i-нумерабл, но на самом деле он уже закэшировал часть результатов внутри, и если вы вызовете на этом to list, то фактически данные у вас закэшируются два раза, один раз во внутреннем буфере и второй раз, когда вы получите коллекцию из to lista.
4476.28 4487.48 "Игорь Лабутин" Поэтому по возможности используем стриминг подход, то есть читаем данные по мере их поступления, по мере их обработки, ну если никак, то тогда, конечно, вызываем to list.
4487.48 4506.64 "Игорь Лабутин" И важный кусочек это про tracking no tracking query, значит по умолчанию при загрузке данных Entity Framework трекает все, что вы грузите, то есть он запоминает все объекты, которые он прочитал и более того складывает их во внутренний словарь.
4506.64 4508.00 "Игорь Лабутин" Зачем это делается?
4508.00 4546.72 "Игорь Лабутин" Во-первых, это нужно не только для safe changes, в основном, конечно, все считают, что это нужно для safe changes, но это не только для этого, это еще используется для того, чтобы не грузить один и тот же объект из базы, а точнее из базы он загрузится, конечно, но если после создания объекта выясняется, что такой же объект уже есть с тем же идентити во внутреннем словарике, то вернется объект из внутреннего словарика, а свежесозданный объект тут же убьется, то есть таким образом мы, ну до некоторой степени экономим память, если вы грузите, например, довольно много сущностей, которые на самом деле одна и та же сущность.
4546.72 4564.36 "Игорь Лабутин" То есть если вы, например, будете грузить в обратном порядке, там, для примера с блогами, вы будете грузить все, не знаю, комменты этого автора во всех постах, то наверное, если какие-то посты очень много комментируются, у вас из этих комментов будет ссылка на один и тот же пост очень много раз.
4564.36 4583.88 "Игорь Лабутин" И если трейкинг включен, то объект поста будет один для каждого поста, а если выключен, то для каждого поста, для каждой ссылки на один и тот же пост будут созданы разные объекты постов, что может быть, кстати, плохо с точки зрения и вашей логики тоже, вы будете ожидать в C#, что объекты равны, но что это один и тот же объект, это не так.
4583.88 4605.56 "Анатолий Кулаков" Мне кажется, такую проблему очень легко поймать, знаешь, когда ты, например, загрузил автора поста, изменил ему имя, и вот еще не успел сохранить, и потом загружаешь статью и обращаешься опять к автору этого поста, и у тебя уже заберется не тот автор, которым поменял имя, а еще старый, который есть еще в базе, со старым именем, и получишь неконститентные данные.
4605.56 4616.40 "Игорь Лабутин" Все так, но все-таки да, но тут ты, поскольку ты говоришь, что вначале ты меняешь автора, ты как бы готовишься к safe changes в каком-то смысле, и наверное, ты не будешь выключать трекинг.
4616.40 4630.56 "Игорь Лабутин" То есть все-таки, если ты собираешься менять что-то, то трекинг, ну как бы лучше включить, если ты не готов вот все эти advanced штуки делать, когда ты оттачишь объекты обратно в контекст с пометкой того, что в них изменились.
4630.56 4641.92 "Игорь Лабутин" Так можно сделать, но в целом да, в целом можно поймать, на самом деле, проблемы на том, что у тебя создаются несколько копий одного и того же объекта, который логически один.
4641.92 4646.68 "Анатолий Кулаков" И это довольно сложно обычно выловить, ну то есть такая ошибка довольно неприятная.
4646.68 4647.68 "Игорь Лабутин" Ну да.
4647.68 4658.68 "Игорь Лабутин" И еще штука, которую делает трекинг, он собственно сохраняет некоторое состояние объекта, чтобы потом было с чем сравнить, когда вы поменяете что-то, чтобы safe changes знал, что поменялось.
4658.68 4661.28 "Игорь Лабутин" Поэтому это потребляет памяти, опять же.
4661.28 4677.56 "Игорь Лабутин" Вот трекинг можно выключить, сказав add no tracking, экстенджер методов, но тогда, как мы сказали, там отключаются все эти проверки и один объект, и даже если это один и тот же объект, будет грузиться несколько раз, ну и создаваться память несколько раз.
4677.56 4680.24 "Игорь Лабутин" Возможно это то, что вам и нужно.
4680.24 4697.40 "Игорь Лабутин" Если вам никак не получается всеми этими ухищрениями добиться того, чтобы кверка получилась нормальной, тогда конечно можно использовать row SQL, то есть есть специальный метод, который позволяет передать это просто SQL-ку прямо написанную в строчке и вперед.
4697.40 4712.44 "Игорь Лабутин" Ну и напоминание не лишнее про то, что желательно все методы, которые вы дергаете у EF Core, дергать в асинхронном варианте, потому что 99% операций с базой данных асинхронны, и скорее всего вы зачем блокировать поток, пока там база данных думает.
4712.44 4718.00 "Игорь Лабутин" Это было все про запросы, дальше есть небольшой раздел про апдейты.
4718.00 4719.00 "Игорь Лабутин" Тут не так много.
4719.56 4732.96 "Игорь Лабутин" Во-первых, предположим, вы меняете несколько вещей, то есть вам нужно поменять там сущности одни, сущности другие, вы все это делаете в рамках одной транзакции или в одной, логическое действие, а потом говорите safe changes в конце.
4732.96 4736.84 "Игорь Лабутин" У EF Core есть несколько вариантов.
4736.84 4748.20 "Игорь Лабутин" Вариант первый — скомпоновать все эти SQL-запросы, которые он сгенерил, в один большой и заслать один раз, либо на каждый SQL-запрос послать отдельно его базу и выполнить.
4748.20 4751.64 "Игорь Лабутин" И у того и у другого походу есть плюсы и минусы.
4751.64 4766.32 "Игорь Лабутин" С одной стороны, если их компоновать, то у вас будет большой запрос, и плюс он будет возможно не очень эффективно исполняться на некоторых базах данных, ну как-то так, распространяется точно, написано в статье.
4766.32 4771.36 "Игорь Лабутин" А с другой стороны, посылая по одному запросу, у вас будет куча round-trips и это не очень здорово.
4771.36 4787.96 "Игорь Лабутин" Как написано в статье, эксперименты показали, что на типичном SQL-сервере оптимальный вариант, когда батчится таким образом запрос, не более 40 штук в одном батче, то есть типа save changes, собирает их в пачке не более чем 40 штук.
4787.96 4799.88 "Игорь Лабутин" Поэтому, внимание, логика, по дефолту максимальное количество стейтментов, которые будет сохраняться EF Core в save changes на SQL-сервере, это 42.
4799.88 4802.68 "Анатолий Кулаков" Это правильное решение, полностью поддерживаю.
4802.68 4806.80 "Игорь Лабутин" При том, что эксперименты показали, что 40 это оптимально, но будет 42.
4806.80 4810.44 "Игорь Лабутин" Ну в общем, забавно, да, возможно подпроса в том, что это 42.
4810.44 4816.28 "Игорь Лабутин" Дальше, соответственно, в базе данных есть еще такая фича, называется bulk updates.
4816.28 4837.20 "Игорь Лабутин" Потихонечку в EF Core въезжает поддержка bulk updates, но как правило это делается только в экстендженах, и прямой поддержки пока нету, надо использовать функцию context.database.execute_score_row и туда передавать нормальный bulk update, синтез той базы данных, которую вы используете.
4837.20 4840.36 "Игорь Лабутин" Это то, что касается апдейтов.
4840.36 4848.24 "Игорь Лабутин" Дальше есть еще отдельная тема, а как же строить модель данных, то есть модель вашей базы данных, таблички, колоночки.
4848.24 4851.40 "Игорь Лабутин" Советы от Microsoft примерно такие.
4851.40 4861.44 "Игорь Лабутин" Начинаем всегда с нормальной, более-менее нормализованной модели, то есть не пытаемся денормализовать с самого начала, если только мы не знаем конкретно бизнес кейсов, где это будет нужно.
4861.44 4867.48 "Игорь Лабутин" И по мере необходимости начинаем денормализовывать, то есть добавляем какие-то compute от колонки.
4867.48 4887.48 "Игорь Лабутин" Если мы compute от колонку именно базы данческую не можем добавить, то тогда добавляем колонки, которые, соответственно, содержат некоторую закэшированную информацию, и если его исходники для этой информации меняются, нам приходится заботиться о том, чтобы информация в этих кэширующих колонках была обновлена.
4887.48 4890.28 "Игорь Лабутин" И тут есть тоже несколько методов, как это сделать.
4890.28 4896.56 "Игорь Лабутин" Это можно сделать вручную, понятное дело в коде, но это чревато ошибками, мало ли, забудете.
4896.56 4899.72 "Игорь Лабутин" Это можно сделать db-триггерами, если с другой стороны посмотреть.
4899.72 4908.72 "Игорь Лабутин" Это ошибками точно не чревато, но это создаёт некоторую нагрузку на базу, хотя, возможно, не очень большую с моей точки зрения, это ок.
4908.72 4916.28 "Игорь Лабутин" И есть промежуточный вариант, и в Core есть понятие event или interceptors, которые тоже можно для этого использовать.
4916.28 4923.68 "Игорь Лабутин" То есть вы можете навесить некоторую логику на изменение тех или иных свойств, и в этой логике менять какие-то compute-от свойства.
4923.68 4924.68 "Игорь Лабутин" Почему нет?
4924.68 4929.36 "Игорь Лабутин" Ну и если даже этого не хватает, используйте materialized views, всё такое.
4929.36 4933.68 "Игорь Лабутин" Но это все уже такие, больше не про EF Core, а больше про базоданческую штуку.
4933.68 4937.80 "Игорь Лабутин" То, что касается EF Core, касается обычного наследования.
4937.80 4945.92 "Игорь Лабутин" То есть если у вас есть некоторая иерархия объектов, которые вам нужно каким-то образом представить в базе данных, то, как правило, используется несколько подходов.
4945.92 4961.80 "Игорь Лабутин" Либо table per hierarchy, то есть когда вы все объекты храните в одной табличке, и у вас просто некоторая колоночка является, ну то, что иногда называют дискриминантом или определяющей колонкой вообще, что за тип хранится в этой строчке.
4961.80 4969.16 "Игорь Лабутин" Удобство состоит в том, что все данные лежат в одной таблице, и никаких join-ов делать не надо для того, чтобы достать всю иерархию.
4969.16 4975.08 "Игорь Лабутин" Проблема в том, что табличка обычно получается очень широкой, если все эти типы шарят довольно мало свойств.
4975.08 4982.08 "Игорь Лабутин" Ну потому что у каждого типа будут заполнены только релевантные ему колонки, а остальные будут null'ами.
4982.08 4984.88 "Игорь Лабутин" Это может быть не очень здорово для очень широких таблиц.
4984.88 4991.28 "Игорь Лабутин" Вот, альтернативный подход — это table per type, то есть на каждый тип в иерархии вы создаете отдельную табличку.
4991.28 4998.36 "Игорь Лабутин" Он имеет свои преимущества, он имеет свои недостатки, вам нужно точно join-ить, если вы сходите и доставите всю иерархию.
4998.36 5006.44 "Игорь Лабутин" Но если у вас типы достаточно не связаны друг с другом по количеству свойств, то, может быть, он более оптимален.
5006.44 5025.80 "Игорь Лабутин" Это тот кейс, где заранее нельзя предсказать, и самое противное, что, ну как мне кажется, подход нужно выбирать довольно рано в жизненном цикле продукта, поэтому тут нужно просто мерить, мерить и мерить, предполагая, какие у вас будут типы, какие у вас будут иерархии, или может быть, вы даже точно знаете.
5025.80 5029.84 "Игорь Лабутин" Напишите тестик, померьте, по-другому не получится.
5029.84 5033.84 "Игорь Лабутин" Что будет быстрее, джойны или широкие таблицы?
5033.84 5037.36 "Игорь Лабутин" И последний раздел, он называется Advanced Performance Topics.
5037.36 5043.92 "Игорь Лабутин" Тут собрано некоторое количество фич, которые могут вам пригодиться, если вам нужно выжать последние соки из EF Core.
5043.92 5046.92 "Игорь Лабутин" Ну, во-первых, pooling db-контекстов.
5046.92 5056.68 "Игорь Лабутин" То есть обычно вы говорите add db-контекст при конфигурации, вы можете сказать add db-контекст pool и передать туда, соответственно, примерно те же самые аргументы.
5056.68 5062.72 "Игорь Лабутин" В этом случае db-контексты начнут пулиться, то есть когда вы его диспользуете, он на самом деле не уничтожается, он возвращается в pool.
5062.72 5073.48 "Игорь Лабутин" Все бы хорошо, но по большому счету это означает, что db-контексты переюзаются между разными запросами, и это означает, что вы не можете его конфигурить под каждый запрос отдельно.
5073.48 5090.00 "Игорь Лабутин" То есть db-контекст будет, ну, считайте, что он у вас singleton, по сути говоря, то есть он сконфигурировался один раз в самом начале приложения, их физически это несколько, но вы никогда не знаете, будете получать в один тот же или нет, поэтому считайте, что он singleton после этого.
5090.00 5094.60 "Анатолий Кулаков" Слушай, какие полезные конфигурации есть у db-контекста, которые я бы хотел менять на каждый запрос?
5094.60 5098.20 "Игорь Лабутин" У нас, например, в зависимости от запроса connection string возле данной будет разный.
5098.20 5099.20 "Игорь Лабутин" Мы в разные базы.
5099.20 5100.44 "Анатолий Кулаков" Серьезные вы ребята, да.
5100.44 5112.00 "Игорь Лабутин" Мы в зависимости от запроса, то есть мы, грубо говоря, нам в руле запроса приходят некоторые идентификаторы, по которым мы понимаем, в какую базу данных мы пойдем.
5112.00 5129.52 "Игорь Лабутин" Это некоторый исторический момент, потому что раньше система стабла он премис, и, соответственно, она была развернута на, условно говоря, нескольких серверах, с каждой инстанцией своей базы данных, а теперь она развернута в облаке, но нужно ходить в те же базы данных, по крайней мере, пока мы их не сконсолидировали в одну.
5129.52 5136.96 "Игорь Лабутин" И мы знаем, где лежат те или иные данные, то есть это однозначно определяется по ключу в запросе, ну, по некоторым данным внутри запроса.
5136.96 5144.16 "Игорь Лабутин" Но дальше мы должны сказать ей в кору, в какую базу пойдем, поэтому мы connection string определяем в рантайме внутри запроса в скоупе.
5144.16 5147.40 "Анатолий Кулаков" Ну, такой искусственный шардинг прямо на клиенте вы сделали.
5147.40 5148.40 "Игорь Лабутин" Да.
5148.40 5151.52 "Анатолий Кулаков" Принято, отлично.
5151.52 5157.60 "Игорь Лабутин" Следующая фича — это compiled queries, то есть штука… Смотрите, что нужно сделать EF Core.
5157.60 5160.32 "Игорь Лабутин" EF Core работает с LinkU, точнее, не так.
5160.32 5171.20 "Игорь Лабутин" Вы работаете с EF Core посредством LinkU, как правило, а EF Core нужно в конце сказать, что… Ну, генерить, собственно, какой-то текст.
5171.20 5173.20 "Игорь Лабутин" Для этого она берет что?
5173.20 5194.60 "Игорь Лабутин" Она берет вашу текст на LinkU, ну, то есть это Expression Tree, разбирает его, смотрит, что там получилось, генерит из нее некоторое внутреннее представление, и после этого на основе этого генерит на основе этого представления некоторый текст запроса, и все это дело кэшируют.
5194.60 5195.60 "Игорь Лабутин" Вот.
5195.60 5200.36 "Игорь Лабутин" Все бы хорошо, но есть проблема.
5200.36 5209.56 "Игорь Лабутин" Каждый раз, когда EF Core выполняет… Когда вы выполняете новую кэшку, то есть она выполняется, EF Core нужно сделать следующее.
5209.56 5221.80 "Игорь Лабутин" Ему нужно взять Expression Tree, который у вас есть, сравнить его с тем, который у него закэширован, и если он закэширован, то ему не нужно тратить время на сборку заново из коль выражения, он его может взять из кэша.
5221.80 5232.72 "Игорь Лабутин" Это сравнение довольно быстрое, ну, просто по сути рекурсивно пробежаться по дереву и сравнить с тем деревом, которое у вас сложено, но все же некоторое время требует.
5232.72 5253.36 "Игорь Лабутин" Поэтому можно вызвать специальный метод, который называется EF.compileAsyncQuery, который вам вернет по сути делегат, то есть вы туда передаете кэшку, и получаете делегат, который принимает те параметры, которые вы бы и так передали в query, ну то есть какие-нибудь там, которые потом станут SQL-параметрами.
5253.36 5269.20 "Игорь Лабутин" Фишка еще в том, что делегат является thread-safe, то есть вы можете получить делегат, сохранить его в каком-нибудь там static-поле и спокойно дергать его из разных потоков, из разных ваших приходящих там HTTP-реквестов без каких-либо проблем, оно все thread-safe, там нет никакого shared-состояния.
5269.20 5272.20 "Игорь Лабутин" И… Но есть несколько ограничений.
5272.20 5293.04 "Игорь Лабутин" Во-первых, поддержаны только простые параметры, то есть вы не можете передать каким-нибудь там table-value параметр или что-то сложное, то есть только простые типы скалярные, и вы можете такую query-ку компилить только для одной модельки, то есть вы не можете смешивать несколько EF-core-model, то, что у них называется в документации.
5293.04 5311.48 "Игорь Лабутин" То есть в общем ограничений есть, но для каких-то случаев, когда действительно есть какая-то query, которая выполняется прям очень много раз, и вы хотите твердо знать, что мы не тратим время на поиск того, есть ли она уже в кэше, ну скомпилируйте ее вручную таким способом.
5311.48 5330.20 "Игорь Лабутин" Дальше есть еще такой момент, касаемый query-cache, то есть вы можете, например, написать, что у вас… Ну в какой-то в query, да, в linq, когда вы пишете, вы в конце можете написать там равно-равно и какой-нибудь, не знаю, констант, например, в условии.
5330.20 5334.80 "Игорь Лабутин" А в другом методе вы написали такую же query-ку, но с другой константой.
5334.80 5361.84 "Игорь Лабутин" Это не очень здорово, потому что query-ки-то физически одинаковые, но из-за того, что в текст запроса будет вставлена прям константа, для EF-core и для SQL-сервера, что важно, это будут на самом деле разные query-ки, то есть SQL-сервер, соответственно, например, да и я думаю, что остальные базы данных тоже будут считать их разными, соответственно, каждый раз считать execution-план, а EF-core в этом вторнику кэше сохранит их как две разных query.
5361.84 5363.24 "Игорь Лабутин" Это будет нездорово.
5363.24 5371.72 "Игорь Лабутин" Поэтому вместо того, чтобы запихивать константы в query-ку, лучше всего эти константы объявить локальной переменной прямо перед query-кой и использовать переменную.
5371.72 5381.16 "Игорь Лабутин" Если вы такой подход используете во многих методах, ну для query, который выглядит очень похоже, то это все в итоге схлопнется в одну и ту же query-ку внутри EF-core и будет хорошо оптимизировано.
5381.16 5387.72 "Игорь Лабутин" Ну вы не будете просто генерить кучу разных очень похожих, но на самом деле различающихся query.
5387.72 5394.88 "Игорь Лабутин" И здесь как раз помогут внутренние каунтиры EF-cora, то есть там есть такое, называется query-cache-hit-rate.
5394.88 5402.28 "Игорь Лабутин" Если он явно больше, нет, наоборот, если он меньше 100% постоянно, то это нехорошо.
5402.28 5411.16 "Игорь Лабутин" То есть в нормально написанном предложении рано или поздно вы коснетесь всех query-ок, они все закэшируются, и после этого этот показатель должен быть строго 100%.
5411.16 5430.00 "Игорь Лабутин" Так вот, если он строго меньше 100%, значит, у вас где-то есть query, которая постоянно как-то отличается все время сама от себя, и возможно, потому что вы, например, собрали параметр, не знаю, конкатенации строк, и в итоге они параметризовали его, поэтому посмотрите внимательно.
5430.00 5443.72 "Игорь Лабутин" И EF-core, в принципе, позволяет вообще создавать динамические query, вы прямо expression tree можете создать, но там прямо написано в статье «избегайте этого», потому что там все плохо и ничего не кэшируется, и плохо работает медленно.
5443.72 5450.68 "Игорь Лабутин" Это все касалось, значит, непосредственного выполнения, но есть еще стартап.
5450.68 5464.12 "Игорь Лабутин" То есть на момент стартапа EF-core, точнее, это не сам стартап, это на самом деле, когда первый раз на db-контексте выполняется что-нибудь, db-контексту нужно вообще проближаться и понять, что у него за модели, есть ли у них какие-то свойства, как он все это будет мапить.
5464.12 5475.36 "Игорь Лабутин" Чтобы все это не делать каждый раз, если вам важно, например, время первого запуска, первого какого-то коннекта к базе данных, первого запроса, то вы можете использовать штуку под названием compiled models.
5475.36 5503.96 "Игорь Лабутин" То есть для этого вы используете сначала .NET-овский command-line, вызываете .NET EF db-контекст optimize, он генерирует некоторый код-файлик, ну, файлик, на котором написан код, и потом вы используете extension-метод useModel, где передаете, соответственно, код, который в этом файлике генерен, и таким образом .NET будет знать уже модель, которая в этом классе определена.
5503.96 5515.08 "Игорь Лабутин" Причем там все довольно-таки неплохо сделано, в том смысле, что этот generated код использует кучу всяких partial методов и partial классов, и это позволяет его до некоторой степени кастомизировать.
5515.08 5531.56 "Игорь Лабутин" Смотрите документацию, потому что, во-первых, там описаны все возможности кастомизации, а во-вторых, там есть ограничения, из-за которых все может быть так легко и просто, не все поддержано сейчас в этих compiled-моделах.
5531.56 5538.00 "Игорь Лабутин" Ну и последний раздел — это про то, как сделать так, чтобы все это работало получше в рантайме.
5538.00 5541.36 "Игорь Лабутин" Мы уже касались db-контекст-пуллинга.
5541.36 5552.56 "Игорь Лабутин" Дальше можно вообще забить на di для db-контекста и использовать пулт db-контекст-фактори напрямую, то есть без di.
5552.56 5555.44 "Игорь Лабутин" Можно, соответственно, прикомпилировать кверки.
5555.44 5564.24 "Игорь Лабутин" Ну и есть еще такая штука, смотрите, db-контекст по умолчанию не является thread-сейфом, то есть нельзя один и тот же db-контекст использовать из разных потоков.
5564.24 5571.64 "Игорь Лабутин" У него есть внутри неопределенные механизмы, которые позволяют это отследить, и если вдруг такое происходит, он кидает exception специальный.
5571.64 5585.20 "Игорь Лабутин" Так вот, можно сказать, при конфигурации контекста поставить специальную опцию enable thread-safety checks false, и если это сделано, то db-контекст перестает проверять что-либо на thread-safety, но становится чуть быстрее.
5585.20 5590.76 "Игорь Лабутин" Ну и если после этого вы его неправильно заюзаете из разных тридов, ну вы сами себе буратины.
5590.76 5592.96 "Игорь Лабутин" А по умолчанию это включено?
5592.96 5596.28 "Игорь Лабутин" Да, да, да, да, по умолчанию включено.
5596.28 5608.40 "Игорь Лабутин" Но если вы твердо уверены, что у вас абсолютно правильный многопоточный код и никогда один и тот же db-контекст не будет использоваться из разных потоков, выключайте и вы немножко выиграете.
5608.40 5612.72 "Анатолий Кулаков" Ну вообще это нормальная идея не использовать db-контекст в нескольких потоках, да?
5612.72 5624.68 "Анатолий Кулаков" То есть у тебя приходит какой-нибудь запрос, у тебя создаются отдельные db-контексты на уровне scope, в HTTP request, ты там это всего один поточек делаешь, закрываешь запрос, зачем тебе там несколько потоков?
5624.68 5632.32 "Игорь Лабутин" Не знаю, возможно, кстати, в каких-нибудь ASP, ну вот в таких вот, да, ASP.NET Core приложениях, там, наверное, может быть, действительно не надо.
5632.32 5645.76 "Игорь Лабутин" А если ты, например, включишь какой-нибудь десктоп в WPF, где у тебя там какой-нибудь там бэкграундная работа, что-нибудь где-нибудь, потом что-то в UI поток вернулось, что-то там в бэкграунде опять что-то делается, то может быть и scope-ов нету, например.
5645.76 5647.68 "Игорь Лабутин" То там может что-нибудь такое происходить.
5647.68 5655.24 "Анатолий Кулаков" Да, да, ну тут, наверное, правильное решение все-таки делать выделенные scope и, понятно, следить за всеми workflow, за всеми процессами.
5655.24 5656.24 "Анатолий Кулаков" Ну да.
5656.24 5665.04 "Анатолий Кулаков" Хорошо, смотри, у меня еще есть одна статейчика от Джона Скита, но она не то чтобы особо свежая, просто она интересная.
5665.04 5679.08 "Анатолий Кулаков" Откнулся на нее абсолютно случайно и называется она «А как бы нам передизайнить System Object?» Или «А что было плохо запроектировано в языке программирования у базового объекта?» Вот.
5679.08 5693.64 "Анатолий Кулаков" Ну и, соответственно, меня заинтриговало само название и действительно, вот когда мы используем уже там сколько 20 лет мы уже используем C# и все время каждый день смотрим на этот System Object, используем его, используем эти методы, которые уже все знают наизусть.
5693.64 5700.80 "Анатолий Кулаков" И очень полезно задуматься, а зачем нужны эти методы, правильно ли они были спроектированы и что можно было бы сделать лучше.
5700.80 5708.96 "Анатолий Кулаков" Мне кажется, как раз хорошая статья для того, чтобы ее обсудить и посмотреть взгляд именно Джона Скита на эту проблему.
5708.96 5711.96 "Анатолий Кулаков" Ну что ж, давай приступим тогда.
5711.96 5713.52 "Анатолий Кулаков" Итак, System Object.
5713.52 5719.68 "Анатолий Кулаков" Наверное, каждый из вас знает, что это как раз-таки классик, от которого пронаследованы все остальные объекты.
5719.68 5723.88 "Анатолий Кулаков" Кто бы ни не был, в .NET все наследуется от System Object.
5723.88 5730.96 "Анатолий Кулаков" Вот и поэтому любой метод, который есть в Object, он, соответственно, будет у всех объектов в вашей системе.
5730.96 5738.48 "Анатолий Кулаков" И хочется, конечно же, чтобы там было как можно меньше методов, для того чтобы они просто так не плодились для каждого из наследников.
5738.48 5746.44 "Анатолий Кулаков" Соответственно, если метод там есть, нужно понимать, а почему он именно там и нельзя ли было его сделать где-нибудь отдельно.
5746.44 5750.68 "Анатолий Кулаков" Вот этим вопросом и занялся Джон Скит вместе со своими друзьями.
5750.68 5754.12 "Анатолий Кулаков" Напомню, что у объекта есть, прежде всего.
5754.12 5776.16 "Анатолий Кулаков" Это конструктор без параметров, финализатор, getType, getHashCode, метод equals, принимающий object, метод toString, memberwiseClone, а также непосредственно в объекте их нет, но очень сильно связанный с объектом и влияющим на его структуру есть MonitorWeight, MonitorPulse и MonitorPulseAll.
5776.16 5778.28 "Анатолий Кулаков" Короче, мониторы.
5778.28 5780.36 "Анатолий Кулаков" Давайте разберемся по порядку.
5780.36 5788.28 "Анатолий Кулаков" Во-первых, это есть методы, есть группа методов, которая связана с жизненным циклом объекта и с его идентификацией.
5788.28 5796.84 "Анатолий Кулаков" Кажется, что это единственные три метода, которые действительно должны быть в объекте и никаких вопросов они не вызывают.
5796.84 5799.92 "Анатолий Кулаков" Ну, во-первых, это конструктор без параметров.
5799.92 5806.52 "Анатолий Кулаков" Действительно, каждый объект нужно каким-то образом создавать и нам нужен конструктор, от этого никуда не денешься.
5806.52 5815.48 "Анатолий Кулаков" И, наверное, сложно придумать какой-то универсальный параметр, который будет представлять из себя некий стейт, который необходим просто абсолютно всем объектам в этой системе.
5815.48 5818.52 "Анатолий Кулаков" Наверное, такого универсального параметра нет.
5818.52 5821.48 "Анатолий Кулаков" Поэтому неудивительно, что конструктор без параметров.
5821.48 5823.80 "Анатолий Кулаков" К этому претензий, наверное, нет никаких.
5823.80 5824.80 "Анатолий Кулаков" Далее финализатор.
5824.80 5839.64 "Анатолий Кулаков" Ну, в принципе, без разницы, где должен размещаться финализатор, в самом объекте или, может быть, компилятор должен опознавать финализатор в наследниках и каким-то образом добавлять дополнительный код для того, чтобы финализировать этот объект.
5839.64 5845.60 "Анатолий Кулаков" В принципе, никакой разницы нет, поэтому к финализатору тоже вопросов особых нет.
5845.60 5852.76 "Анатолий Кулаков" Единственное дело, что хочется отметить, на самом деле финализаторы нужно использовать очень-очень редко.
5852.76 5859.08 "Анатолий Кулаков" Если вы в вашем коде видите финализатор, то, скорее всего, вы делаете что-то не так.
5859.08 5863.36 "Анатолий Кулаков" Единственным исключением является как раз-таки работа с Unmanaged ресурсами.
5863.36 5870.36 "Анатолий Кулаков" Но, когда мы работаем с Unmanaged ресурсами, есть более правильный, официально рекомендованный Микрософтам подход.
5870.36 5871.96 "Анатолий Кулаков" Это SafeHandle.
5871.96 5878.80 "Анатолий Кулаков" Поэтому обратите внимание, что SafeHandle намного более предпочтительен, чем финализатор, чем деструктор.
5878.80 5882.28 "Анатолий Кулаков" Поэтому старайтесь финализаторы в вашем коде совсем не использовать.
5882.28 5886.52 "Анатолий Кулаков" Это уже или какое-то Legacy, или что-то не то.
5886.52 5891.60 "Анатолий Кулаков" И третий тип, которому нет никаких вопросов, это GetType.
5891.60 5896.00 "Анатолий Кулаков" В общем, GetType - это, наверное, самый важный метод в объекте.
5896.00 5904.36 "Анатолий Кулаков" Он возвращает в возможность точку для рефлекшена, для того, чтобы исследовать дальше и как-то анализировать объект.
5904.36 5907.60 "Анатолий Кулаков" И ему сложно придумать какую-то альтернативу.
5907.60 5910.48 "Анатолий Кулаков" Можно, например, сделать какой-то статический класс.
5910.48 5916.76 "Анатолий Кулаков" И у этого статического класса запрашивать этот дискриминатор, это описание типа.
5916.76 5920.72 "Анатолий Кулаков" Но, с другой стороны, никакого смысла в этом нет.
5920.72 5927.08 "Анатолий Кулаков" Потому что каждый объект обязан давать вот эту точку для исследования, точку для рефлекшена.
5927.08 5930.60 "Анатолий Кулаков" Поэтому никакого смысла отрывать эту точку от объекта нет.
5930.60 5933.04 "Анатолий Кулаков" Вот эти три типа, в принципе, никаких проблем не вызывают.
5933.04 5937.84 "Анатолий Кулаков" А вот все остальное уже сталкивается с какими-то вопросами.
5937.84 5939.00 "Анатолий Кулаков" Давайте по порядку.
5939.00 5944.60 "Анатолий Кулаков" Во-первых, есть пачка методов, предназначенных для сравнения.
5944.60 5947.60 "Анатолий Кулаков" Это getHashCode и equals.
5947.60 5955.24 "Анатолий Кулаков" Во-первых, не очевидно, что каждый объект в системе, вообще любой инстанс, любое порождение, обязано сравниваться.
5955.24 5960.72 "Анатолий Кулаков" И обязано уметь быть сравнябельным.
5960.72 5964.32 "Анатолий Кулаков" Просто сравниваться с собой иногда лишено особого смысла.
5964.32 5968.32 "Анатолий Кулаков" И именно поэтому дефолтная имплементация для equals - это reference equals.
5968.32 5973.72 "Анатолий Кулаков" То есть сравнивается именно, грубо говоря, адреса в памяти, по которым лежит этот объект.
5973.72 5986.20 "Анатолий Кулаков" Но это тоже за уши притянутое техническое решение, которое может не иметь ничего общего под тем объектом, который реально мы используем в нашей логике.
5986.20 5999.44 "Анатолий Кулаков" Идея заключается в том, что, наверное, каждый объект должен сам решать, каким образом он именно сравнивается.
5999.44 6003.08 "Анатолий Кулаков" И нет какого-то универсального подхода для того, чтобы это сделать.
6003.08 6007.96 "Анатолий Кулаков" Например, как сравнить Integer - это довольно очевидно и понятно.
6007.96 6011.16 "Анатолий Кулаков" Его можно просто сравнить по значению и даже не загоняться.
6011.16 6013.44 "Анатолий Кулаков" Пример чуть посложнее - это float.
6013.44 6017.56 "Анатолий Кулаков" На самом деле, float тоже сравнивается точно как он есть, прям по байтово.
6017.56 6022.48 "Анатолий Кулаков" Но этот подход сравнения точно по байтово, он не рекомендуется.
6022.48 6025.36 "Анатолий Кулаков" Потому что float хранит себе примерное значение.
6025.36 6027.72 "Анатолий Кулаков" Поэтому сравнивать его нужно с каким-то эпсилоном.
6027.72 6031.32 "Анатолий Кулаков" А эпсилон может быть или абсолютным, или относительным.
6031.32 6036.40 "Анатолий Кулаков" Опять же, неизвестно, какой из этого лучше или не лучше использовать.
6036.40 6041.20 "Анатолий Кулаков" То есть нет подхода, который называется "самый лучший способ сравнения по умолчанию".
6041.20 6046.60 "Анатолий Кулаков" В каждой конкретной ситуации мы можем рассмотреть уже целых три подхода сравнения с float.
6046.60 6050.00 "Анатолий Кулаков" И нет самого лучшего, нужно выбирать в зависимости от ситуации.
6050.00 6051.68 "Анатолий Кулаков" Со стрингами еще интереснее.
6051.68 6057.52 "Анатолий Кулаков" Там у нас есть Ordinal, там у нас есть Kultura, там у нас есть в зависимости от регистра.
6057.52 6064.52 "Анатолий Кулаков" И тоже непонятно, что из этого должно быть дефолтным, самым главным и самым лучшим сравнением.
6064.52 6067.56 "Анатолий Кулаков" Очевидно, что не может здесь быть самого лучшего сравнения.
6067.56 6070.28 "Анатолий Кулаков" В каждом конкретном случае нам нужно что-то свое.
6070.28 6073.72 "Анатолий Кулаков" Более сложный пример - это URL.
6073.72 6078.96 "Анатолий Кулаков" Нужно ли заботиться о том, чтобы сравнивать URL с учетом регистра.
6078.96 6086.04 "Анатолий Кулаков" Нужно ли сравнивать фрагменты URL, которые являются практически незначимой частью, но в некоторых случаях они значимы.
6086.04 6105.36 "Анатолий Кулаков" Можно ли представить, что URL, у которого явно задан порт 80 и протокол HTTP, если вы сравниваете его с другим URL, который точно так же HTTP, но порт явно у него не задан, но по спецификации подразумевается, что если это HTTP, то дефолтный порт у него 80.
6105.36 6110.04 "Анатолий Кулаков" Должны ли эти два URL совпадать или не должны, или это абсолютно разные URL?
6110.04 6113.52 "Анатолий Кулаков" Все эти вопросы не имеют какого-то очевидного ответа.
6113.52 6122.48 "Анатолий Кулаков" Именно поэтому в каждой конкретной ситуации что такое равно для двух объектов универсально определить невозможно.
6122.48 6124.72 "Анатолий Кулаков" В каждой ситуации нужно это делать индивидуально.
6124.72 6130.64 "Анатолий Кулаков" И в принципе эта проблема в Дотнете уже решена, потому что у нас есть интерфейс iQuotable.
6130.64 6139.28 "Анатолий Кулаков" Интерфейс который как раз таки и позволяет сравнить объект самого себя с каким-то T, который является таким же типом как и этот объект.
6139.28 6143.08 "Анатолий Кулаков" Ну и также можно посчитать GetHashCode от самого себя.
6143.08 6145.92 "Анатолий Кулаков" Интерфейс iQuotable полностью решает эту проблему.
6145.92 6150.04 "Анатолий Кулаков" И у него есть отличный напарник, который называется iEquotableComparer.
6150.04 6158.12 "Анатолий Кулаков" Это интерфейс, который позволяет сравнить два инстанца от T и также вычислить GetHashCode от T.
6158.12 6166.52 "Анатолий Кулаков" То есть вынести вот эту логику сравнения в какой-то сторонний класс и соответственно в зависимости от ситуации использовать тот или иной EquotableComparer.
6166.52 6177.84 "Анатолий Кулаков" И соответственно, имея два вот этих интерфейса, нам вообще не нужен equals метод и GetHashCode метод в System Object.
6177.84 6180.68 "Анатолий Кулаков" Они становятся абсолютно ненужны.
6180.68 6194.28 "Анатолий Кулаков" Они становятся даже абсолютно вредны, потому что никогда не известно, что там по-настоящему заимплементировано, что скрывается за этим дефолтным или не дефолтным, а перекрытым, не важно, equals у какого-то определенного объекта.
6194.28 6210.08 "Анатолий Кулаков" Намного было бы удобнее, намного было бы лучше, если бы при сравнении или какой-то объект сам имплементил интерфейс Equotable или явно передавался какой-то EqualityComparer.
6210.08 6218.68 "Анатолий Кулаков" Например, дефолтное поведение текущего могло бы быть реализовано с помощью обычного ReferenceEqualityComparer, который сравнивал бы по ссылкам.
6218.68 6221.76 "Анатолий Кулаков" Это было бы очевидно, правильно и просто.
6221.76 6231.96 "Анатолий Кулаков" Обратимся к консюмерам, потому что прежде всего, когда говорят про GetHashCode и equals, оправдываются тем, что у нас есть некие коллекции, которым эти методы жизненно необходимы.
6231.96 6234.96 "Анатолий Кулаков" Например, dictionary.
6234.96 6242.52 "Анатолий Кулаков" И, соответственно, очень важно, чтобы у каждого объекта был хэш-код, и чтобы он мог участвовать в dictionary.
6242.52 6257.40 "Анатолий Кулаков" Но, с другой стороны, мы можем наложить специальные констрейты на dictionary, что если нам передается какой-то генерик в качестве ключа в словарик, то мы можем наложить constraint, что этот тип должен обязательно реализовать IEquotable.
6257.40 6260.12 "Анатолий Кулаков" И, соответственно, наши проблемы решены.
6260.12 6264.42 "Анатолий Кулаков" Те типы, которые реализуют IEquotable, они могут быть ключом для dictionary.
6264.42 6266.36 "Анатолий Кулаков" Те, которые не реализуют, они быть не могут.
6266.36 6267.36 "Анатолий Кулаков" В общем, все честно.
6267.36 6272.72 "Анатолий Кулаков" Или, если у вас есть тип, который не реализует, но вы знаете, как его правильно сравнивать, все очень просто.
6272.72 6278.20 "Анатолий Кулаков" Передаете IEquotableComparer для этого ключа, и все, dictionary начинает уметь с ним работать.
6278.20 6279.80 "Анатолий Кулаков" Никаких проблем с этим нет.
6279.80 6287.72 "Анатолий Кулаков" Поэтому, все-таки, вывод в том, что equals и getHashCode в объекте практически бесполезны.
6287.72 6292.48 "Анатолий Кулаков" Далее еще одна интересная секция — это монитор и работа с потоками.
6292.48 6299.36 "Анатолий Кулаков" И это, по мнению скита, одна из самых величайших ошибок в проектировании как раз BCL.
6299.36 6309.80 "Анатолий Кулаков" То есть у нас каждый объект каким-то образом связан с монитором, каким-то образом его структура построена для того, чтобы обеспечить правильный трейдинг.
6309.80 6317.16 "Анатолий Кулаков" Это поведение было ошибочно изначально проимплементировано в Java, и, к сожалению, было бездумно скопировано в .NET.
6317.16 6319.00 "Анатолий Кулаков" Вот отсюда, в принципе, все корни растут.
6319.00 6322.28 "Анатолий Кулаков" И к чему же это приводит?
6322.28 6327.44 "Анатолий Кулаков" К тому, что мы можем сделать лок на любом объекте, который у нас есть в системе.
6327.44 6332.16 "Анатолий Кулаков" Но это считается на данный момент плохой практикой.
6332.16 6348.68 "Анатолий Кулаков" Если вы, например, лочите this — объект this, потому что к этому объекту могут обращаться и точно так же лочить его или снаружи, или с других методов, которые не видят того, что данный лок на this используется для чего-то другого.
6348.68 6351.84 "Анатолий Кулаков" В общем, лочить this — это плохо.
6351.84 6353.68 "Анатолий Кулаков" Это bad practice считается.
6353.68 6362.48 "Анатолий Кулаков" И обычно используют приватное read-only поле типа Object, которое просто-напросто создают в этом классике и на него лочатся.
6362.48 6368.88 "Анатолий Кулаков" Соответственно, если у вас есть несколько алгоритмов или workflow в локе, вы создаете несколько этих полей и лочитесь на том, на котором вам нужно.
6368.88 6370.68 "Анатолий Кулаков" И никаких проблем с этим this нет.
6370.68 6372.40 "Анатолий Кулаков" Каждый лочится там, где ему необходимо.
6372.40 6382.00 "Анатолий Кулаков" Соответственно, никакого смысла иметь возможность залочиться абсолютно на любом reference-типе, ее нет.
6382.00 6394.28 "Анатолий Кулаков" То есть у нас есть какой-то специальный, обычно есть какой-то специальный классик, который специальный instance, который для этого выделен, и именно на нем сейчас весь современный код, все best practices лочатся.
6394.28 6402.60 "Анатолий Кулаков" Для чего нам нужен лок на любом reference-типе, это остается сейчас большой-большой загадкой, большой-большой неудел.
6402.60 6410.72 "Анатолий Кулаков" Намного лучше было бы, если бы монитор, который для трейдинга используется, можно было бы просто инстанцировать.
6410.72 6417.16 "Анатолий Кулаков" То есть instance монитора и служил бы тем самым объектом, который мог бы синхронизировать различные потоки.
6417.16 6426.32 "Анатолий Кулаков" И методы, которые wait, pulse, pulse all — все они были бы методами не статическими, а инстанциями метода этого монитора.
6426.32 6432.40 "Анатолий Кулаков" И тогда бы ушло все разногласие, и тогда бы ушли все вот эти многочтения.
6432.40 6438.88 "Анатолий Кулаков" Код стал бы более чистым, код стал бы более читабельным, и может быть нам даже не нужно было бы ключевое слово.
6438.88 6439.88 "Анатолий Кулаков" Ключевое слово — лок.
6439.88 6449.40 "Анатолий Кулаков" Потому что можно было бы сделать метод monitorEnter, который возвращал бы idisposable, а idisposable мы уже можем в юзинге.
6449.40 6453.52 "Анатолий Кулаков" Соответственно, с помощью юзинга мы могли бы заменить все локи.
6453.52 6461.76 "Анатолий Кулаков" Вот таким образом можно было бы избавиться от вот этих дурацких мониторов, которые зачем-то нам связаны с каждым объектом в нашей системе.
6461.76 6467.96 "Анатолий Кулаков" Еще одно интересное замечание про string.
6467.96 6470.76 "Анатолий Кулаков" То есть у каждого объекта есть метод toString.
6470.76 6478.32 "Анатолий Кулаков" И этот метод очень часто используется, и очень часто даже используется неявно в различных местах.
6478.32 6486.80 "Анатолий Кулаков" Здесь нужно иметь в виду, что обычно под этим методом можно подразумевать три различных функции.
6486.80 6494.92 "Анатолий Кулаков" Во-первых, метод toString часто используется для того, чтобы сделать какое-то представление объекта для разработчиков.
6494.92 6498.28 "Анатолий Кулаков" То есть каким-то образом его одебажить, задампить или залогировать.
6498.28 6502.84 "Анатолий Кулаков" То есть то, как можно представить этот объект глазами разработчика.
6502.84 6508.96 "Анатолий Кулаков" Во-вторых, очень часто toString используется для какого-нибудь юзер интерфейса.
6508.96 6513.56 "Анатолий Кулаков" Например, отформатировать сообщение об ошибке и показать пользователю.
6513.56 6517.72 "Анатолий Кулаков" Или, например, сделать какие-нибудь текстовые контроллы в UI.
6517.72 6529.52 "Анатолий Кулаков" И, соответственно, все это немножко противоречит первому пункту, когда объект использует toString для того, чтобы разработчикам показать какую-нибудь дамповую информацию.
6529.52 6537.76 "Анатолий Кулаков" И третий путь - это toString используется для того, чтобы отформатировать какой-нибудь машиноспецифичный код.
6537.76 6540.92 "Анатолий Кулаков" Например, сериализацию.
6540.92 6546.24 "Анатолий Кулаков" Когда мы форматируем какие-нибудь циферки, это не так страшно.
6546.24 6548.44 "Анатолий Кулаков" То есть int засериализовать может любой.
6548.44 6564.52 "Анатолий Кулаков" А если мы начинаем форматировать уже что-то сложнее, например, что-то с плавающей точкой, то там toString полностью зависит от текущей культуры и может вам выдать на разных культурах, на разных потоках, на разных машинах совсем разные значения.
6564.52 6574.68 "Анатолий Кулаков" То есть обычно для сериализации нужно использовать invariant culture, а для, например, показывания сообщений пользователю и для рисования текста на формочках, там как раз таки нужно использовать current culture.
6574.68 6581.00 "Анатолий Кулаков" И что из этого будет использоваться по-настоящему в методе toString, мы, грубо говоря, не знаем.
6581.00 6590.16 "Анатолий Кулаков" То есть для потребителя, для разработчика это абсолютно не очевидно, как заимплементирован toString в каком-то абстрактном объекте, в каком-то абстрактном классе, который мы используем.
6590.16 6601.68 "Анатолий Кулаков" И то, что смешиваются вот эти три подхода, вот эти три разные способа использования toString, это и есть проблема.
6601.68 6611.08 "Анатолий Кулаков" Потому что очень часто, практически всегда мы понятия не имеем, что там творится под капотом и как по-настоящему там должно все происходить.
6611.08 6623.12 "Анатолий Кулаков" Если мы говорим про современный кодинг, то в принципе машиноспецифичный код, который используется для сериализации, кажется, что уже разработчики отучились использовать toString в этих местах.
6623.12 6632.28 "Анатолий Кулаков" У нас есть специальные сериализаторы, они мощные, разнообразные, гибкие и мы доверяем полностью им, а сериализатор уже полностью заботится обо всем.
6632.28 6636.72 "Анатолий Кулаков" По всех частых случаях это уже, наверное, так.
6636.72 6646.52 "Анатолий Кулаков" Но для юзер интерфейса и для дампа данных для глаз разработчика toString все еще используется.
6646.52 6658.52 "Анатолий Кулаков" Поэтому здесь у Джона Скита есть такая рекомендация, что лучше бы явно использовать метод toString, то есть назвать его, допустим, toDebugString.
6658.52 6665.96 "Анатолий Кулаков" И тогда будет полностью понятно, что это не нужно использовать в интерфейсе, это можно использовать для дебага и вот только там его и надо использовать.
6665.96 6675.84 "Анатолий Кулаков" Если вы хотите, машиночитабельный код идете в сериализатор, если вы хотите для юзер интерфейса, идете в какой-нибудь Localization Manager и оттуда выдираете все сообщения.
6675.84 6680.60 "Анатолий Кулаков" Вот это было бы намного явнее и намного понятнее.
6680.60 6682.68 "Анатолий Кулаков" toString здесь тоже неудел.
6682.68 6688.00 "Анатолий Кулаков" То есть его можно было бы оставить, но желательно переименовать.
6688.00 6696.72 "Анатолий Кулаков" А может быть рассмотреть вариант, что оставлять его не надо, а запримитировать специальный интерфейс, который предоставил бы эту toDebugString.
6696.72 6701.40 "Анатолий Кулаков" Но скорее всего, в принципе, ничего страшного, если бы мы оставили этот метод и не было бы.
6701.40 6708.40 "Анатолий Кулаков" Следующий метод это MemorizeClone, который, наверное, многие даже разработчики не знают и не помнят, что он такой существует.
6708.40 6715.96 "Анатолий Кулаков" Потому что изначально он явно очень яро использовался вот с начала времен, как только дотнет появлялся.
6715.96 6727.84 "Анатолий Кулаков" После этого уже вышли какие-то рекомендации от Microsoft, где он был признан bad practice, потому что невозможно понять, насколько глубоко этот MemorizeClone работает.
6727.84 6735.04 "Анатолий Кулаков" То есть копирует ли он просто ссылки верхнеуровневые или заходит внутрь объекта и внутри объекта все копирует.
6735.04 6742.88 "Анатолий Кулаков" Ну допустим, если у вас есть какой-нибудь классик, который внутри себя содержит коллекцию и вы вызываете MemorizeClone, совсем не очевидно, что он вам вернет.
6742.88 6748.56 "Анатолий Кулаков" Клонированный объект, у которого ссылка на эту коллекцию привязана к той же самой коллекции?
6748.56 6756.60 "Анатолий Кулаков" Или же он зашел внутрь коллекции, продублировал все элементы, создал вам новую коллекцию и туда добавил дубли всех этих элементов.
6756.60 6763.64 "Анатолий Кулаков" И так можно входить в элементы и дублировать до полной бесконечности.
6763.64 6767.70 "Анатолий Кулаков" Поэтому официально Microsoft рекомендует не использовать этот метод.
6767.70 6778.36 "Анатолий Кулаков" Если вам нужно, вы сами должны заимплементировать какой-то интерфейс и уже в этом интерфейсе четко сказать, что это будет shallow copy, это будет deep copy или будет какой-нибудь structure copy или еще что-то.
6778.36 6780.96 "Анатолий Кулаков" То есть вы должны это явно обозначить.
6780.96 6792.96 "Анатолий Кулаков" Поэтому MemorizeClone по идее в объекте тоже абсолютно не нужен, потому что он непонятно что делает, непонятно в каком виде и поэтому его никто вот так вот прямо из объекта обычно не использует.
6792.96 6800.08 "Анатолий Кулаков" Можно было бы сделать это в соседнем методе, назвать там какой-нибудь класс Cloner и там сделать клон.
6800.08 6801.32 "Анатолий Кулаков" Вполне могли бы сделать и так.
6801.32 6803.16 "Анатолий Кулаков" Зачем его засовывать в объект?
6803.16 6804.28 "Анатолий Кулаков" Абсолютно не очевидно.
6804.28 6810.96 "Анатолий Кулаков" И еще с MemorizeClone существует очень много всяких неочевидных подводных камней.
6810.96 6816.84 "Анатолий Кулаков" Мало кто знает, что MemorizeClone создает объект без вызова конструктора.
6816.84 6818.68 "Анатолий Кулаков" Казалось бы полная дичь вообще.
6818.68 6822.72 "Анатолий Кулаков" Зачем в современном мире нормальному человеку это могло прийти в голову?
6822.72 6833.20 "Анатолий Кулаков" Создать объект и при этом не вызвать конструктор, который призван как раз таки для того, чтобы пронициализировать все варианты и сделать объект правильным, красивым, проверить его консистентность, статус и прочее.
6833.20 6841.08 "Анатолий Кулаков" Но такая штука была нужна и в принципе сейчас, насколько я знаю, никто таким подходом не пользуется и никому он не нужен.
6841.08 6847.52 "Анатолий Кулаков" Это еще один гвоздь в то место, откуда нужно выбросить MemorizeClone.
6847.52 6855.56 "Анатолий Кулаков" Вот в принципе мы и все MemorizeClone разобрали и в итоге давайте все-таки подведем черту.
6855.56 6863.44 "Анатолий Кулаков" Это equals, getHashCode должны просто переехать в отдельный интерфейс, который уже существует.
6863.44 6867.52 "Анатолий Кулаков" Их нужно явно выкинуть из объекта.
6867.52 6870.68 "Анатолий Кулаков" Это позволит нам более явно сравнивать объекты.
6870.68 6881.16 "Анатолий Кулаков" WaitPulsePulseAll должны перейти в класс Monitor, который теперь должен стать не статическим, а должен стать инстанцированным.
6881.16 6889.56 "Анатолий Кулаков" Метод toString должен быть переименован, для того, чтобы было более понятно, какую именно строку мы ждем отсюда.
6889.56 6897.48 "Анатолий Кулаков" MemorizeClone вообще должен быть удален или перенесен в какой-нибудь соседний класс, если это действительно кому-то может быть нужно.
6897.48 6901.76 "Анатолий Кулаков" И таким образом у нас был бы хороший, приятный, понятный и чистый объект.
6901.76 6913.32 "Анатолий Кулаков" Но правда заключается в том, что в этом мире мы с вами никогда жить не будем, потому что никто никогда на такие пряки-чичизы не пойдет.
6913.32 6921.48 "Анатолий Кулаков" И просто можно пофантазировать и попридумывать, какой мог бы быть объект и какие могли бы быть там полезные методы.
6921.48 6922.48 "Анатолий Кулаков" Вот такая грустная правда.
6922.48 6930.44 "Игорь Лабутин" Да, все потому что дженериков не придумали в самой первой версии, потому что были бы дженерики, на самом деле часть бы этих проблем могла бы уйти.
6930.44 6937.24 "Игорь Лабутин" Ты неоднократно упоминал, что вот здесь constraint, давай тут constraint добавить, но не было в версии 1.0 никаких таких constraints.
6937.24 6947.32 "Анатолий Кулаков" Да, да, не зря стандартный equals, который в object находится, он принимает object, а не t, не еще что-то другое.
6947.32 6950.32 "Анатолий Кулаков" Из-за дженериков очень много страдают.
6950.32 6956.24 "Анатолий Кулаков" И вот те люди, которые говорят, что нам не нужны дженерики в наших языках, они просто не понимают, от чего они отказываются.
6956.24 6971.52 "Игорь Лабутин" Ну хорошо, у нас дженерики есть, дотанет развивается, не боится делать breaking changes, хотя, конечно, я согласен, что этот change будет довольно breaking и вряд ли он будет сделан, но посмотрим, чем черт не шутит, вдруг что-нибудь сломают когда-нибудь.
6971.52 6987.66 "Игорь Лабутин" Давай пойдем на последнюю тему, мы сегодня прям довольно много засиделись, но кажется, что статьи все такие интересные, мы редко садимся так прям почитать длинные и большие статьи, так что будет такой особенный немножко выпуск в этом смысле.
6987.66 6993.64 "Игорь Лабутин" Мы поговорили много раз уже в этом подкасте про всякие фишечки вокруг нугета.
6993.64 7013.84 "Игорь Лабутин" Нугет там на сайте что-то делал, мы делали в нугете, не в смысле не мы, а Microsoft в нугете поддерживал всякие разные странные штуки типа package source mapping, и я опять хочу обратиться к официальной документации Microsoft, к статье, которая называется best practices for secure software supply chain.
7013.84 7019.60 "Игорь Лабутин" Мы опять же обсуждали уже такую штуку, как атаки на supply chain.
7019.60 7048.12 "Игорь Лабутин" Если вы помните, кратко напомню, это когда вы, например, публикуете в публичной репозитории нугет пакет с именем, который заведомо должен быть, содержаться в каком-нибудь private nuget фиде, и после этого, если у атакуемой стороны порядок nuget серверов указан неправильно, то есть public сначала, а потом только private, то радостно скачается пакет с public server, таким образом потенциально вредоносный код попадет внутрь.
7048.12 7062.00 "Игорь Лабутин" Ну это прям такая явная атака, но на самом деле, если вы используете nuget, ну а кто ж тут найти его не использует, то возникает вопрос в принципе секьюрности всего этого дела и как с всем этим работать и на что обращать внимание.
7062.00 7067.32 "Игорь Лабутин" И вот у Microsoft есть довольно неплохая обзорная статья про то, на что смотреть, если вы используете nuget.
7067.32 7070.52 "Игорь Лабутин" Давайте по ней пройдемся.
7070.52 7092.84 "Игорь Лабутин" Начинается статья собственно с того, что вообще говоря, сейчас не стоит вопрос, используете ли вы open source или не используете, вы его используете, как минимум потому что вы используете .NET, потому что .NET сейчас распространяется тоже частично в виде nuget, и вы вряд ли сможете, я вот кстати не пробовал, но наверное вряд ли получится собрать какое-то маломальски полезное .NET приложение, используя только офлайн SDK.
7092.84 7095.24 "Игорь Лабутин" Наверняка хотя бы с одним nuget вы сходите в сеть.
7095.24 7102.80 "Игорь Лабутин" И поэтому у вас у приложения появляется в любом случае кучка зависимости.
7102.80 7116.40 "Игорь Лабутин" И здесь нужно понимать, что зависимость это не только то, о чем вы думаете в первую очередь, то есть nuget пакеты, зависимость это на самом деле все, от чего зависит сборка и вообще ваше приложение.
7116.40 7124.12 "Игорь Лабутин" То есть это, ну понятно операционная система, вот это все, но это как бы ладно, некоторые достаточно высокий для нас уровень, другой уровень.
7124.12 7143.64 "Игорь Лабутин" Но даже если мы говорим просто про .NET, это не только nuget пакеты, но это например сама система сборки, то есть скрипты сборки, и допустим, не знаю, .NET SDK вы можете доверять, но если вы используете какой-нибудь, не знаю, кейк или еще что-нибудь, то это тоже внешняя зависимость, хотя вы можете ее так и не воспринимать.
7143.64 7155.84 "Игорь Лабутин" В этих всех зависимостях могут быть конечно какие-то уязвимости, либо специально туда добавлены, либо случайным образом получившиеся, вот, и с этим надо работать.
7155.84 7159.20 "Игорь Лабутин" То есть как только вы используете какие-то внешние зависимости, с ними надо работать.
7159.20 7163.80 "Игорь Лабутин" И вот соответственно, что говорит Microsoft.
7163.80 7180.76 "Игорь Лабутин" Во-первых, нужно знать ваше окружение, то есть, что значит знать ваше окружение, то есть не просто знать, какие nuget пакетики вы используете из вашего css-профильма, на самом деле куда они идут дальше.
7180.76 7190.92 "Игорь Лабутин" Для этого нужно знать полный граф зависимости, то есть, и вообще говоря, они говорят, что иногда следует на него смотреть и понимать вообще, что там находится.
7190.92 7210.84 "Игорь Лабутин" Вы можете это сделать через посмотреть nuget dependency граф, он генерится во время сборки в том числе, либо вы можете на GitHub, если у вас проект на GitHub, посмотреть GitHub dependency граф, он тоже умеет строить граф зависимости по каким-то своим айвлистикам и данным.
7210.84 7215.92 "Игорь Лабутин" И при этом у зависимости нужно смотреть на версии.
7215.92 7231.56 "Игорь Лабутин" Мы, например, используем в работе tool под названием white source, это SAS решение, которое анализирует все библиотеки, которые мы используем, внешние, и рассказывает, где, в какой библиотеке какие уязвимости найдены.
7231.56 7244.76 "Игорь Лабутин" И плюс, какие лицензии, то есть мы можем контролировать, какие лицензии мы используем и не появились ли каких-то новых известных уязвимостей в версиях каких-то библиотек, которые надо срочно побежать обновить.
7244.76 7245.76 "Игорь Лабутин" Это полезно.
7245.76 7256.48 "Игорь Лабутин" И это как раз-таки уже по сути относится к разделу под названием управляйте вашей независимостью.
7256.48 7266.92 "Игорь Лабутин" Во-первых, если у вас большой проект, в котором много пакетов, или даже если может быть маленький, рекомендуется периодически выполнять две таких команды.
7266.92 7276.84 "Игорь Лабутин" Одна называется .NET list package --deprecated, то есть вдруг какие-то пакеты авторы задепрекейтили и нужно срочно искать им замену.
7276.84 7287.56 "Игорь Лабутин" И то же самое только с аргументом vulnerable, и тогда вам tool расскажет, какие пакеты предположительно являются уязвимыми по той или иной причине, в которых обнаружены уязвимости, и что с ними делать.
7287.56 7298.96 "Игорь Лабутин" GitHub имеет собственную поддержку по иску уязвимости и зависимости, ее можно включить в вашем проекте, если вы хотите с ней GitHub и сделаете это.
7298.96 7308.56 "Игорь Лабутин" Дальше контролируйте ваши NuGet фиды, то есть проверяете, что у вас написано в NuGet фидах, с помощью которых вы собираете, откуда вы берете ваши NuGet пакеты.
7308.56 7321.80 "Игорь Лабутин" Вы можете NuGet перевести в формат так называемый client trust policy, когда вы будете качать только с доверенных этих самых фидов.
7321.80 7324.24 "Игорь Лабутин" Никогда не пользовался, поэтому деталей не знаю.
7324.24 7338.00 "Игорь Лабутин" Вы, может быть, кстати, видели такую штуку, как периодически, особенно во времена дотландкора 1-го, 2-го, сборка очень часто падала со словами "не могу что-нибудь сделать с project log файлом".
7338.00 7340.56 "Игорь Лабутин" Log в смысле замок.
7340.56 7350.72 "Игорь Лабутин" Вот это как раз тоже полезная тема, то есть во время сборки у вас появляется log файл, где на самом деле содержится полный дерево зависимости, которые были использованы во время сборки.
7350.72 7354.52 "Игорь Лабутин" Он появляется где-то в obj директории и в принципе обычно никак не используется.
7354.52 7377.20 "Игорь Лабутин" Но если вы такой файлик положите, если я правильно помню, рядом с tessproj, сейчас могу ошибаться, проверьте по документации, то NuGet можно запустить со специальным ключиком, так что рестор будет срабатывать и восстанавливать из ровно те версии, которые указаны в этом файле, и никакие другие.
7377.20 7388.88 "Игорь Лабутин" И если вдруг такая версия почему-то была убрана, например, из NuGet, ну потому что она признана уязвимой и удалена тем самым, unlistened, то у вас сборка сломается.
7388.88 7393.12 "Игорь Лабутин" Поэтому если у вас там какой-то очень критичный код, посмотрите в сторону log файлов.
7393.12 7406.76 "Анатолий Кулаков" Ну да, тут хотелось бы еще подчеркнуть такую вещь, что многие думают, что одного хэша коммита, например, в git, достаточно для того, чтобы собрать точно такой же код, как вот мы выпустили на продакшен.
7406.76 7420.32 "Анатолий Кулаков" Поэтому вот если на продакшене хэш у нас 42, то мы просто-напросто берем вот этот коммит, который 42, собираем у себя локально и получаем абсолютно такую же копию этого приложения, можем его дебажить, дампить, и что хотим с ним делать.
7420.32 7421.84 "Анатолий Кулаков" Вот, на самом деле это не так.
7421.84 7424.72 "Анатолий Кулаков" Как уже сказал Игорь, там есть еще куча всего вокруг.
7424.72 7432.76 "Анатолий Кулаков" Можно взять библиотечку на повыше версии, можно SDK другое сюда подсунуть, операционная система опять же влияет и прочее-прочее.
7432.76 7445.24 "Анатолий Кулаков" Поэтому вот такой подобный log файл, он более или менее уже сужает вот этот круг переменчивых зависимостей, и более или менее у вас хотя бы версии dll будут одинаковые.
7445.24 7461.80 "Игорь Лабутин" Да, дальше, если продолжать работу с NuGet, нельзя не упомянуть ту самую feature package source mapping, то есть вы можете в вашей конфигурации вашего NuGet в вашем проекте задать, какие пакеты из каких NuGet фидов разрешено брать.
7461.80 7469.12 "Игорь Лабутин" То есть, например, вы можете задать по маске, что пакеты, которые имеют префикс вашей компании, можно забирать только из internal NuGet фида.
7469.12 7474.64 "Игорь Лабутин" И тогда даже если кто-то подложит его в паблик, и у вас будет неправильный порядок, все равно не сработает.
7474.64 7478.48 "Игорь Лабутин" Это прям полезно, если вы используете много внутренних NuGet пакетов.
7478.48 7487.56 "Игорь Лабутин" Ну и последний большой раздел у них под названием monitor supply chain, то есть смотрите вообще, что там происходит.
7487.56 7508.40 "Игорь Лабутин" И здесь тоже несколько вещей, но они такие более, ну что ли, не то что абстрактные, но не то что касающиеся прям по всей темной жизни разработчиков, а именно, во-первых, можно включить github secret scanning, то есть github периодически умеет сканировать на содержание секретов в коде.
7508.40 7514.56 "Игорь Лабутин" Если вы случайно закоммитили какой-нибудь секрет, то это уже нехорошо.
7514.56 7522.40 "Игорь Лабутин" А если такой секрет оказался вдруг в NuGet, то это тоже нехорошо, потому что он будет разнесен сразу по многим, вообще говоря, клиентам.
7522.40 7527.08 "Игорь Лабутин" Так что следите за этим и не коммитите ваши NuGet всякие секретные данные.
7527.08 7540.20 "Анатолий Кулаков" Ну я больше могу сказать, что существуют специальные сканеры, которые на постоянку сканируют и NuGet пакеты, и github, и все публичные репозитории, и вычленяют по определенному шаблону различные ключи.
7540.20 7549.12 "Анатолий Кулаков" Например, с AWS ежедневно находятся вот такие вот ключики, которые люди уводят, а потом используют для своих целей.
7549.12 7553.84 "Игорь Лабутин" Да, поэтому эта штука важна, и следите за секретами.
7553.84 7565.64 "Игорь Лабутин" Дальше вы можете подписывать пакеты, если вы пишете неконечный софт, а публикуете NuGet пакеты, вы можете их подписывать, и таким образом консимеры смогут их тогда проверять.
7565.64 7571.12 "Игорь Лабутин" Вы можете включить, ну не то чтобы включить, использовать reproducible builds.
7571.12 7579.80 "Игорь Лабутин" Это тема, которая у нас на самом деле лежит в бэклоге, мы когда-нибудь до нее доберемся и подробно расскажем, что такое reproducible builds, когда сами поймем, что это такое.
7579.80 7585.44 "Игорь Лабутин" Мы пока, мне кажется, не очень понимаем до конца, зачем это и как со всем этим работать.
7585.44 7592.28 "Игорь Лабутин" Фича NuGet, NuGet-орган, про который мы рассказывали, package-id, prefix-reservation.
7592.28 7600.40 "Игорь Лабутин" Если вы автор NuGet пакетов, возможно, имеет смысл зарезервировать себе префикс, чтобы никто другой не мог выкладывать пакеты с вашим префиксом.
7600.40 7606.40 "Игорь Лабутин" Ну и опять же, если вы автор NuGet пакетов, не забывайте деприкейтить и unlist-ить package, если в нем найдена уязвимость.
7606.40 7614.84 "Игорь Лабутин" Тем самым вы скорее поможете комьюнити, чем как-то навредите, естественно, если есть более новая версия с исправлением.
7614.84 7616.40 "Игорь Лабутин" Ну вот, примерно так.
7616.40 7643.12 "Игорь Лабутин" Так что, если вы работаете с NuGet, казалось бы, с одной стороны все просто, Visual Studio или в Rider нашли пакетик, сказали ему "инсталл" и все работает, а с другой стороны, как только вы это сделали, у вас появляется вообще говоря большое количество головной боли для того, чтобы мейнтейнить все это и проверять, что ничего не сломалось и все еще работает все как надо, лицензии те же самые, уязвимостей нет и никто вредный и вредоносный вам не может подсунуть в какой-нибудь левый год.
7643.12 7650.12 "Анатолий Кулаков" Да, это очень важная, хорошая тема, очень радостно, что она начала в последнее время возникать и люди начали о ней говорить.
7650.12 7656.76 "Анатолий Кулаков" Поэтому будем надеяться, что мы в конечном счете приведем нашу экосистему к какому-то понятному, безопасному состоянию.
7656.76 7659.44 "Игорь Лабутин" Ну и на этом на сегодня мы будем заканчивать.
7659.44 7665.36 "Игорь Лабутин" Выпуск получился довольно длинный, как я сказал, но мы посмотрели довольно много хороших статей.
7665.36 7679.36 "Игорь Лабутин" Во-первых, серия статей от Andrew Locke про exploring .NET 6, то есть обзор каких-то, ну, довольно рандомного набора, но довольно больших фич .NET 6, как они устроены внутри.
7679.36 7686.36 "Игорь Лабутин" Посмотрели, как создавать SDK на основе HTTP клиента и какие подходы к этому могут быть.
7686.36 7697.64 "Игорь Лабутин" Выяснили, что у нас наконец-таки начинает появляться breaking changes в 7.NET и метод group conversion больше не будет создавать каждый раз новый делегат, а будет его кэшировать, если это статический метод был передан.
7697.64 7701.80 "Игорь Лабутин" Посмотрели, как писать более эффективный код, если вы используете EF Core.
7701.80 7709.40 "Игорь Лабутин" Помечтали вместе с Джоном Скиттом, что могло бы быть, если вы правильно задизайнили систему Object, но, к сожалению, то, что имеем.
7709.40 7716.72 "Игорь Лабутин" Ну, и если вы используете Nuget пакеты, то позаботьтесь о том, чтобы ваш supply chain был достаточно секьюрным.
7716.72 7719.76 "Анатолий Кулаков" Ну что ж, на сегодня, наверное, все.
7719.76 7721.48 "Анатолий Кулаков" Всем счастливо, всем пока.
7721.48 7723.76 "Игорь Лабутин" Всем пока, это был 47 выпуск радио .NET.
7723.76 7728.76 "Игорь Лабутин" Пока!
7728.76 7732.32 None [музыка]
