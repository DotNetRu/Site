0.00 11.52 SPEAKER_00 Здравствуйте, дорогие друзья, в эфире Radio.net, выпуск номер 63.
11.52 13.84 SPEAKER_00 В эфире, как всегда, Анатолий Кулаков.
13.84 15.60 SPEAKER_00 И Игорь Лопутин, всем привет.
15.60 22.16 SPEAKER_00 В самом начале хотелось бы поблагодарить наших друзей, тем, кто у нас помогает на нашем сайте Boosty.
22.16 27.72 SPEAKER_00 Это Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Горький Самарин.
27.72 31.92 SPEAKER_00 Спасибо большое, что помогаете, и всем другим, кто поддерживает нас на Boosty.
31.92 35.12 SPEAKER_00 Ну что ж, прогремел у нас .NET Conf.
35.12 39.88 SPEAKER_00 Надеюсь, вам понравились все те новинки, которые были анонсированы.
39.88 42.28 SPEAKER_00 Надеюсь, вам понравился выпуск, который мы записали.
42.28 47.52 SPEAKER_00 Получился довольно такой плотненький, тем у нас там просто было рекордное количество, очень много.
47.52 61.20 SPEAKER_00 Ну и естественно, всего мы не охватили, и может быть вот какие-то отголоски, какие-то инструменты, какие-то еще те ответвления будем постепенно догонять до тех пор, пока нас Microsoft не начнет нарадовать какими-то новыми релизами.
61.20 68.80 SPEAKER_00 И наверное вот сегодня несколько даже таких статейчиков, которые можно было бы отнести к выпуску .NET.
68.80 78.00 SPEAKER_00 Мы сегодня тоже вспомним, но они будут как раз-таки не новостные, а уже какие-то осмысленные, там про перформанс, про настройку, может быть, про сравнение, про еще что-то.
78.00 83.80 SPEAKER_00 Ну что ж, у нас официальная часть закончена, давай посмотрим, что у нас из статей сегодня есть.
83.80 103.28 SPEAKER_02 Да, как ты правильно сказал, сразу после релиза у нас у Microsoft не так много, так сказать, чего обсуждать с точки зрения новостей, но после релиза осталось какое-то количество статей, которые можно обсудить, или такие, точнее, не статей, а того, чего происходило в момент релиза или на презентации, которые были показаны.
103.28 112.00 SPEAKER_02 И одна из статей как раз называется "How fast is SP.NET Core?", то есть насколько вообще он быстр, SP.NET Core.
112.00 133.44 SPEAKER_02 Если вы смотрели .NET Conf презентейшн и прошлого года, и вообще говоря этого года, то в обоих презентациях было сказано, что .NET у нас очень супербыстрый, он стал еще быстрее, и в 2021 году был слайдик, где было написано, что .NET в 10 раз быстрее Node.js, ну и заодно быстрее, чем Java, Go и плюсы.
133.44 134.44 SPEAKER_02 Вместе взятые.
134.44 138.80 SPEAKER_02 Не уточнялось, но возможно, да, было бы очень здорово, если бы вместе взятые.
138.80 151.48 SPEAKER_02 В 2022 году слайдик, по-моему, был какой-то похожий, там может быть был не 10x, а 7x, я вот сейчас не помню, но смысл в том, что тоже было прям супербыстро и все такое.
151.48 173.68 SPEAKER_02 И товарищ по имени Себастин Рос, это представитель команды SP.NET, который как раз-таки занимается в том числе перформансом, сказал или написал такую фразу, что даже с самым быстрым вебфреймворком на Go, .NET все равно быстрее, при том, что он использует высокоуровневый стэк, то есть middleware, minimal API, вот это все.
173.68 194.88 SPEAKER_02 И такой товарищ, как Дастин Моррис Горский, это довольно известный, я бы сказал, ф-шарпер, который поддерживает штуку под названием Giraffe, это микровебфреймворк для ф-шарпа, он решил проверить, правда ли это, ну потому что слайдик - это слайдики, но слайдики - это менеджерская штука, давайте посмотрим, что там на самом деле, тем более, что все бенчмарки, они открыты.
194.88 197.28 None Код открыт и доступен.
197.28 226.76 SPEAKER_02 Мы говорим про бенчмарки, которые называются Tech Empower, довольно известная штука, там есть огромное количество всяких разных бенчмарков, которые проверяют и то, и это, и смысл в том, что они запускают эти самые бенчмарки у себя на серверах, то есть регулярно, но регулярность у них, она такая как бы непонятная, последний официальный раунд 21-й был в июле 22-го года, а до этого в феврале 21-го, ну не то, чтобы очень регулярно, но будем считать, что так.
226.76 283.64 SPEAKER_02 Конкретно про бенчмарки, которые нас интересуют, даже не которые нас интересуют, а которые хоть как-то могут относиться к SPNetCore, они относятся к куче категорий, есть там бенчмарки про JSON Serializers, про Single Query, Multiple Query, Caching Query, бенчмарк под названием Fortune's, ну и там несколько других, и вот как раз-таки Fortune's - это то, что является более-менее таким, то, что он называет Gold Standard в бенчмарках, именно в веб-фреймворках, потому что он более-менее пытается воспроизвести, что происходит в реальной жизни с вашим приложением, то есть в этом бенчмарке мы читаем из базы данных, сортируем данные, потом добавляем какой-то там заголовочек для всяких XSS, предотвращения XSS, и даже делаем небольшой сервер-сайт, значит, HTML-рендеринг на основе шаблонов, ну вроде как такое, обычное веб-приложение более-менее.
283.64 296.92 SPEAKER_02 Понятно, что там не гигантские данные, поскольку это бенчмарк, то он запускается там много-много-много раз, поэтому из базы данных по-моему там читается типа 12 записей или около того, но смысл в том, что все равно тестируются какие-то кусочки фреймворка.
296.92 302.00 SPEAKER_02 Итак, давайте, говорит автор, посмотрим на результаты SPNetCore.
302.00 319.92 SPEAKER_02 Находит он, если мы берем, значит, рейтинг топ всяких фреймворков, он находит там три записи с названием SPNetCore, это ASP.Core.ado, Postgres, ASP.Core.mw, Postgres и ASP.NetCore.
319.92 320.92 SPEAKER_02 Ну вроде как три.
320.92 324.52 SPEAKER_02 Они занимают, соответственно, 9, 13 и 14 места, ну вроде неплохо.
324.52 330.84 SPEAKER_02 Но если посмотреть полную таблицу, выясняется, что всего существует 15 разных ASP.NetCore бенчмарков.
330.84 338.52 SPEAKER_02 Они основаны, поскольку мы читаем из базы данных, то они основаны некоторые на Postgres, некоторые на MySQL.
338.52 343.16 SPEAKER_02 Мы выкидываем те, которые про MySQL, потому что они точно медленнее, чем те, которые Postgres, видно по результатам.
343.16 345.28 SPEAKER_02 Некоторые из них основаны на Mono.
345.28 349.44 SPEAKER_02 Mono мы тоже сейчас выкидываем, потому что мы же говорим про релиз 7-го дотнета.
349.44 358.44 SPEAKER_02 И остается у нас 7 штук, то есть 7 бенчмарков, которые все используют Postgres, и они классифицируются дальше на еще несколько категорий.
358.44 363.20 SPEAKER_02 Самый топовый, который самый крутой, он классифицирован как Platform.
363.20 371.68 SPEAKER_02 Следующие 3 классифицированы как Micro, и еще 3 более медленных классифицированы как Full.
371.68 379.60 SPEAKER_02 Причем эта классификация не является каким-то стандартом, который техэмпауэр, это просто некоторые теги, которые автор бенчмарка может навесить.
379.60 383.88 SPEAKER_02 Ну вот так оно классифицируется, почему нет.
383.88 392.48 SPEAKER_02 Если посмотреть на топовый бенчмарк, он говорит, ну давайте мы разберем, что же там в этом топовом бенчмарке, как мы так всех уделываем в 10 и больше раз.
392.48 401.84 SPEAKER_02 Сама дотнетим, команда дотнетком, считает этот бенчмарк, точнее один из тегов, который навешан на этот бенчмарк, называется реалистик.
401.84 413.44 SPEAKER_02 И он говорит, ну автор говорит, давайте, открываем код, смотрим, и приводит в структуру проекта, и в том числе скриншотик кода из программ ЦС.
413.44 418.56 SPEAKER_02 Он говорит, ну что тут, из знакомого из PanadCore тут только слово kestrel, ну типа use kestrel.
418.56 421.68 SPEAKER_02 Больше там нет ничего знакомого из ISP-PanadCore.
421.68 431.24 SPEAKER_02 Для того, чтобы этот бенчмарк был таким супер быстрым, там применено огромное количество оптимизаций.
431.24 441.84 SPEAKER_02 Там нету строчек вообще, ну точнее, строчки вы в коде увидите, но они сразу передаются в класс под названием ASCIIString, который внутри их тут же конвертит первым делом в момент инстализации в byte array.
441.84 450.60 SPEAKER_02 То есть это делается один раз за жизнь программы, и дальше эти строчки все собираются в ответы HTTP, без, понятно, конвертации, дальше в байты.
450.60 452.12 SPEAKER_02 Сразу из byte array собираются ответы.
452.12 465.84 SPEAKER_02 Все части заголовков HTTP-шных тоже сразу вычисляются в байтах и записываются, значит, грубо говоря, в переменные, которые живут все время жизни программы.
465.84 467.80 SPEAKER_02 Раутинг сделан очень круто.
467.80 469.20 SPEAKER_02 Раутинг сделан следующим образом.
469.20 472.48 SPEAKER_02 Мы получаем реквест напрямую от kestrel.
472.48 484.72 SPEAKER_02 Мы берем path в url и проверяем, условно говоря, если девятый символ в рауте равен c, то это точно не fortunes.
484.72 487.64 SPEAKER_02 Там есть несколько стандартных endpoint, по которым должны отвечать бенчмарки.
487.64 499.40 SPEAKER_02 Ну и понятно, что если учитывать, что их конечное количество, то можно написать довольно оптимальный алгоритм, который, проверяя 1-2 символа всего лишь, точно узнает, какой из этих стандартных endpoint был вызван.
499.40 507.16 SPEAKER_02 То есть это нифига не полноценный раутинг, это вот такой очень специфически заточенный под это benchmark раутинг.
507.16 512.16 SPEAKER_02 Никакого там html контекста, вообще из span-add-core только kestrel, больше ничего нет.
512.16 520.88 SPEAKER_02 Пишем мы все это напрямую в pipewriter, то есть это тоже, опять же, ну если не socket, то очень близко с kestrel.
520.88 526.44 SPEAKER_02 Никаких html-темплейтов, напоминаю, что бенчмарки подразумевают какой-то сервер-сайт html-темплейт-рендеринг.
526.44 531.48 SPEAKER_02 Никаких там html-темплейтов, типа rather-pages или rather-views нет.
531.48 536.24 SPEAKER_02 Зато мы с stringbuilder собираем строчку ответа и ее фигачим в ответ.
536.24 540.52 SPEAKER_02 И самая крутая оптимизация это с датой.
540.52 546.72 SPEAKER_02 По стандарту этого бенчмарка, по описанию, мы обязаны отправить в ответ хедер с датой.
546.72 549.72 SPEAKER_02 Ну типа там, текущая дата такая-то.
549.72 557.76 SPEAKER_02 По стандарту, опять же, http, эта дата отправляется без миллисекунд, то есть там точность секунда в этой дате.
557.76 564.44 SPEAKER_02 Поэтому команда span-add-core, точнее, команда, которая писала этот бенчмарк, сделала следующую прекрасную штуку.
564.44 573.68 SPEAKER_02 У нас есть код, который заполняет значение этого заголовка, даты текущие, в ответ, в response-header.
573.68 576.84 SPEAKER_02 Он туда берет значение статической переменной.
576.84 586.60 SPEAKER_02 И есть отдельный тред, который эту статическую переменную, там строчка, сразу, периодически раз в секунду обновляет новым значением текущего даты времени.
586.60 591.28 SPEAKER_02 Ну вызывает dateTime.utcNow.toString один раз в секунду в багграундном треде.
591.28 602.40 SPEAKER_02 И это прям сильно повышает производительность, потому что понятно, что мы за секунду обслуживаем, не знаю, тысячи реквестов, и даже сотни тысяч реквестов.
602.40 609.20 SPEAKER_02 И понятно, что вместо того, чтобы вызывать utcNow.toString на каждом, мы это делаем один раз в секунду всего лишь и кэшируем это значение.
609.20 611.92 SPEAKER_00 Ну действительно реалистик, что уж говорить, каждый
611.92 615.24 SPEAKER_02 день так и пишу. Да, реалистик, так реалистик.
615.24 624.56 SPEAKER_02 Если посмотреть на код микробенчмарков, вот три следующих, которые чуть более тормозные, они уже ну поближе к SPNetCore.
624.56 643.40 SPEAKER_02 Там все еще нет раутинга полноценного, и не то, что ML-темплейтов, там все еще StringBuilder, но там уже нормальная типа middleware, которая просто, ну по сути там все сделано на одной middleware, то есть middleware проверяет, что если путь содержит fortunes, то надо в shtp-контекст.response послать соответствующую строчку ответа.
643.40 650.08 SPEAKER_02 То есть там уже есть shtp-контекст, все дела, но никакого там контроллеров, фразеров, вот этого всего нет.
650.08 664.60 SPEAKER_02 Ну и полный benchmark, да там все как положено, все как мы знаем и любим, это контроллеры, reserview, все такое прочее, но он уже не 9, там 13 или 14, а он 109 в рейтинге.
664.60 674.68 SPEAKER_02 И он успевает обслуживать, тем не менее, 109 эта штука обслуживает 184 тысячи реквестов в секунду.
674.68 681.52 SPEAKER_02 То есть вообще говоря, числа, в абсолютном понимании числа неплохие, мы все равно все еще достаточно быстрые.
681.52 689.48 SPEAKER_02 Но далеко не на первом месте, ну и там не в десятке, назовем это так, а всего лишь 109.
689.48 696.68 SPEAKER_02 Он говорит, окей, давайте посмотрим на другие языки, может быть другие языки тоже там все четерят и делают неправильно.
696.68 724.64 SPEAKER_02 Он говорит, ну берем java, там, ну там конечно не spring, там где-то в тормозах, где-то глубоко внизу, но у java есть более легковесный раутинг и прочее, что такое, значит, такие сервера, и он на нормальном, как бы одном из таких серверов, он 12 из 400 тысяч реквестов в секунду, тут напоминаю 184, то есть типа в 2 раза быстрее на java можно написать.
724.64 739.72 SPEAKER_02 В go тоже 22 место и 381 тысяча, ну плюсы на первом месте 616 тысяч реквестов в секунду, как бы их сложно побить, поэтому говорить, что мы там быстрее c++, ну это как-то странно, мы не быстрее c++.
739.72 754.52 SPEAKER_02 Вот, а остальные языки тоже на самом деле не так все плохо, то есть и Rust, и Kotlin, и Node.js, и PHP, они все есть, Node.js только помедленнее на 100% в любом варианте, а остальные языки в разумной реализации вроде есть выше нас.
754.52 789.20 SPEAKER_02 И вывод из статьи такой, что ну блин, короче, полная фигня, как бы это все маркетологи врут, сп.netcore не такой быстрый, при том, что товарищ на самом деле пишет очень хорошо, он говорит, что типа при этом не надо винить в этом команду, ну в смысле это не команда такая плохая, что они вот так вот рекламируются, это как бы маркетинг увидел такие чиселки и решил, что да, скажем, что .net такой быстрый, хотя цель команды была в том, чтобы показать, на что способна платформа, если написать, ну если грубо говоря вы захотите написать там, не знаю, фреймворк новый поверх кестрила, то что вам может дать кестрил?
789.20 796.28 SPEAKER_02 Именно поэтому он обозван как платформ, то он реалистик, но он платформ, то есть типа на что способна вот платформ в смысле кестрила?
796.28 798.40 SPEAKER_02 И все ни жили раще.
798.40 820.84 SPEAKER_02 Вот Дэвид Фаулер в твиттере отреагировал на все это дело и как раз сказал, что ну да, типа вот мы вот так хотели, это как раз были его слова про то, что мы хотели показать, насколько быстро вы можете построить что-нибудь поверх собственно основной платформы, ну а маркетингу понравились чиселки, поэтому они сказали, что в принципе дотнет такой быстрый, хотя как бы не вчитываясь в то, кто же там быстрый.
820.84 821.84 SPEAKER_02 Вот.
821.84 858.84 SPEAKER_02 В целом, как бы вроде все более-менее остались, ну назовем это довольны, в том смысле, что вроде и статья по делу разбор и дотнет команда как бы сказала, что ну да, типа окей, вот, но дальше эта статья еще была опубликована на рейтите, ну ссылка на нее, и там в комментах пришел товарищ, который написал прям шикарнейший коммент, который говорит, ну хорошо, как бы спасибо автору, он действительно прав, что дотнет как бы чедерит, а давайте посмотрим внимательно на другие языки.
858.84 867.40 SPEAKER_02 Ну то есть как бы Go, например, который действительно использует раутинг, действительно использует темплейты, зато делает другие штуки.
867.40 906.76 SPEAKER_02 Например, он предполагает, что записи в банке, например, в базе данных, помните, я говорил, что там типа 12 штук запрашивается из BD, вот он приаллокейтит, грубо говоря, там 15 или сколько-то структур и их переиспользует на каждый запрос, ну то есть типа заполняет их заново каждый раз, из BD не аллокейти новые, то есть фактически у него не работает garbage collector вообще, а дотнет честно делает new list, ну со всей логикой удвоения размеров внутри, пока мы туда запихиваем 12 записей, он там 2 раза, по-моему, успевает удвоиться, ну то есть надо было тогда у нас тоже писать new list от 15 и желательно в статическом поле его переиспользовать.
906.76 930.08 SPEAKER_02 Потом опять же, в go template, вот этот механизм шаблонов, который там использован, библиотека, она в compile time превращает шаблон в исполняемый код, то есть по сути некоторый аналог string builder, то есть ты пишешь, конечно, шаблон, но в результате в runtime делается исполняемый код, это неплохо, почему нет, если такой язык шаблонов в дотнете, наверное, тоже можно такое написать.
930.08 936.08 SPEAKER_00 Ну t4 так делает, например, он может, в design time ты пишешь template, а во время компиляции он прямо из него код генерирует.
936.08 941.44 SPEAKER_02 Да, то есть как бы, но там условия benchmark соблюдены, template engine используется.
941.44 952.24 SPEAKER_02 Там раутер, который они используют, fastrtpt, он там типа не полностью rstpt compliant, он там на некоторые заголовки реагирует неправильно, ну и че, цель достигнута.
952.24 962.80 SPEAKER_02 Там высокие результаты Python и PHP объясняются тем, что почти все там работает на стандартной библиотеке, на сях на самом деле, и на питоне ты пишешь там типа это, вызов этой библиотеки и все.
962.80 974.12 SPEAKER_02 То есть фактически на самом деле во всех этих бенчмарках, на любой платформе есть куча читинга, ну такого как бы, не то чтобы читинга, но непонятно на самом деле в чем и мере, в общем-то.
974.12 985.80 SPEAKER_02 То есть это как бы хорошее упражнение попробовать соптимизировать те или иные сценарии, но они очень нишевые и фактически в реальной жизни таких чисел вы, конечно, не получите.
985.80 990.24 SPEAKER_02 Ну и на Java вы пишете на Springeo скорее всего, который не такой что бы быстрый.
990.24 991.24 SPEAKER_02 Вот.
991.24 1007.68 SPEAKER_02 Так же как и на дотнете вы пишете, да, на полноценном большом фреймворке и только если у вас совсем большие требования по производительности, например, вы пишете какой-нибудь proxy, тогда, наверное, вы, конечно, все сделаете на middleware и не будете контроллеры дергать, они вам там не нужны и только все замедлит.
1007.68 1008.68 None Вот.
1008.68 1031.72 SPEAKER_02 Так что для каждой, для каждого подхода к своей задачке, но интересно вот так вот почитать, что народ думает и что же вот тот самый техэмпауэр, в который все верят и говорят, о, техэмпауэр, мы заняли какое-то n-ное место, на самом деле надо внимательно смотреть, с каким бенчмарком вы заняли и какое из 15 мест, какое из 15 ваших бенчмарков.
1031.72 1038.56 SPEAKER_00 И что в это время еще там делали другие и как читерили они и вообще все вместе как это юзабельно.
1038.56 1052.16 SPEAKER_00 Да, действительно, когда начинаешь работать ради цифр, когда в твоих метриках устанавливаются какие-то критерии, какие-то чиселки, то начинаешь работать на чиселке, а не на то, чтобы сделать хорошо свою работу.
1052.16 1061.24 SPEAKER_00 Так вот типичное доказательство и здесь, когда тебе выставили какой-то бенчмарк, то ты делаешь фреймворк для того, чтобы пройти бенчмарк, а не для того, чтобы сделать быстрый фреймворк.
1061.24 1063.80 SPEAKER_00 Это грустно, конечно, друзья.
1063.80 1070.52 SPEAKER_00 Надеюсь, что все-таки мы дойдем до каких-нибудь нормальных циферок с нормальным реалистик кодом, чтобы было не стыдно.
1070.52 1074.64 SPEAKER_02 Ну слушай, 184 тысячи реквестов в секунду, мне кажется,
1074.64 1075.64 SPEAKER_01 не так, чтобы стыдно.
1075.64 1088.80 SPEAKER_00 Это неплохо, да, безусловно, неплохо, но опять же, хотелось бы точно такой же подход сравнить и на других языках, то есть с точно таким же уровнем плейнинга, таким же уровнем роутинга, в общем, как-то научиться это все хотя бы близко подгонять по функциональности.
1088.80 1093.42 SPEAKER_02 Ну языки настолько разные, что боюсь, что прям идеально подогнать не сможем.
1093.66 1097.90 SPEAKER_00 Да ладно, для Java странно скомпилируется один в один просто.
1097.90 1105.06 SPEAKER_02 Нет, Java, да, я согласен, то есть там, грубо говоря, ну там спринговая есть наверняка реализация, я не смотрел, где она там находится, но наверняка есть.
1105.06 1109.94 SPEAKER_02 То есть понятно, что нужно сравнивать, грубо говоря, мейнстрим, там, дотнета с мейнстримом Java, но…
1109.94 1112.82 SPEAKER_00 Да, то есть действительно, что люди переиспользуют каждый день.
1112.82 1118.22 SPEAKER_00 Вот взять прям по процентам, и мы видим, что там 90% всех ASP приложений, то есть всех веб-приложений – это ASP.NET.
1118.22 1124.10 SPEAKER_00 Вот значит, и в Java берем там 100% всех веб-приложений – это Spring, и погнали значит их сравнивать.
1124.10 1127.98 SPEAKER_00 И вот это должно более-менее дать какую-то реалистику картину.
1127.98 1129.98 SPEAKER_02 Ну, наверное, да.
1129.98 1131.98 SPEAKER_02 Ладно, давай дальше.
1131.98 1132.98 SPEAKER_02 Да, давай.
1132.98 1134.58 SPEAKER_00 У нас сегодня много тем.
1134.58 1144.14 SPEAKER_00 Не отходя далеко от веба, интересная статья тут есть про рассуждение немножко про Minimal API, нафига он вообще нужен, и зачем он появился, и как его можно использовать.
1144.14 1150.82 SPEAKER_00 Вот ты как думаешь, Minimal API нам все еще нужен, или это была неудачная попытка, и можно его закапывать?
1150.82 1164.30 SPEAKER_02 Знаешь, я в работе им, так скажем, не пользуюсь, а в целом я вполне, наверное, одобряю, что он есть, но я пока не понимаю, как я его буду использовать.
1164.30 1171.54 SPEAKER_02 То есть вот я, это должны быть совсем минимальные какие-то компоненты, а я небольшой любитель прямо микро-микросервисов.
1171.54 1174.30 SPEAKER_02 То есть я скорее любитель просто сервисов.
1174.30 1175.30 SPEAKER_02 Трех рутов, да?
1175.30 1176.30 SPEAKER_02 Да-да-да.
1176.30 1185.22 SPEAKER_02 То есть нет, если по какой-то логике деление, мне понадобится сделать сильно маленький сервис с одним endpoint, то наверное да, я возьму Minimal API.
1185.22 1186.22 SPEAKER_02 Почему нет?
1186.22 1187.22 SPEAKER_02 Вот.
1187.22 1202.14 SPEAKER_02 И я так понимаю, что одна из целей вот этого Minimal API была попытка собрать что-то, что не так завязано нам огромную магию рефлексии контроллеров, и вот этого всего огромного хозяйства под названием MVC.
1202.14 1212.54 SPEAKER_00 Может быть, но видишь, смотря на развитие Minimal API, особенно в последнем дотнете, который недавно зарелизался, невольно начинаешь наблюдать, что вся эта магия рефлексии проникает туда.
1212.54 1221.38 SPEAKER_00 То есть ты легко можешь заинжектировать туда любой сервис в скобочке какой захочешь, а логерю можно засунуть те же самые тайп-мароты, http-контексты и это все.
1221.38 1226.10 SPEAKER_00 То есть точно такая же рефлексия, только не через контроллер к тебе придет, а через делегат.
1226.10 1227.10 SPEAKER_00 Ну кажется, какая разница.
1227.10 1229.02 SPEAKER_02 Ну может быть, может быть.
1229.02 1238.02 SPEAKER_02 В общем, для чего-то это точно делается, есть какие-то use-case, я пока для себя их не нашел, но у меня, видимо, и сценарий пока не подходящий.
1238.02 1249.02 SPEAKER_00 Ну да, тема мутная, вот чтобы ее немножко прояснить, давайте попробуем обратиться к одному из авторов, который примерно понимает, как это использовать, зачем это нужно и как это применить.
1249.02 1256.02 SPEAKER_00 Самое главное, не в каких-то hello world, которые вы хотите показать студенту в одном файлике, а в более-менее нормальных продакшн-системах.
1256.02 1265.82 SPEAKER_00 И статья как раз-таки называется тоже довольно интересно, а не пора ли нам передумать структуру наших проектов с новым дотнетом.
1265.82 1268.58 SPEAKER_00 Давайте посмотрим, что же здесь можно передумать.
1268.58 1270.58 SPEAKER_00 Для тех, кто пропустил, начнем с начала.
1270.58 1278.14 SPEAKER_00 Во времена дотнет 6 вышла такая прекрасная штука, новый API, который называется minimal web API.
1278.14 1289.42 SPEAKER_00 Этот специальный способ, назовем его так, позволяет вам писать, обрабатывать web-реквесты, возвращать web-респонсы и все это делать абсолютно без контроллеров.
1289.42 1292.46 SPEAKER_00 Кажется, что это единственная фишка избежать контроллеров.
1292.46 1300.66 SPEAKER_00 Почему они захотели этого избежать, то есть действительно ли контроллеры такие медленные, или такие большие, или такие некрасивые, то есть вот это никакой предпосылки не было.
1300.66 1303.90 SPEAKER_00 Просто команда села и сказала, вот смотрите, как мы умеем миленько писать.
1303.90 1321.50 SPEAKER_00 С тех самых пор вкладывается огромное количество усилий в minimal API, добавляются различные методы расширения, подключается там аутентификация, авторизация, подключается dependency injection, прочие там навешиваются свагерские атрибуты и в общем он превращается в полноценную замену подхода с контроллерами.
1321.50 1332.82 SPEAKER_00 А разница казалось бы практически минимальная, та же самая однострочка с кучей атрибутов и с кучей fluent интерфейсов заменялась бы просто-напросто одним контроллером с теми же самыми атрибутами.
1332.82 1335.50 SPEAKER_00 То есть разница чисто техническая.
1335.50 1337.46 SPEAKER_00 Другой пока нам не приводили.
1337.46 1339.50 SPEAKER_00 Ну будем работать с тем, что есть.
1339.50 1351.10 SPEAKER_00 И даже если новый шаблон раньше создавали в бета-версиях первых .NET, то по умолчанию он использовал minimal API, ISP.NET template использовал minimal API.
1351.10 1360.94 SPEAKER_00 Сам от этой идеи откатились, вроде начали генерить большой нормальный стандартный, но периодически возвращаются и может быть даже официально вернутся к этому подходу.
1360.94 1381.66 SPEAKER_00 Если же мы используем minimal API template ISP.NET, в то же самое время к нам прилетает сразу top-level statement, то есть у нас нет никакого program, класса program, у нас сразу файл начинается с того, что у нас появляется application builder и мы погнали там строить web application и мапить ему всякие роуты.
1381.66 1386.42 SPEAKER_00 И буквально там из пяти строчек мы можем собрать полноценный веб-сервер.
1386.42 1392.54 SPEAKER_00 И самое интересное в этом minimal API будет, это как раз маппинг этих роутов.
1392.54 1401.10 SPEAKER_00 То есть мы там можем писать map get, передать туда роут, по которому мы хотим, чтобы наш делегат вызывался и передать непосредственно сам делегат.
1401.10 1405.58 SPEAKER_00 То есть что будет происходить, когда к нам придет запрос, например, вернуть фразу hello world.
1405.58 1407.82 SPEAKER_00 Этого в принципе вполне достаточно.
1407.82 1419.06 SPEAKER_00 Вот из таких вот делегатиков, даже я бы сказал пар, роут плюс делегатик, плюс обработчик входящего запроса и состоит minimal API.
1419.06 1427.30 SPEAKER_00 Дальше идут небольшие усложнения, там навешивается, как я уже сказал, интерфейсом или атрибутом всяким возможностям, но суть его остается на месте.
1427.30 1440.90 SPEAKER_00 При этом с новым подходом, с minimal API и top-level statement у нас нет program.cs, у нас нет startup.cs, у нас нет методов, которые конфигурируют сервисы, у нас нет папочки с контроллерами, в которых лежит куча контроллеров.
1440.90 1444.86 SPEAKER_00 У нас там есть один единственный файлик, в который можно войти и все это написать.
1444.86 1447.14 SPEAKER_00 Кажется красиво, мило и прекрасно.
1447.14 1453.90 SPEAKER_00 Но теперь давайте рассуждать в терминах как раз-таки нормальной реалистичной разработки.
1453.90 1457.22 SPEAKER_00 Что будет, если мы захотим добавить туда новую функциональность?
1457.22 1462.30 SPEAKER_00 Допустим, мы хотим добавить новый контроллер, новый обработчик, новый роут.
1462.30 1476.06 SPEAKER_00 По идее самый легкий способ, самый очевидный способ, который нас все подталкивает, это просто-напросто пойти в файлик program.cs, найти там вот этот наш web-аппликейшен и добавить к нему еще один map.get.
1476.06 1480.90 SPEAKER_00 Передать туда еще один роут и передать туда еще один делегат и вот таким образом накидывать новые фичи.
1480.90 1492.70 SPEAKER_00 Это очень просто, это очень понятно, но легко представить, что если у нас там будет большое число уже роутов, если их там будет десятки и может быть сотни, то этот файлик превратится в жуткое месиво.
1492.70 1500.94 SPEAKER_00 Он будет мега грязным, он будет очень неподдержанным, он будет абсолютно неразборчивым и ничего там разобрать будет невозможно и работать с этим, поддерживать это никак нельзя будет.
1500.94 1509.86 SPEAKER_00 В то же самое время, если бы у нас были контроллеры, то у нас там было бы 10 контроллеров по 10 методов и вполне реально такие проекты живут и даже намного больше.
1509.86 1521.06 SPEAKER_00 И поэтому люди, смотрящие после настоящего production кода на вот это издевательство, они туда не очень лезут, в этот minimal API.
1521.06 1526.34 SPEAKER_00 Другой подход, если нам нужно добавить новую кейт-фичу, это все-таки вернуться к нашим старым контроллерам.
1526.34 1532.78 SPEAKER_00 Для этого нам понадобится в билдере всего лишь на все вызвать метод addControllers, который наверняка во многих ваших проектах уже есть.
1532.78 1538.22 SPEAKER_00 И все, контроллеры будут знакомые, интересные и ими можно будет продолжать пользоваться так же, как и раньше.
1538.22 1544.14 SPEAKER_00 Но у контроллеров автор выделяет две очень большие проблемы, которые он видит.
1544.14 1554.02 SPEAKER_00 Во-первых, это то, что контроллеры группируются по техническому уровню абстракции, то есть так называемому не feature concern, а technical concern.
1554.02 1572.50 SPEAKER_00 Когда мы в папочке с контроллерами храним отдельно контроллеры, в папочке с бизнес-моделями храним бизнес-модели, может быть даже вы видели, что у некоторых есть папочка интерфейс, они там хранят интерфейсы, в папочке с enum'ами - enum'чики, в папочке с делегатиками - делегатики и прочие вот такие глупости.
1572.50 1578.38 SPEAKER_00 И в этом есть проблема, мы ее осмотрим немножко попозже.
1578.38 1595.26 SPEAKER_00 И вторая проблема это в том, что несмотря на то, что ваш запрос может быть очень простым, допустим по какому-то простому роту вернуть hello world или более приземленный пример, это по статическому, то есть по понятному константному url health-чека, вернуть ответ, что да, сервис жив.
1595.26 1608.42 SPEAKER_00 В общем, очень простая ситуация, очень элементарная, но для того, чтобы ее реализовать, вам нужно будет добавить в контроллер, вам нужно добавить action-метод, навесить там каких-то атрибутов, сделать там какой-нибудь return action result, еще что-то.
1608.42 1612.34 SPEAKER_00 В общем, слишком много действий приходится делать для каких-то примитивных случаев.
1612.34 1621.50 SPEAKER_00 То есть сложные вещи в контроллерах делаются сложно, это нормально, но легкие вещи там тоже делаются сложно, и вот это уже не очень нормально.
1621.50 1625.62 SPEAKER_00 В этом заключается вторая проблема, которую автор видит как раз-таки в контроллерах.
1625.62 1630.94 SPEAKER_00 А теперь давайте посмотрим, что же он предлагает, как он предлагает все эти дилеммы, все эти проблемы решить.
1630.94 1634.98 SPEAKER_00 Итак, прежде всего вернемся к нашему technical concern.
1634.98 1648.54 SPEAKER_00 Автор предлагает забросить традиционную модель директорий, про которую я уже чуть выше упоминал, и перевести ее из технологического аспекта более в структуру доменного моделирования.
1648.54 1661.06 SPEAKER_00 То есть сгруппировать наши папочки не по той функции, которую они выполняют, не по интерфейсам, контроллерам и моделям, а сгруппировать их по доменам.
1661.06 1677.70 SPEAKER_00 Группировка по доменам очень распространена, когда вы пишете domain layer, особенно если вы придерживаетесь DDD, вот там всегда domain layer обычно внутри себя содержит папочки именно с тем контекстом, который конкретно используется для определенных бизнес-моделей.
1677.70 1679.74 SPEAKER_00 Также можно сделать и здесь.
1679.74 1687.34 SPEAKER_00 То есть когда различные домены приложения превращаются в некую структуру папок.
1687.34 1692.26 SPEAKER_00 И эти папки обычно называют фичами или также можно их назвать модулями.
1692.26 1693.26 SPEAKER_00 Приведем пример.
1693.26 1699.58 SPEAKER_00 Вместо контроллеров в вашем приложении появляется папочка, которая называется modulus.
1699.58 1713.26 SPEAKER_00 И внутри этого модуля папочки, которые, например, для магазина могут называться корзина, могут называться заказы, какой-нибудь чек-аут, какой-нибудь юзер менеджмент или кабинет пользователя.
1713.26 1717.10 SPEAKER_00 В общем, эти папочки делятся как раз по функциональности, что они делают.
1717.10 1721.02 SPEAKER_00 И внутри этой папочки уже находится абсолютно все, что нужно.
1721.02 1730.50 SPEAKER_00 Например, для того, чтобы работала корзина, нам нужен какой-нибудь модель этой корзины, нам нужны какие-то валидаторы этой корзины, какие-нибудь серилизаторы этой корзины и так далее.
1730.50 1732.18 SPEAKER_00 Все это находится внутри одной папочки.
1732.18 1741.46 SPEAKER_00 Вот именно в этом и заключается вся суть этого фичи фолдеров или модуль фолдеров.
1741.46 1745.18 SPEAKER_00 Внутри такая папочка, как я уже сказал, называется в этих терминах модуль.
1745.18 1747.38 SPEAKER_00 Давайте же посмотрим, из чего состоит модуль.
1747.38 1753.30 SPEAKER_00 Прежде всего модуль состоит из файла, который регистрирует все зависимости, которые здесь есть.
1753.30 1760.06 SPEAKER_00 В этом файле добавляются необходимые классы в DI контейнер.
1760.06 1762.02 SPEAKER_00 То есть у него в этом файле есть два метода.
1762.02 1772.62 SPEAKER_00 Первый метод добавляет все классы в DI контейнер, а второй метод как раз прописывает руты у нашего минималпиа, то есть маппит все эти руты с делегатиками.
1772.62 1788.14 SPEAKER_00 То есть обзаведясь одним этим файлом, мы таким образом разделили все наши сотни делегатов, которые я приводил в начале, мы их разделили на 10 таких модулей, которые относятся к своему домену.
1788.14 1789.82 SPEAKER_00 У каждого модуля будет всего-навсего 10 маппингов.
1789.82 1797.22 SPEAKER_00 Это уже более чисто, это уже легко поддерживать, а само деление на модули дает нам очень хорошую например тестируемость.
1797.22 1804.50 SPEAKER_00 Для того, чтобы протестировать какой-то класс корзины, мы уже не должны потаскивать все приложения, регистрировать там какие-то непонятные зависимости.
1804.50 1813.62 SPEAKER_00 Мы просто берем вот этот классик с регистрацией корзины, вызываем у него метод зарегистрировать DI контейнер, вызываем метод зарегистрировать руты и все.
1813.62 1816.66 SPEAKER_00 И мы можем уже полноценно взаимодействовать с рутами корзины.
1816.66 1820.62 SPEAKER_00 Независимо от ничего другого, потому что он самодостаточен и полноценный.
1820.62 1826.22 SPEAKER_00 И также в этом модуле очень легко удалять ненужные вещи.
1826.22 1829.38 SPEAKER_00 Понадобился нам какой-то рут, мы его туда добавили в одном индейценном понятном месте.
1829.38 1831.50 SPEAKER_00 Не понадобился - удалили.
1831.50 1844.50 SPEAKER_00 Далее мы идем в наш программ.cs, в билдере подключаем эти модули с помощью метода register module, в аппликейшене подключаем все маппинги с помощью mapping points.
1844.50 1856.14 SPEAKER_00 И мы получаем как раз таки довольно чистый, хороший, понятный программ.cs, который просто-напросто подключает вот эти доменные модули, а в каждом отдельном модуле у нас уже распространена какая-то логика.
1856.14 1868.42 SPEAKER_00 Если у нас есть какая-то функциональность, которая нужна всем модулям, там логирование, аутентификация, какие-то middleware, те же самые свагеры, их можно для начала вставить в программ.cs, если будет нужно, просто вынести в какой-то отдельный классик.
1868.42 1873.78 SPEAKER_00 Не суть важна, у нас сейчас самая главная тема понять это вот эти вот самые модули.
1873.78 1882.46 SPEAKER_00 Естественно эти модули элементарно регистрировать автоматически, чтобы не ходить, не вызывать определенные методы, di-контейнера, mapping-routes.
1882.46 1890.26 SPEAKER_00 Мы просто можем Reflection просканировать текущую assembly, выяснить все классы, которые наследуются от маркеров, от специального интерфейса imodule.
1890.26 1902.90 SPEAKER_00 У этого интерфейса можно два метода те же самые сделать, зарегистрировать классики, зарегистрировать роуты, вызвать эти методы автоматически, и у нас появляется очень легкая и приятная модель регистрации.
1902.90 1909.42 SPEAKER_00 Нам уже не нужно менять код в нескольких местах для того, чтобы завести нам, допустим, вообще новый домен.
1909.42 1916.74 SPEAKER_00 Нам не нужно бежать в папочку с контроллером, дописывать контроллеры, в папочку с моделями дописывать какую-то модель, с валидаторами дописывать валидатор.
1916.74 1936.82 SPEAKER_00 То есть мы уже не бегаем по всему Solution, мы всего лишь навсего заходим в один модуль, добавляем туда класс, реализующий imodule, подключаем ему необходимые модельки, валидаторы, хендлеры, все подряд, и Reflection автоматически, без изменения чего-то еще снаружи, нам подхватывает эту реализацию и предоставляет все необходимые endpoints для работы приложения.
1936.82 1945.90 SPEAKER_00 Очень получается удобно, гибко и самое приятное, что в одном месте все меняется, не нужно никуда больше ходить.
1945.90 1950.94 SPEAKER_00 Модуль получается, как я уже сказал, самодостаточной единицей.
1950.94 1957.78 SPEAKER_00 И более того, он получается более гибкий, чем стандартные подходы с контроллерами и с моделями.
1957.78 1967.86 SPEAKER_00 Потому что если вы хотите сделать что-то простое, допустим, тоже самый холсчек, то внутри этого модуля вам даже не нужно выделять отдельные хендлеры.
1967.86 1976.30 SPEAKER_00 Вы просто можете с помощью minimal API смапить один единственный делегатик с холсчека, и все, и ваша функциональность реализована просто одной строчкой.
1976.30 1978.30 SPEAKER_00 Вам не нужно загоняться чем-то больше.
1978.30 1997.06 SPEAKER_00 Если у вас есть сложная функциональность, та же самая корзина, у которой есть какие-то валидаторы, какой-нибудь походок в базе данных, перемаппинг моделей, то вы можете внутри этой папочки корзина создать себе под папочки какие-то, создать себе дополнительные классики, создать себе те же самые модели.
1997.06 2003.06 SPEAKER_00 В общем, организовать полностью ту структуру, которая позволит вот эту сложность нивелировать с помощью разделения.
2003.06 2014.78 SPEAKER_00 Также модули можно, например, выделять, если у вас там завелся какой-то сабмодуль, и потом его функциональность стала настолько большой, что вы понимаете, что его нужно перенести на какой-то уровень выше.
2014.78 2015.78 SPEAKER_00 То же самое элементарно.
2015.78 2023.02 SPEAKER_00 Вы его выделяете, всего лишь на все добавляете регистрационную часть i-модуль, и все, он уже живет как полноценный модуль.
2023.02 2040.82 SPEAKER_00 Также данный подход с модулями, он более понятен, потому что, когда новый разработчик приходит в ваш проект, ему не нужно уже бегать по 50 папочкам для того, чтобы осознать, где лежат контроллеры, где лежат слои доступа к базе данных для корзины, где лежат валидаторы.
2040.82 2044.54 SPEAKER_00 Он просто идет в модуль, и в этом модуле содержится абсолютно все.
2044.54 2047.22 SPEAKER_00 Все, что ему нужно, это вот перед глазами преследовать одну папочку.
2047.22 2054.94 SPEAKER_00 Это гораздо легче, чем бегать по всему приложению и искать, где там что регистрируется, и что происходит.
2054.94 2057.66 SPEAKER_00 Следующий аспект, что по модулям легче навигироваться.
2057.66 2061.18 SPEAKER_00 То есть, довольно понятно становится, где что лежит.
2061.18 2069.10 SPEAKER_00 Это может быть вывод из предыдущего пункта, где что лежит, куда идти и что делать.
2069.10 2073.66 SPEAKER_00 Также автор рекомендует придерживаться вот этого понятия, что держать модули нужно как можно проще.
2073.66 2080.38 SPEAKER_00 То есть, если у вас есть какая-то простая функциональность, не выпендривайтесь, напишите ее в одном делегате и забудьте.
2080.38 2085.06 SPEAKER_00 Если она начинает разрастаться, тогда уже можно подумать об отдельном методе.
2085.06 2089.82 SPEAKER_00 Если она уж слишком большая, смотрите на отдельные классы или может быть даже уже потом на отдельной папочке.
2089.82 2097.38 SPEAKER_00 Но начинать всегда стоит с одного и единственного файла, вот этого модуля регистрации.
2097.38 2104.54 SPEAKER_00 Дальше его уже можно бить на различные части и усложнять по мере усложнений вашей логики.
2104.54 2110.14 SPEAKER_00 То есть, нужно держать как можно проще то, что у вас есть.
2110.14 2117.26 SPEAKER_00 И соответственно, ваша структура проектов таким образом тоже будет отражать сложность этих модулей.
2117.26 2129.62 SPEAKER_00 То есть, вы можете прям открыть проект и посмотреть, что если папочка с корзиной там наворочена, у нее там много подпапок, много каких-то файлов, вы понимаете, что это сложная доменная область и туда нужно как-то больше сил, чтобы погрузиться.
2129.62 2132.10 SPEAKER_00 То есть, вы отражается реальная доменная область.
2132.10 2147.22 SPEAKER_00 Если вы заходите в папочку в кабинет пользователя и там нет практически ничего, кроме одного файлика с парочкой роутов, который перенаправляет на какой-нибудь третий сторонний сайт, вы сразу визуально понимаете, что в вашем приложении вот эта доменная область, она довольно простая.
2147.22 2156.02 SPEAKER_00 И таким образом у вас структура проекта отражается с тем доменом, который вы используете на работе.
2156.02 2157.02 SPEAKER_00 Это тоже довольно приятно.
2157.02 2161.90 SPEAKER_00 И сами модули, они получаются довольно гибкие.
2161.90 2165.90 SPEAKER_00 Как я уже сказал, их можно прям отдельно тестировать, так как у вас это отдельная самодостаточная папочка.
2165.90 2170.78 SPEAKER_00 Их можно передвигать между друг другом, можно выделять какой-то сабмодуль, если он разросся.
2170.78 2177.66 SPEAKER_00 Можно наоборот, вкладывать их в сабмодуль, удалять элементарно, так как у нас динамическая регистрация, никто об этом даже не узнает.
2177.66 2182.22 SPEAKER_00 Комбинировать несколько модулей в одну штуку, какой-то один большой модуль.
2182.22 2188.82 SPEAKER_00 В общем, всего это данная структура каталогов, данная структура проектов позволяет очень гибко и легко делать.
2188.82 2192.22 SPEAKER_00 Автор находит очень много примеров, где такая структура давно используется.
2192.22 2215.34 SPEAKER_00 И контроллеры там как раз-таки и казались вот этой избыточной штукой, которая вырождалась всегда в класс с контроллером, и экшен-методы, просто состоящие из одного-единственного метода, который вызывает там сервис или дальше, или может быть бросает в медиатор какую-нибудь команду или какую-нибудь query, и все, и больше ничего не делает.
2215.34 2218.58 SPEAKER_00 То есть там вырождение уже было давно и было очевидно.
2218.58 2232.90 SPEAKER_00 И вот такая структура с минимал-апиаем, она как раз-таки позволяет вот этот ненужный слой, который уже эволюционно начал отмирать, вот она позволяет его вообще убрать и дальше уже подумать, что мы можем сделать на основании тех возможностей, которые у нас есть.
2232.90 2234.50 SPEAKER_00 Вот такое интересное предложение.
2234.50 2238.94 SPEAKER_00 Как ты думаешь, Игорь, достойно того, чтобы попробовать?
2238.94 2252.70 SPEAKER_02 Ну по крайней мере это выглядит как логичный способ объединить вот эти самые разрозненные, ну точнее простыню действительно этих вызовов map-get-map-get во что-то новое и хорошее.
2252.70 2259.74 SPEAKER_02 Кроме того, есть же в седьмом дотнете теперь группы, то есть теперь можно еще сказать map-group с общим префиксом.
2259.74 2268.14 SPEAKER_02 И потом ты получаешь билдер, который можешь передать, например, в какой-нибудь модуль для дальнейшей настройки endpoints.
2268.14 2270.30 SPEAKER_02 То есть возможно группы тут еще помогут дополнительно.
2270.30 2278.90 SPEAKER_00 Да, мне кажется они вот точно отражают сущность модуля, что у тебя одна группа получается, это ровно на один модуль, ты его там полностью, этот домен описываешь.
2278.90 2284.46 SPEAKER_02 Ну единственное, что если тебе дать только самый групп билдер, ты не сможешь добавлять новые сервисы.
2284.46 2293.26 SPEAKER_02 То есть от сервисов тоже, ну от модуля тоже нужен тот самый интерфейсик, который сможет добавить тебе нужные модули сервисы до того, как ты пошел определять endpoints.
2293.26 2300.10 SPEAKER_02 Но в целом для endpoints возможно группы будут как-то тоже более интересны и добавят возможностей.
2300.10 2301.94 SPEAKER_00 Там именно поэтому выделено два метода.
2301.94 2304.94 SPEAKER_00 Один метод регистрирует сервисы в DA, а второй только маппет роуты.
2304.94 2305.94 SPEAKER_00 Ну да.
2305.94 2306.94 SPEAKER_00 То есть там они именно разнесены во времени специально.
2306.94 2322.58 SPEAKER_02 Ну в общем надо посмотреть, я пока не видел ни одного такого прям большого хорошего жирного проекта на minimal api, в основном так всякие модельные штуки, но я, наверное по open source, если пошариться, то можно найти.
2322.58 2324.78 SPEAKER_02 Посмотрим, подождем, может на работе появится.
2324.78 2335.42 SPEAKER_02 А пока пойдем дальше, и следующая штука, которая я не знаю насколько она появится на работе, я пока не готов такую штуку брать в работу, это новый сериализатор.
2335.42 2340.22 SPEAKER_00 Подожди, подожди, это самый быстрый сериализатор на свете, его надо брать в работу, он же самый быстрый,
2340.22 2349.98 SPEAKER_02 он же за перформанс. У него есть некоторые но, которые мне, например, не то чтобы не позволяют его взять, но я буду сильно сомневаться брать его или нет.
2349.98 2366.74 SPEAKER_02 Смотрите, в общем, был у нас message pack такой формат, формат в принципе он написан отдельно, у него есть спецификация, и у нас была реализация message pack для C# написанная человеком по имени Yoshifumi Kawai, который возможно вам известен по нику NewCC.
2366.74 2377.82 SPEAKER_00 Я думаю, что если вы сталкивались с быстрой сериализацией, с бинарной сериализацией, искали самый клевый, самый крутой сериализатор, то вы обязательно с ним сталкивались, потому что этот просто гений сериализации.
2377.82 2389.46 SPEAKER_02 Да, у него был UTF-8 Jason сериализатор, который быстрее всех, у него был Zero Formatter, по-моему, это называлось, который тоже там как-то очень быстро все сериализовывал, десериализовывал, но они были очень специфичные и узкие.
2389.46 2410.70 SPEAKER_02 А здесь он, соответственно, да, message pack никуда не делся, message pack живет, он используется в SignalARIA, туда пришли ребята из Microsoft, помогли все это оптимизировать, переписать, дописать на Span и вот это все, но этого показалось мало, и поэтому этот самый товарищ Yoshifumi, он написал новый сериализатор, назвал его Memory Pack.
2410.70 2423.66 SPEAKER_02 Он еще в несколько раз быстрее message pack, лучше всего он работает на семерке, на седьмом дотнете, но также поддерживает пятый и шестой дотнеты, то есть если вы на чем-то более раннем, забудьте, он не будет работать.
2423.66 2430.46 SPEAKER_02 Еще он поддерживает Unity и он поддерживает TypeScript, про TypeScript отдельно расскажу чуть позднее.
2430.46 2450.90 SPEAKER_02 Причем он такой как бы, сериализатор прикольный, он там поддерживает полиморфизм, умеет быть version tolerant, циклические ссылки и все возможные современные способы ввода-вывода, это интерфейсы iBufferWriter, это работа с ReadOnlySequence, с системой iOPipelines, вот это все.
2450.90 2455.46 SPEAKER_02 Короче звучит, я статью начал читать, звучало прям вообще зашибенно.
2455.46 2456.94 SPEAKER_02 Плюс он использует SourceGenerator.
2456.94 2459.78 SPEAKER_01 Обязательно, какой же сериализатор без SourceGenerator?
2459.78 2460.78 SPEAKER_00 Да.
2460.78 2462.42 SPEAKER_02 Вообще красавчик, заверните два, я уже беру.
2462.42 2481.94 SPEAKER_02 Да, поэтому теперь во-первых, для того чтобы его использовать, вы должны сделать следующее, вы должны ваш класс, который вы хотите сериализовывать, ну и вы его объявляете partial, ну чтобы к нему можно было, понятно, накрутить сериализатор, нагенерить собственно сериализатор, и помечаете его атрибутом memory-packable.
2481.94 2484.14 SPEAKER_02 Ну и все, вы готовы.
2484.14 2500.66 SPEAKER_02 В смысле, все нормально, поскольку он от SourceGenerator, то это все там AOT-friendly, плюс в CompileTime у вас проверят, что внутри вашего класса или структуры, которую вы сериализуете, лежат только те классы либо структуры, которые он умеет сериализовывать.
2500.66 2507.02 SPEAKER_02 Тут возникают тонкости, он сериализует далеко не все, есть некоторые но.
2507.02 2516.54 SPEAKER_02 Во-первых, статья дальше продолжает говорить следующее, возьмем самый простой тип, это int, ну int-ов у нас много, их сериализовать надо.
2516.54 2519.14 SPEAKER_02 Какие у нас есть варианты сериализации int-а?
2519.14 2532.26 SPEAKER_02 Мы можем его сериализовывать как бы как 4 байта, ну просто вот взять 4 байта и записать, а можем сериализовывать по технологии, которая называется, ну или спецификации, которая называется var int, которая как раз используется в MessagePack.
2532.26 2545.62 SPEAKER_02 Идея там в том, что для маленьких чисел, которых у нас вообще говоря довольно много, используется тогда минимум 1 байт, то есть 1 битик из байта на самом деле просто используется для признака, есть ли там еще следующий байт за этим числом.
2545.62 2550.02 SPEAKER_02 И по сути у вас 32 бита этого числа размазывается уже не по 4, а по 5 байтам максимум.
2550.02 2558.02 SPEAKER_02 Плюс это, ну то есть во-первых, большие числа потребуют больше байт, ну очень большие, да.
2558.02 2567.62 SPEAKER_02 А во-вторых, это все-таки требует некоторых ресурсов CPU на предмет, значит декодировать это все, потому что битовые операции, вот это все, ну короче, какая-то работа требуется.
2567.62 2575.02 SPEAKER_02 Но если вы фигачите по int-ы прям как они есть, то сериализация будет быстрее, особенно если это массивы.
2575.02 2583.14 SPEAKER_02 Понятное дело, что вы просто можете скопировать целиком весь массив в выходной поток или наоборот, и у вас все гораздо быстрее.
2583.14 2590.34 SPEAKER_02 Вот, значит здесь в этом новом сериализаторе используется fixed сериализация, то есть int-ы сериализуются как 4 байта.
2590.34 2597.54 SPEAKER_02 В massage-паке использовался varint, поэтому он компактнее, но зато помедленнее.
2597.54 2598.54 SPEAKER_02 Дальше строки.
2598.54 2600.98 SPEAKER_02 Со строками ситуация в каком-то смысле похожа.
2600.98 2604.90 SPEAKER_02 В тотнете внутри они хранятся в utf-16, как вы может быть знаете.
2604.90 2620.90 SPEAKER_02 Если мы в основном работаем со строками, которые у нас влезают в utf-8, то есть английский и прочие не очень экзотические языки, то по сути сериализованная строчка в utf-16 будет занимать в 2 раза больше места.
2620.90 2633.14 SPEAKER_02 В данном случае у него был сделан выбор в пользу сериализации в utf-8, хотя можно настроить, чтобы он сериализовывал прям в utf-16, если вам важна скорость и не важен размер.
2633.14 2637.62 SPEAKER_02 Тогда он будет прям фигачить байтиками из массива чаров изнутри строки.
2637.62 2652.14 SPEAKER_02 При этом, забавный момент, поскольку мы в момент сериализации по строке проходимся, в любом случае, то мы вместе со строкой сериализуем ее длину, причем ее длину и в utf-8 размере и в utf-16 размере.
2652.14 2656.86 SPEAKER_02 Они могут быть разные, поскольку там разные эти уникальные символы.
2656.86 2662.86 SPEAKER_02 И это помогает потом быстро десериализовать, потому что мы сразу можем залокитить нужный размер.
2662.86 2669.74 SPEAKER_02 Ну и есть еще несколько всяких трюков на предмет того, что массив булов он пакуется как массив битов.
2669.74 2671.06 SPEAKER_02 Ну то есть тут понятно.
2671.06 2675.56 SPEAKER_02 А еще у него есть компрессия, но компрессия прям на уровне отдельных байтерей.
2675.56 2687.66 SPEAKER_02 То есть можно на какой-нибудь байтерей, если вы знаете, что в нем прям много всего хранится, прямо на весь атрибут, а вот этот еще пожми, пожалуйста, дополнительно, и он будет использовать алгоритм Бротли, чтобы пожать вот этот байтерей при сериализации.
2687.66 2694.30 SPEAKER_02 По тестам, говорит, выходит это эффективнее, чем сжимать потом итоговый поток.
2694.30 2696.26 SPEAKER_02 Зачем потребовался dotnet 7?
2696.26 2702.10 SPEAKER_02 То есть не то чтобы потребовался, но 7 версия немножко отличается от 5 и 6, она даже немножко быстрее.
2702.10 2706.38 SPEAKER_02 Во-первых, ну она более оптимизирована, поэтому она побыстрее.
2706.38 2709.70 SPEAKER_02 Во-вторых, используются статически абстрактные мемберы в интерфейсах.
2709.70 2728.42 SPEAKER_02 То есть вот вы объявляете вашу модель как partial class, source generator, понятно, дописывает свою часть как свою часть partial class, и в этом месте объявляет, что ваш модель реализует некоторый специальный интерфейс, в котором генерится на самом деле два метода serialize и deserialize статически.
2728.42 2729.42 SPEAKER_02 Чуешь смысл?
2729.42 2731.42 SPEAKER_01 Ну да, нормальный подход.
2731.42 2741.94 SPEAKER_02 То есть у тебя получается на твоей модели волшебным образом появляются два метода serialize и deserialize, которые статически, но они реализованы в стороннем интерфейсе, и за счет этого их не нужно реализовать в твоем методе.
2741.94 2745.14 SPEAKER_02 Ну допустим, почему бы нет.
2745.14 2746.14 SPEAKER_02 Вот.
2746.14 2757.10 SPEAKER_02 Дальше используются reffields, и дальше используются всяческие супер оптимизации для типов, ну, стандартной библиотеки, назовем это так, то есть listt.
2757.10 2765.18 SPEAKER_02 То есть, например, у него есть в коде структурка, которая по набору полей полностью повторяет внутреннее устройство listt.
2765.18 2772.74 SPEAKER_02 И за счет этого он может оптимально, оперируя эту структуркой, оптимально копировать содержимое listt.
2772.74 2776.98 SPEAKER_02 То есть там очень такая low-level магия, сильно завязанная она.
2776.98 2780.38 SPEAKER_02 То есть если сейчас в рантайме взять и поменять порядок полей в listt, этот стерилизатор сломается полностью.
2780.38 2784.50 SPEAKER_00 Я помню, у Стэна Драпкина был похожий хак, у него было еще круче.
2784.50 2787.02 SPEAKER_00 Ну, смысл в том же самом, да.
2787.02 2794.18 SPEAKER_00 И его расчет, как раз я ему задавал этот вопрос, его расчет был на то, что типа listt — это настолько устраивающаяся структура, что никто им не отнимет.
2794.18 2795.18 SPEAKER_00 Да.
2795.18 2796.18 SPEAKER_02 Мы в этом уверены.
2796.18 2797.18 SPEAKER_02 Да, именно поэтому.
2797.18 2813.82 SPEAKER_02 То есть тут тоже есть некоторое количество хаков, то есть, например, он использует новую штуку, по-моему, это в шестом, знаете, появилась, да, вот это вот collection-marshal s-span, по-моему, в шестерке появилась, когда ты можешь получить доступ к, собственно, массиву внутри листа, значит, ну к спану точнее, да, поверх массива внутри листа.
2813.82 2818.50 SPEAKER_02 Но там, например, проблема в том, что этот спан возвращается той длины, сколько у тебя элементов в листе.
2818.50 2821.98 SPEAKER_02 При десерилизации у тебя сколько элементов в листе внутри нового?
2821.98 2824.98 SPEAKER_00 Мы не знаем, если не записали каунт.
2824.98 2829.46 SPEAKER_02 Не-не-не, очевидно ноль, ну в смысле, ты вот взял лист, даже если… Ты хочешь его наполнить, да?
2829.46 2839.78 SPEAKER_02 Да, я хочу наполнить его десерилизацией, он пустой, возможно, массив-то не пустой, потому что, возможно, массив мы там переиспользовали откуда-то, ну в смысле, в этом листе мы ему сказали clear, грубо говоря, перед этим.
2839.78 2846.94 SPEAKER_02 Он там, в нем что-то лежало, то есть он может быть длинный, но если ты скажешь collection_marshal_span, тебе вернется спан нулевой длины.
2846.94 2875.54 SPEAKER_02 Поэтому через вот эту вот типа копию-не копию, значит, структурки, через приведение типов можно внутри листа задать, что у него на самом деле length нужной тебе длины, которую ты взял из десерилизатора, после чего спан тебе вернет нужную длину, ну в смысле, collection_marshal_span вернет спан нужной длины, ты в этот спан запишешь содержимое из, собственно, десерилизованных данных и проставишь эту длину еще раз уже нормально.
2875.54 2880.34 SPEAKER_02 Короче, там такая супермагия, ну значит, от этого он, конечно,
2880.34 2892.02 SPEAKER_00 быстрый. Ну, может, это и звучит как бы страшно, но если разобраться, то все эти ORM-ки, допустим, самые быстрые, все десерилизаторы, которые самые быстрые, они такую магию применяют уже давно и долго, поэтому это нормально.
2892.02 2897.72 SPEAKER_02 Ну да, ну в общем, для десерилизатора такого general purpose звучит немножко страшно.
2897.72 2911.06 SPEAKER_02 Итак, детали, значит, десерилизует он, понятно, все встроенные типы плюс кучу встроенных коллекций, там основные, понятно, листы, дикшн, ремапы, вот это все, стеки очереди и все такое прочее.
2911.06 2923.58 SPEAKER_02 Значит, если вы десерилизуете структуру, то никакие аннотации, вообще десерилизатор позволяет задать всякие аннотации, ну типа вызвать callback до сериализации, после сериализации, вот это все.
2923.58 2934.66 SPEAKER_02 Короче, если это структура, то никаких там конструкторов аннотаций вызываться не будет никогда, она сериализуется просто напрямую из памяти, вот как она лежит, так и сериализуется туда-сюда.
2934.66 2962.62 SPEAKER_02 Поддерживается полиморфизм, для этого нужно либо на базовом классе, либо интерфейсе, разметить атрибутиками, типа вот у этого интерфейса есть там челды такие-то, каждому челду присвоить свой номер, он, видимо, будет сериализован как ключик, чтобы понимать, какой класс создать при десерилизации, но можно эту штуку собрать и в коде тоже, в рантайме прямо определить, сколько у тебя там челдов и как их десериализовать.
2962.62 2967.46 SPEAKER_02 Дальше эта штука поддерживает два режима версионирования.
2967.46 2976.82 SPEAKER_02 Есть так называемый режим limited version tolerance, то есть такой ограниченный режим версионированности, в нем работают следующие ограничения.
2976.82 2991.54 SPEAKER_02 Во-первых, если у вас есть структура, то вы не можете ее менять вообще никак, ну вот совсем, то есть если вы какую-то структуру описали, начали ее сериализовать, все, ее менять больше нельзя никогда, иначе вы десериализовать не сможете, потому что она десериализуется при моем копировании.
2991.54 3006.62 SPEAKER_02 Вы можете добавлять мемберов, но удалять нельзя, а также вы не можете менять у мемберов тип, либо порядок, то есть по сути вы в классы, вы можете просто дописывать поля в конец, больше вы не можете делать ничего.
3006.62 3015.46 SPEAKER_02 Это, понятное дело, довольно ограничивает все, поэтому есть версия, которая называется full version tolerance, точнее режим работы.
3015.46 3030.78 SPEAKER_02 В этом случае структурки все еще не могут быть поменены, там ничего не поменялось, а у классов все мемберы должны обязательно иметь атрибут memory pack order и явно прописанные чиселку, в каком порядке их сериализовать.
3030.78 3049.82 SPEAKER_02 Ну и понятно, в этом случае вы можете добавлять и удалять, но если вы добавляете новые элементы, поля или property, то нужно будет использовать неиспользуемые чиселки, то есть вы дописываете в конец, а если какое-то поле удалили, то больше эту чиселку переиспользовать нельзя в этом классе.
3049.82 3055.74 SPEAKER_02 Но логика понятна, поскольку мы не сериализуем имена, мы сериализуем только значения, но нужно знать точный порядок.
3055.74 3058.70 SPEAKER_02 Поэтому такие дела.
3058.70 3062.30 SPEAKER_02 Тип все еще менять нельзя у мемберов.
3062.30 3072.38 SPEAKER_02 Получается, за счет того, что в отличие от message pack тут не пишется ни имена, ни структура, ничего, получается понятно, очень компактный формат, до некоторой степени вообще похоже на protobuf, в общем-то.
3072.38 3082.02 SPEAKER_02 Там по сути тоже самое, тоже размечается порядок строгий, типы заранее известны в схеме, и вы просто гоняете все только значения.
3082.02 3088.50 SPEAKER_02 Но вот он такой, protobuf, но без явной схемы на основе классов.
3088.50 3101.54 SPEAKER_02 При этом есть опция в compile time, поскольку это все source генератор и вот это все, то в compile time выплюнуть файлик, в котором будет написано, а какая же в итоге псевдосхема какая получается.
3101.54 3116.98 SPEAKER_02 То есть это позволяет, например, во время CI проверить, что эта схема не поменялась, то есть закоммитить предыдущую схему и если схема поменялась, как-нибудь на CI отругаться либо сверить схемы и проверить, что вы там поля не убрали, что-нибудь в таком духе.
3116.98 3140.14 SPEAKER_02 Короче, довольно много ограничений, но если вам нужен прям супербыстрая скорость или у вас довольно такие стабильные типы, ну например вы сериализуете много там, не знаю, каких-нибудь там векторов или матриц, которые строго фиксированы на размеры и никогда меняться не будут, ну потому что что там еще в векторе из трех элементов нужно добавлять, там всегда три элемента, то возможно такой сериализатор имеет место, имеет право на жизнь.
3140.14 3141.14 SPEAKER_02 По перфомансу.
3141.14 3172.02 SPEAKER_02 По перфомансу есть замеры, ну я видел их только в этой статье пока, поэтому не знаю, будут ли еще какие-то независимые когда-нибудь, но смысл в том, что если мы берем JSON, JSON для сериализуется в бенчмарках MessagePack за 23 секунды, ой за 23 миллисекунды видимо, десериализуется за 39, а MemoryPack за 13-25 соответственно, то есть выигрыш где-то раза в 2 на сериализации и в 1,5 на десериализации.
3172.02 3196.18 SPEAKER_02 А вот если мы берем, вот тут для примера сериализовался век, как раз таки массив из векторов, то есть массив из трехмерных векторов, 10 тысяч элементов, то MessagePack на это тратил 10 миллисекунд и 26 на распаковку, а MemoryPack 0.2 и 0.3 соответственно, то есть тут уже разница в, что там, 10, в 50 раз приблизительно.
3196.18 3210.30 SPEAKER_02 То есть ну прям по скорости действительно круто, ну понятно за счет чего, за счет того, что он работает напрямую с памятью во многом старается, то есть положить в сериализованные данные ровно так, как они лежат в памяти объектов, удобно ведь?
3210.30 3227.34 SPEAKER_02 При этом в этой же статье есть вполне частное сравнение с MessagePack с точки зрения функциональности, то есть и он говорит, что MessagePack все еще круче, чем MemoryPack, чем, что во-первых он точно совместим между разными языками, MessagePack вы сможете распаковать на Java, на Python, на чем угодно.
3227.34 3232.78 SPEAKER_02 MessagePack совместим с JSON в том смысле, что в MessagePack пишутся имена, вам не нужно знать схему.
3232.78 3244.42 SPEAKER_02 Он полностью version-tolerant по дефолту, он позволяет там всякие анонимные типы сериализовывать и так далее, ну и он давным-давно работает, так сказать, проверен временем.
3244.42 3257.74 SPEAKER_02 MemoryPack по дефолту, ну как бы, понятно, супербыстрый, но по дефолту limited version-tolerant, то есть вы очень ограничены, что вы можете делать с полями и изменениями ваших моделей.
3257.74 3262.50 SPEAKER_02 Единственный поддерживаемый язык, кроме C#, это TypeScript.
3262.50 3275.26 SPEAKER_02 Для TypeScript там на самом деле в момент компиляции генерятся JS-файлики, которые нужно потом заинклюдить в ваш код TypeScript, и там написан JS-код, который, собственно, может десериализовать и сериализовать то, что вы собрали.
3275.26 3277.74 SPEAKER_02 То есть там тоже код дегенерации, по сути, это делается.
3277.74 3307.46 SPEAKER_02 И он, конечно, MemoryPack лучше, чем MessagePack, если вам нужен performance, если вам нужен AOT, потому что MessagePack все еще на рефлекшене, а не все там работает в AOT, MemoryPack - Strongly Compiled Time, поэтому там AOT, полиморфизм, циклические ссылки, то, что называется Override Deserialization, то есть вы можете подсунуть существующий объект, как мы смотрели с примером, в список, и он в существующий список заново положит новые данные.
3307.46 3310.70 SPEAKER_02 Ну, в общем, примерно так.
3310.70 3330.10 SPEAKER_02 И рекомендация автора, собственно, говорит следующее, что если вы живете только в C#, в C# ни с кем другим не общаетесь, и у вас достаточно стабильные модели, можно использовать MemoryPack, но думайте про вот эту версионность, то есть если вы собираетесь часто менять модели, скорее всего, это не ваш вариант.
3330.10 3332.82 SPEAKER_02 В любом другом случае, используйте MessagePack.
3332.82 3333.82 SPEAKER_02 Как-то так.
3333.82 3336.86 SPEAKER_02 Будешь использовать такую штуку.
3336.86 3360.18 SPEAKER_00 На самом деле я много писал проектов, где скорость и компактность, и Memory Allocation были очень важными вещами, важнее всего, и честно могу сказать, что вот эти все глупости, толерантность к версионированию, меняние порядка полей, еще что-то, ну вообще это не играет никакой роли, если вам нужно выжать максимальный перформанс.
3360.18 3368.70 SPEAKER_00 Я думаю, что здесь даже полиморфизм в дистиллизации появился только потому, что его элементарно поддержать с помощью Source Generator.
3368.70 3372.18 SPEAKER_00 Если бы не было Source Generator, то тут бы и полиморфизма тоже, естественно, никакого бы не было.
3372.18 3373.18 SPEAKER_00 Это слишком затратно.
3373.18 3378.54 SPEAKER_00 Поэтому если, ну то есть люди, которые выжимают перформанс, они не загоняются такими глупостями.
3378.54 3381.06 SPEAKER_00 Для них вот главное перегнать максимально эффективно.
3381.06 3391.22 SPEAKER_00 И поэтому там делаются и отдельные структуры, которые никогда в жизни не меняются, а если меняются, то заводятся полностью другие структуры, постепенно все переезжается руками.
3391.22 3395.70 SPEAKER_00 И полиморфизм там делается руками, если вдруг это почему-то вам нужно в таком случае.
3395.70 3400.22 SPEAKER_00 В общем, там где нужен перформанс, все вот эти минусы, они абсолютно несущественны.
3400.22 3404.74 SPEAKER_00 Там нужно просто гонять Massive Byte, просто как сумасшедший максимально эффективно.
3404.74 3413.18 SPEAKER_00 И если там действительно Memory Pack показывает шикарные результаты, которые обгоняют всех, то конечно, я его использовать буду.
3413.18 3417.90 SPEAKER_00 Я еще хотел подчеркнуть это, что это как раз не General Purpose, а сервизатор, как ты говорил.
3417.90 3422.10 SPEAKER_00 А если мне нужен какой-нибудь General Purpose, то наверное, Message
3422.10 3433.10 SPEAKER_02 Pack, да, наше все. Ну вот авторы, я так понимаю, это все дело, судя по тому, что это что-то поддерживает Unity, как раз это все пилят ради игр, где много однотипных мосилов, так скажем.
3433.10 3434.10 SPEAKER_00 Массивые экстрапов, матрицы.
3434.10 3438.98 SPEAKER_00 Да, где как раз таки не важен ваш JSON compatibility, так наплевать всем на него.
3438.98 3440.30 SPEAKER_02 Да, и там это все нужно.
3440.30 3444.86 SPEAKER_02 Но действительно, наверное, есть такие области в обычном программировании, но скорее всего, я все-таки потащу Message Pack.
3444.86 3448.98 SPEAKER_02 Я пока не вижу, где я такое могу использовать, но опять же, областей есть много разных.
3448.98 3454.86 SPEAKER_02 Давай дальше, у нас еще много тем, поэтому надо не останавливаться.
3454.86 3457.02 SPEAKER_00 Да, да, давай быстрее.
3457.02 3465.70 SPEAKER_00 Чтобы развеять там твой перформанс, интерналс и все такое, хочу немножко стратегическую для начинающих бросить, говорим про GitHub Actions.
3465.70 3486.30 SPEAKER_00 Так вдруг случилось, что я почему-то узнал, что если люди уже начали выходить на GitHub, то есть раньше у нас на GitHub вообще разработчики в России практически не выходили, сейчас уже мы GitHub не боимся, сейчас уже GitHub это как бы стандартная часть нашей жизни, не только там, чтобы посмотреть, но и многие люди уже как бы и даже коммитят, и даже пушат, и даже вообще не боятся.
3486.30 3497.94 SPEAKER_00 Но GitHub Actions это все еще для многих какой-то черный ящик, вот поэтому хотелось бы дать такую вводную про GitHub Actions, зачем он нужен, для чего используется и вообще как он может помочь дотнет-разработчику.
3497.94 3500.62 SPEAKER_00 Давай немножко быстренько в это дело и копнем.
3500.62 3504.10 SPEAKER_00 Соответственно, что такое GitHub Actions?
3504.10 3508.94 SPEAKER_00 Это возможность continuous integration и continuous delivery для GitHub.
3508.94 3521.14 SPEAKER_00 Самое в нем прекрасное в том, что он бесплатный, доступен абсолютно каждому, если у вас есть репозиторий, то в этом репозитории вы можете смело использовать бесплатный CIDI, что в наше время в принципе очень даже хорошо и очень даже щедро.
3521.14 3525.86 SPEAKER_00 У них там довольно нормальный пол агентов, в принципе у меня никогда не было с ними проблем.
3525.86 3532.66 SPEAKER_00 Я раньше сидел на всяких Avera и Travis, и там у меня все время были какие-то очереди, занятости, все такое.
3532.66 3540.42 SPEAKER_00 Здесь же Microsoft вкладывает огромное количество бабла, введено в эту инфраструктуру, и агентов там полно, никаких очередей нет.
3540.42 3543.10 SPEAKER_00 Но давайте поближе, для чего это все?
3543.10 3549.86 SPEAKER_00 Прежде всего, чтобы автоматизированно тестировать, билдить, конечно же, ваш код и может быть даже деплоить.
3549.86 3553.46 SPEAKER_00 GitHub Workflow представляет собой набор YAML файликов.
3553.46 3567.38 SPEAKER_00 Это расширение .yaml какой-нибудь или .yml, и данный файлик просто-напросто складывается внутрь вашего Git репозитория и в специальную папочку, которая называется .git/workflows.
3567.38 3576.06 SPEAKER_00 В этой папочке вы можете сложить несколько различных YAML файликов, в зависимости от того, насколько многообразный Workflow вам требуется.
3576.06 3594.98 SPEAKER_00 Прекрасно здесь то, что нет никакого GUI, не может там какие-нибудь кнопочки утечь, не надо никуда переносить, это всего-навсего настраивается в одном YAML файле, что поддерживает тему Build as Code, то есть мы собираем весь билд и описываем его в виде того же самого кода, если из-за кода считать YAML, и это очень удобно.
3594.98 3610.18 SPEAKER_00 Версионируется, распространяется вместе с бранчами, можно экспериментировать в различных ветках, не мешая основной, есть и история, можно всегда посмотреть, кто это, кто менял какие переменные, в общем все прелести кода у билда здесь появляются.
3610.18 3623.66 SPEAKER_00 Workflow, GitHub Workflow, он как раз-таки использует GitHub Actions, GitHub Actions состоит из инструкций, а вот эти самые непосредственные инструкции, они запускают таски.
3623.66 3627.34 SPEAKER_00 В общем такая иерархия, давайте разберемся подробнее в терминологии, чтобы не запутываться.
3627.34 3629.58 SPEAKER_00 Прежде всего GitHub Actions.
3629.58 3640.50 SPEAKER_00 GitHub Actions это платформа для CI/CD, она позволяет вам запускать такие обычные рутинные вещи для каждого проекта, как сборка, тестирование и развертывание.
3640.50 3648.58 SPEAKER_00 Далее есть такое понятие как Workflow, это как раз-таки настраиваемый автоматический процесс, который умеет запускать джабы.
3648.58 3654.02 SPEAKER_00 Об этом вернемся чуть попозже, а прежде всего мы узнаем, кто их запускает, то есть какое событие их запускает.
3654.02 3655.70 SPEAKER_00 У нас есть такое понятие как Event.
3655.70 3665.38 SPEAKER_00 Event это как раз-таки специальная активность, которая происходит внутри репозитория, которая триггерит, запускает Workflow, и в свою очередь запускает джабы.
3665.38 3677.94 SPEAKER_00 Внутри репозитория что у нас может быть, например, кто-то запушил новое изменение, кто-то создал новый pull request, кто-то создал новый issue даже, на все на это может поджечь триггер, который запустит соответствующий Workflow.
3677.94 3682.30 SPEAKER_00 Как я уже сказал, Workflow для исполнения запускает джабы.
3682.30 3690.30 SPEAKER_00 Джабы это набор шагов, которые будут выполняться на одном раннере, то есть они будут выполняться не параллельно, они будут на одном раннере выполняться последовательно.
3690.30 3705.06 SPEAKER_00 Если вы хотите, чтобы с вашим основным процессом, то есть с вашим основным джабом выполнялись какие-то другие вещи, сканирование кода вполне может, сканирование кода на какие-нибудь security-извимости вполне может идти параллельно с тем, когда вы код билдите и тестируете.
3705.06 3713.68 SPEAKER_00 Это можно сделать двумя джабами, и они будут запускаться параллельно, и друг другу мешать не будут, а билд у вас в общее время будет соответственно намного меньше.
3713.68 3716.66 SPEAKER_00 Дальше есть такое понятие как Actions.
3716.66 3728.42 SPEAKER_00 Actions это специально написанные маленькие приложенницы, которые как раз таки выполняют непосредственно различную работу с различными аспектами.
3728.42 3733.98 SPEAKER_00 Эти приложения, они обычно сложные, но очень часто переиспользуемые.
3733.98 3742.18 SPEAKER_00 Такие как, например, запустить команду, или скачать репозиторий, или пропатчить определенный файлик.
3742.18 3746.62 SPEAKER_00 То есть обычные такие команды, они выполнены, каждая эта команда в виде отдельного приложения.
3746.62 3751.26 SPEAKER_00 И такие приложения называются Actions, что довольно удобно об этом мы посмотрим попозже.
3751.26 3754.54 SPEAKER_00 И еще одно понятие, которое вам пригодится это Runner.
3754.54 3764.26 SPEAKER_00 То есть это непосредственно тот сервер, который запускает ваш workflow в результате, когда триггернуло какое-то событие.
3764.26 3767.74 SPEAKER_00 Теперь давайте разберемся, что же внутри находится этого GitHub workflow.
3767.74 3771.22 SPEAKER_00 Как я уже сказал, workflow это всего лишь навсего ямл файлик.
3771.22 3774.46 SPEAKER_00 И в этом одном единственном ямл файлике описано абсолютно все, что вам нужно.
3774.46 3784.10 SPEAKER_00 Поэтому вы можете пойти, найти в GitHub этот файл, просто визуально его открыть, посмотреть и вытащить оттуда какие-нибудь интересные подходы, интересные хаки.
3784.10 3785.10 SPEAKER_00 Все в одном месте.
3785.10 3787.42 SPEAKER_00 Этот файлик обычно не такой уж и большой.
3787.42 3790.74 SPEAKER_00 Для примитивных проектов он можно в десяток строк вложить.
3790.74 3796.90 SPEAKER_00 Для каких-то более больших, более богатых там уже естественно комментарии, ветвления, параллельности.
3796.90 3799.34 SPEAKER_00 Но до этого нам еще дожить надо.
3799.34 3801.34 SPEAKER_00 Итак, в каждом workflow прежде всего есть имя.
3801.34 3806.34 SPEAKER_00 Это имя будет отображаться в интерфейсе GitHub, когда pipeline будет запускаться.
3806.34 3814.58 SPEAKER_00 У него есть набор триггеров, по которым этот workflow будет триггериться в зависимости от какого-то ивента или от какого-то другого события.
3814.58 3817.10 SPEAKER_00 В общем все это описывается в этом же файле.
3817.10 3825.58 SPEAKER_00 Для того чтобы workflow работал вам нужно указать хотя бы один триггер, иначе его некому будет запускать, никакое событие не произойдет и он никогда не будет работать.
3825.58 3827.86 SPEAKER_00 Очень полезным бывает атрибут ignore.
3827.86 3835.78 SPEAKER_00 Это секция ignore, которая вам рассказывает, что workflow нужно запускать не всегда, а только на определенный шаблон каких-нибудь файликов.
3835.78 3850.70 SPEAKER_00 Допустим, если мы исправляем ошибку в файле readme, то есть в текстном описании нашего проекта, и коммитим такой коммит в нашей репозитории, то естественно не надо запускать никакой билд, то есть не надо запускать workflow, который перезапустит опять наши тесты, начнет это все гонять.
3850.70 3857.58 SPEAKER_00 Мы понимаем, что файл readme никак на наши тесты не повлияет, скорее всего статус останется таким же, каким он был до этого.
3857.58 3870.58 SPEAKER_00 Мы можем задавать какие-то перемены в этом ямле, то есть использовать его более-менее как полноценный более-менее язык, переменные в одном месте объявлять, в одном месте менять, а дальше уже в течение всей жизни в коде его как-то использовать.
3870.58 3874.82 SPEAKER_00 У нас есть список джебов, есть хороший параметр, называется стратегия.
3874.82 3877.02 SPEAKER_00 Стратегия обычно задает матрицу операционных систем.
3877.02 3888.22 SPEAKER_00 Как вы сейчас знаете, дотнет у нас кросс-платформенный, поэтому вы можете написать матрицу операционных систем, на которой вы хотите тестировать ваш код, указать там допустим Ubuntu, Windows и macOS.
3888.22 3898.54 SPEAKER_00 И в результате этого у вас запустится уже не один джоб, а целых три джоба на различных операционных системах и в каждом из джобов будут выполнены определенные шаги.
3898.54 3903.26 SPEAKER_00 Вот давайте как раз таки разберемся, какие например шаги выполняет стандартный дотнет разработчик.
3903.26 3913.90 SPEAKER_00 Прежде всего первым шагом он делает чек-аут, то есть мы забираем из гитхаба тот репозиторий или ту ветку или тот коммит, который мы сейчас хотим протестировать.
3913.90 3929.54 SPEAKER_00 Дальше мы можем настроить переменные окружения дотнета, например выставить версию дотнета, с которой мы будем билдиться, выбрать версию SDK, с которой мы будем билдиться и запускать соответственно тесты.
3929.54 3945.10 SPEAKER_00 Следующим шагом у нас идет обычно рестор пакетов, это запуск стандартной команды dotnet restore, дальше билд, это команда dotnet build и обычно тест, это команда dotnet test, как несложно догадаться, вот из таких там простых шагов и складывается минимальный pipeline.
3945.10 3951.62 SPEAKER_00 И в результате этого весь ваш код будет обязательно собирабельный, тестируемый и ресторабельный.
3951.62 3968.18 SPEAKER_00 Можно добавлять больше, например можно собирать артефакты, NuGet пакеты допустим, Docker images, и отсюда же можно их прям пушить, какой-нибудь NuGet.org или в Docker Hub или куда-то еще в ваш приватный репозиторий, если вам это вдруг нужно.
3968.18 3980.62 SPEAKER_00 Также можно запускать различные уязвимости, сканирование на security уязвимости и анализировать ваш код, насколько там соответствует параметрам различным, которые у вас там приняты.
3980.62 3988.38 SPEAKER_00 Естественно можно запускать не просто security уязвимости, а просто проверку качества кода или проверку стиля, который принят в вашей команде.
3988.38 3996.86 SPEAKER_00 Вот все вот эти проверочки, они тоже сделаны в виде отдельных экшенов, они уже есть, они уже стандартные, все подхватываются, вам нужно добавить просто-напросто одну строчку.
3996.86 4013.82 SPEAKER_00 Ну и естественно разворачивать приложение тоже можно, если у вас площадка, на которой вы хотите развернуть доступно из агентов GitHub, то есть это какое-нибудь стандартное публичное облако, Azure, Yandex, еще что-нибудь в общем, туда тоже можно прямо из GitHub запольнуть ваше свеженькое приложение и оно уже попадет непосредственно на площадку.
4013.82 4022.98 SPEAKER_00 Еще один аспект, о котором часто забывают, а зря, это кэширование, потому что наше дотант приложение очень сильно зависит от различных референсов.
4022.98 4026.54 SPEAKER_00 Таких референсов, ну, get-пакетов, ну, get-референсов, их может быть очень много.
4026.54 4041.30 SPEAKER_00 И у GitHub Actions есть специальная оптимизация, которая позволяет вам указать там папочки, которые будут кэшироваться и указать там маски, к которым файлам нужно кэшировать специальный ключ, когда сбрасывать кэш.
4041.30 4057.02 SPEAKER_00 В общем, там много настроечек, но самый главный смысл, что обычно так случается, что большую часть всего пайплайна занимает именно .NET Restore, потому что пойти там куда-нибудь в интернет и оттуда скачать там 100 тысяч миллионов зависимостей, это довольно долго.
4057.02 4060.82 SPEAKER_00 Это часто бывает дольше, чем забилдить, даже протестировать приложение.
4060.82 4067.66 SPEAKER_00 И вот, если у вас такая ситуация, то как раз кэширование много пакетов – это ваше спасение.
4067.66 4075.46 SPEAKER_00 Один из самых крутых фич, которые вам дает GitHub Actions – это проверка вашего workflow.
4075.46 4090.94 SPEAKER_00 То есть вы можете задать специальные условия, которые проверят статус текущего commit, текущей ветки, которая к вам, например, приходит в виде pull-request, и завалить определенно билд, если вам это нужно, или наоборот, не завалить, а пропустить билд.
4090.94 4106.34 SPEAKER_00 Ну, например, вы можете сконфигурировать, что если ваш pull-request не компилируется, то, естественно, вы не хотите видеть его в мастере, и вы можете такую настройку сделать в workflow, что если данный pull-request не компилируется, то запретить merge в мастер.
4106.34 4108.46 SPEAKER_00 И дальше вы можете наворачивать.
4108.46 4114.82 SPEAKER_00 Соответственно, он должен не только компилироваться, но и проходить, например, style-гайды, должен проходить там качество кода, должен выдавать какой-то артефакт.
4114.82 4119.18 SPEAKER_00 И вообще абсолютно все, что в вашу фантазию может прийти, можно здесь проверить.
4119.18 4129.94 SPEAKER_00 И вот такие вот проверки, вот такие вот quality-гейты, то есть какие-то ворота, которые гарантируют определенное качество в мастере, вы можете строить на основании вот этих GitHub-экшенсов.
4129.94 4139.30 SPEAKER_00 Также существует огромное количество там сторонних экшенов, которые может написать абсолютно каждый разработчик.
4139.30 4144.78 SPEAKER_00 И есть .NET Developer Community, которая поставляет GitHub-экшенсы для .NET.
4144.78 4147.50 SPEAKER_00 И там полно всякого интересного.
4147.50 4159.94 SPEAKER_00 Например, можно взять экшенс, который генерирует вам классные отчеты, показывает покрытие кода, который генерирует классные бейджи, то есть картинки, с помощью которых вы можете нарядить ваш репозиторий.
4159.94 4172.10 SPEAKER_00 В общем, там уйма веселья, уйма всего интересного, но прежде всего, конечно, нужно научиться настраивать экшены вашим конкретным репозиториям под те минимальные шаги, которые обеспечат вам хотя бы тестируемый и валидный мастер.
4172.10 4176.34 SPEAKER_00 А уже все остальное там для вас откроется дальше, там уже много всего интересного.
4176.34 4180.26 SPEAKER_02 Да, технология хорошая.
4180.26 4182.94 SPEAKER_02 Я ее немножечко использовал, на самом деле.
4182.94 4196.98 SPEAKER_02 Ну, на работе мы в GitHub не живем, у меня на GitHub C# практически нет, но когда я куда-то контрабидил в другие проекты, то да, было пару мест, где нужно было поправить GitHub-экшенс, workflow описание, и это было прямо очень приятно.
4196.98 4207.86 SPEAKER_00 Ну, я думаю, на любой работе, естественно, на твоей тоже обязательно будет какой-нибудь CI/CD, и это уже как бы стандарт любой разработки.
4207.86 4215.62 SPEAKER_00 Поэтому то, что у нас open-source проекты некоторые не имеют встроенного CI/CD, это вот грустно, даже не проекты, а репозиторий.
4215.62 4221.58 SPEAKER_00 Хотелось бы, чтобы там тоже это было как бы стандарт, сделать его просто, он бесплатный, поэтому почему бы просто
4221.58 4230.34 SPEAKER_02 не сделать. Давай пойдем дальше, поговорим про CI/CD, но уже немножко другой, ну, то есть не совсем про CI/CD, но тоже про сборку и про код.
4230.34 4235.42 SPEAKER_02 Заанонсили штуку под названием .NET Virtual Monolithic Repository.
4235.42 4241.30 SPEAKER_02 Ну, как заанонсили, анонсмент появился, но там есть куча дисклеймеров, давайте разбираться.
4241.30 4246.86 SPEAKER_00 Слушай, ну звучит прям солидно, да, такой виртуальный монолитик репозиторий, прям очень интересно.
4246.86 4267.86 SPEAKER_02 Да, смысл в том, что если сейчас вы хотите собрать полностью .NET, вот получить, условно говоря, инсталлер .NET SDK или рантайма целиком, то вам нужно это сделать из кучи разных отдельных репозиторий, там у нас как раз рантайм отдельно, спиноткор отдельно, EF отдельно, то отдельно, все отдельно, инсталлеры вообще черти где живут.
4267.86 4272.50 SPEAKER_02 То есть, короче, очень сложный процесс, который в состоянии сделать только Microsoft.
4272.50 4277.26 SPEAKER_02 Сейчас сделали новые репозитории под названием внезапно .NET/.NET.
4277.26 4282.82 SPEAKER_02 Вот, он тоже в организации .NET и репозитории называется .NET.
4282.82 4300.18 SPEAKER_02 Это виртуальный монолитик, монолитный, то есть репозиторий, который включает в себя весь код, который необходим для того, чтобы собрать себе .NET SDK плюс систему под названием Source Build, это та штука, которая, собственно, используется для сборки .NET SDK.
4300.18 4317.94 SPEAKER_02 Причина, ну не причина, одна из целей, которая достигалась, это то, что у нас теперь есть один коммит, то есть как только вы туда, вы можете собрать точнее .NET и ваша сборка будет полностью идентифицироваться одним единственным коммитом.
4317.94 4321.30 SPEAKER_02 Понятное дело, поскольку это один-единый репозиторий.
4321.30 4330.26 SPEAKER_02 Это виртуальные репозитории, это зеркало, куда регулярно синхронизируются изменения из всех оригинальных репозиториев.
4330.26 4339.38 SPEAKER_02 То есть это не сабмодули, это не что-либо другое, это просто нормальные репозитории, куда регулярно коммитятся чинджи автоматически из других репозиториев.
4339.38 4345.78 SPEAKER_02 И эта штука все еще экспериментал, то есть это пока эксперимент, посмотреть, как оно будет жить.
4345.78 4355.42 SPEAKER_02 Майкрософт ожидает, что она станет более-менее нормальной постоянной штукой примерно к моменту первой превьюшки 8-го .NET, которая запланирована на февраль 23-го года.
4355.42 4357.66 SPEAKER_01 Они подразумевают из нее собирать все время или
4357.66 4359.26 SPEAKER_00 зачем она им практически нужна?
4359.26 4362.22 SPEAKER_02 Вот. Значит, цели этой штуки следующие.
4362.22 4371.94 SPEAKER_02 Во-первых, иметь возможность, собственно, иметь весь код в одном репозитории, и чтобы вы могли идентифицировать единым коммитом это все.
4371.94 4377.82 SPEAKER_02 Второе, они собираются релизить и собирать SDK для восьмерки оттуда, в том числе.
4377.82 4389.54 SPEAKER_02 Третье, сейчас очень сложно протестировать, например, если вы пишете какую-то фичу, которая зависит, например, одновременно и от рантайма, и от какого-нибудь там, не знаю, BCL.
4389.54 4395.62 SPEAKER_02 Это лежит, ну, рантайм с BCL лежат в одной репо, поэтому тут как раз более-менее нормально.
4395.62 4401.34 SPEAKER_02 А вот если вам нужно какое-нибудь изменение там в BCL и в SP над Core вместе протестировать, то это сложнее.
4401.34 4409.42 SPEAKER_02 Нужно собирать сначала BCL, потом использовать этот BCL, собирать SP над Core, ну, то есть там прям, это очень непросто, особенно для внешних контрибьюторов.
4409.42 4413.14 SPEAKER_02 Ну и для внутренних тоже, сути по всему.
4413.14 4435.46 SPEAKER_02 И цель как раз-таки, что в таком репозитории вы можете создать, это, конечно, виртуальный репозиторий, но никто не мешает вам, например, создать в нем бранч, что-нибудь погонять, потестировать, поменять одновременно там и рантайм, и BCL, и SP, и что угодно еще, собрать из этого SDK, попробовать что-нибудь погонять, попроверять, а потом аккуратненько все свои чинжи уже спортировать в оригинальной репозитории, чтобы нормально закоммитить.
4435.46 4471.58 SPEAKER_02 И третье, эээ, третье, четвертое, цель это удовлетворить требованиям ребят под названием Red Hat Economical, например, это Ubuntu, которые, как мы помним, нативно теперь собирают себе дотнеты в свои нативные пакеты, а по требованиям open-source должен быть способ собрать эту самую штуку из единого репозитория, грубо говоря, ну то есть скачать репозиторий, сказать, грубо говоря, git clone, да, build, и у тебя собрался дополнительный дотнет, готовый пакет, или для там Red Hat, например.
4471.58 4473.14 SPEAKER_02 Как реализован SYNC?
4473.14 4506.70 SPEAKER_02 Значит, они думали сделать сабмодули, решили, что не надо, почитав отзывы в интернете, дальше они хотели сделать сабтри, это такая прям очень, как я понимаю, advanced технология, когда ты в git-репозиториях, по сути, коллекция деревьев внутри, в внутреннем представлении, ты технически можешь на самом деле хранить несколько деревьев, не связанных друг с другом, и потом их вмерживать вместе в единый комит, но там были трудности с тулингом вокруг этого, git немножко криво это поддерживает, и, короче, решили, что не будем.
4506.70 4569.94 SPEAKER_02 Поэтому в итоге они пришли к выводу, что мы просто напишем custom.sync решение, которое просто аккуратненько, по-моему, сейчас настроено раз в три часа, идет во все значит репозитории, их там двадцать восемь, да, двадцать шесть штук, то есть дотнет у нас сейчас состоит из двадцати шести разных репозиториев, то есть это решение, программка она идет в двадцать шесть репозиториев, раз в три часа, делает там аккуратно git-create-patch, и потом этот патч, аккуратно делает git-apply-patch на этот репозиторий, они еще этим добиваются крутой штуки, им нужно уметь исключательно исключать некоторые файлы, то есть, например, там есть какие-нибудь, не знаю, огромные бинарники для каких-то очень специфических тестов, там, или performance каких-нибудь, или еще чего-нибудь, которые они не хотят видеть в этом едином большом репозитории, они аккуратно исключают, потому что всякие моменты типа там, submodule, subrep, вот это все, оно бы все вытащило целиком, а так они имеют возможность что-то исключить.
4569.94 4580.98 SPEAKER_02 Вот, сейчас это все поддерживает только восьмой дотнет и выше, и вряд ли это будет поддерживать более раннее, понятное дело, потому что начали делать это только сейчас.
4580.98 4593.22 SPEAKER_02 Полностью билд из сурсов доступен сейчас только на линуксе, потому что первичная цель это видимо была, чтобы Red Hat и Canonical, им было полегче собирать свои версии дотнета.
4593.22 4599.58 SPEAKER_02 Мак и Windows будут готовы только к девятому дотнету, пока ждать не стоит, сейчас пока там все завязано на линуксе.
4599.58 4611.50 SPEAKER_02 И на данный момент пока еще нельзя сделать полностью оффлайновый билд, то есть там сейчас реквизит для того, как все это собрать, оно уже там сейчас есть, выглядит довольно забавно.
4611.50 4615.14 SPEAKER_02 Шаг первый, как ты думаешь, какой, что тебе нужно, чтобы собрать дотнет?
4615.14 4618.18 SPEAKER_01 Ну, наверное, выкачать репозиторий, запустить дотнот билд.
4618.18 4621.10 SPEAKER_02 Ага, сейчас, первым шагом поставить дотнот SDK, вот
4621.10 4623.10 SPEAKER_01 так вот, понимаешь? Ну, да, неплохо.
4623.10 4628.30 SPEAKER_02 Да, то есть типа вот для того, чтобы собрать SDK из сурсов, тебе нужно поставить другой дотнот SDK, ну типа
4628.30 4631.22 SPEAKER_01 это облегчит жизнь канонику, я чувствую.
4631.22 4644.30 SPEAKER_02 Да, ну у них есть цель все это сделать полностью оффлайн, он там еще за какими-то Nuget пакетами пойдет, на самом деле, во время билда, и там это сказано явно, что типа сейчас мы не оффлайн, мы пойдем в интернет за Nuget, но над этим всем они работают, чтобы было полностью оффлайн.
4644.30 4646.22 SPEAKER_00 Как они сделают Nuget пакет оффлайн?
4646.22 4649.94 SPEAKER_00 Не знаю, я не знаю пока, не знаю, будем следить.
4649.94 4650.94 SPEAKER_02 Хорошо, будем посмотреть.
4650.94 4667.06 SPEAKER_02 Вот, именно поэтому, видимо, они говорят, что это все экспериментал, то есть у них прям большими буквами написано, что типа мы в принципе можем решить, что нафиг не нужно и дропнуть, ну в смысле в таком виде, да, не взлетело, и дропнуть вообще весь репозиторий, так что вы там типа на него пока не завязываете сильно, пока все очень экспериментал.
4667.06 4682.98 SPEAKER_02 Но как-то так, так что возможно, возможно, к, не знаю, к релизу девятки, а восьмерки у нас, да, следующий релиз, к релизу восьмерки, соответственно, через год у нас будет возможность собрать свою собственную SDK, но пока на Linux только, а там, глядишь, через пару лет и до Mac с винтой доберемся.
4682.98 4713.38 SPEAKER_00 Не знаю, слушай, выглядит это как какой-то позор, я вот, почитав их цели, я надеялся, что они как раз такие сделают, там, Sub3, SubRep, SubModule, что-нибудь там виртуально изобретут, потому что знаешь, прикольно, вот все большие гиганты там, всякие Facebook, Яндекс, Google, они как раз делают Monorep у себя, а потом для того, чтобы решить все проблемы Monorep, они изобретают собственный инструментарий, который позволяет из этой Monorep кусочки выдёргивать, как бы их изменения туда какие-то делать и обратно потом в Monorep эти кусочки заливать, но так, чтобы они не сломали всю Monorep там.
4713.38 4714.38 SPEAKER_00 Ну правильно.
4714.38 4715.38 SPEAKER_00 Чем такие извращения делают.
4715.38 4717.78 SPEAKER_00 Да, Microsoft такое же делал для своих, для гита.
4717.78 4722.74 SPEAKER_00 Да, у Microsoft же такая же система есть, было бы прекрасно, если бы Microsoft как раз-таки с другой стороны подошёл.
4722.74 4745.62 SPEAKER_00 Вот у нас есть много маленьких репозиториев, а мы сделаем вот такую виртуальную штуку, которая их соединяет в Monorep, а то если они разрабатываются как отдельные репозитории со всеми их плюсами, и если тебе вдруг почему-то надо, вот забери их в отдельную Monorep, и безусловно, как бы вторым плюсом от этого всего было бы обратная картинка, ты можешь в этой Monorep всё поменять, и он должен разлететься по своим репозиториям, все эти изменения.
4745.62 4752.34 SPEAKER_00 Не важно, там в pull-request, ещё каким-то образом, ну то есть тогда бы это вообще геймчейджер был, то есть это какой-то новый подход на рынке.
4752.34 4756.42 SPEAKER_00 А так они нажали F5, как бы в фаре скопировали все дифы, и всё.
4756.42 4759.74 SPEAKER_00 Ну что это такое, я в 90-х этим занимался.
4759.74 4762.42 SPEAKER_02 Ну вот они только сейчас к этому пришли.
4762.42 4763.42 SPEAKER_00 Тормозят.
4763.42 4768.06 SPEAKER_00 Это не уровень технологической компании мирового уровня, ну что это такое.
4768.06 4770.86 SPEAKER_02 Посмотрим, может что новое придумают, ты будешь доволен.
4770.86 4772.82 SPEAKER_02 Но пока ты не доволен, я понял.
4772.82 4773.82 SPEAKER_01 Пойдём дальше.
4773.82 4776.26 SPEAKER_00 Да, будем надеяться, что их эксперименты будут поудачнее.
4776.26 4784.02 SPEAKER_00 Вот кстати, насчёт неудачных экспериментов, ты знал, что Nuget, он как бы не очень удачный эксперимент, несмотря на то, что им как бы пользуются все.
4784.02 4786.02 SPEAKER_00 Да нет, норм эксперимент, нормально.
4786.02 4795.94 SPEAKER_00 Да ладно, вот я нашёл автора, который, ну автор инструмента, который называется Nugetizer, и он вот говорит, что реально у Nuget есть проблемы.
4795.94 4799.22 SPEAKER_02 Проблемы, наверное, есть много где, ну давай.
4799.22 4801.34 SPEAKER_02 Ну погоди, ну автора нет.
4801.34 4802.94 SPEAKER_00 А, окей, давай.
4802.94 4804.74 SPEAKER_00 Вот, короче, инструментик.
4804.74 4807.42 SPEAKER_00 Как я уже сказал, Nugetizer.
4807.42 4813.34 SPEAKER_00 Это простой, гибкий, интуитивно понятный и очень мощный Nuget упаковщик.
4813.34 4818.06 SPEAKER_00 Хороший слово, пакетчинг, упаковщик, пусть будет упаковщик.
4818.06 4827.34 SPEAKER_00 И этот упаковщик был призван для того, чтобы устранить все минусы Nuget, которые у него накопились, т.е.
4827.34 4834.82 SPEAKER_00 он такой взглянул на Nuget формат под новым углом, взглянул на то, что он умеет и решил переделать всё правильно и по-своему.
4834.82 4853.58 SPEAKER_00 В общем, как я уже сказал, стандартный, стандартный вот этот SDK, у него есть встроенная поддержка упаковки, т.е. сборка бинарников различных в какой-то определенном формате и запаковка их в Nuget пакет.
4853.58 4877.62 SPEAKER_00 Но, как говорит автор, что дизайн того, как команды у Nuget работают, т.е. даже не команды, а описание самого пакета, т.е. это команды, которые в msbuild в props файлах у нас вписаны, т.е. как вот эти сами таргеты работают, как у них пропертии работают, как эти айтемы комбайнятся, сделано абсолютно неконсистентно и нелогично.
4877.62 4890.90 SPEAKER_00 Там плохие дефолты, часто различные команды противоречат синтаксис у друг друга, в общем, и это видно, что инструмент развивался многие-многие годы и подошел, т.е. в результате получилось большое такое неконсистентное месиво.
4890.90 4916.82 SPEAKER_00 И когда вы начинаете не просто собирать там какой-то маленький пакетик из одной сборочки, из вашего одного проектика, там все хорошо, а когда вы начинаете собирать какие-то сложные пакеты, когда у вас много проектов, из них вылетает много сборок и в зависимости от различных условий вам нужно насобирать такой пакет под различные платформы с различными файликами под каждую платформу с различными версиями.
4916.82 4922.98 SPEAKER_00 В общем, это все становится очень-очень сложно и самое главное непредсказуемо.
4922.98 4932.74 SPEAKER_00 Т.е. что там получится в результате, а главное, что получится после того, как выйдет новая версия или когда кто-то поменяет там один флажочек, это становится абсолютно непредсказуемо.
4932.74 4942.38 SPEAKER_00 В общем, это все автора абсолютно не устраивало, поэтому он написал свой инструмент, который позволяет вам это все дело паковать по-своему.
4942.38 4953.42 SPEAKER_00 Для того, чтобы использовать Nugetizer вы должны прописать в css-прош файли специальную директиву, которая рассказывает, какие прош-файлы нужно упаковать, какие нет.
4953.42 4971.78 SPEAKER_00 Так же, как и у обычного Nuget, у него есть стандартные какие-то атрибуты, стандартные элементы, которые, например, могут добавить контекст в destination пакет, но делают они это намного умнее, у него есть шаблоны, которые раскрываются поумнее, у него есть дефолты, которые более предсказуемы.
4971.78 4982.42 SPEAKER_00 Например, если вы захотите засунуть сюда в пакет всю папочку, он вам засунет всю папочку, без всяких там магических звездочек и решеточек, которые вам нужно в стандартном Nuget пакере использовать.
4982.42 4997.86 SPEAKER_00 Интересная команда в том, что можно указать директиву пакет-шаппл-патх, и он все пакеты, которые соберет из всех проектов, неважно где они на какой глубине настроены, он их соберет и сложит в отдельную директорию, там где вы укажете.
4997.86 5008.86 SPEAKER_00 В общем, возможности все такие же точно, но детализация как раз заключается в удобстве, в понятных дефолтах, в более умном поведении и прочем.
5008.86 5018.62 SPEAKER_00 На примере Redmi покажу, вот каждый знает, что есть обычно у проектов Redmi файл, в котором описаны основные способы работы с проектом.
5018.62 5024.42 SPEAKER_00 И также недавно Nuget добавил возможность запихивания Redmi как раз в пакет.
5024.42 5026.74 SPEAKER_00 Мы об этом тоже говорили в каком-то выпуске.
5026.74 5043.98 SPEAKER_00 То есть для того, чтобы пользователь мог искать ваш пакет, например, в Visual Studio или в Rider, и когда он найдет пакет, щелкнул на него, у него в этот момент показывается Redmi, в который красиво с форматированием, может быть даже с картинками, с графиками рассказывается про вашу прекрасную библиотеку.
5043.98 5050.10 SPEAKER_00 Вот такие Redmi тоже сейчас добавляют в пакеты.
5050.10 5058.82 SPEAKER_00 И обычно тот Redmi файл, который лежит у вас в GitHub репозитории, он не очень соответствует тому Redmi файлу, который вам хотелось бы видеть в этом пакете.
5058.82 5065.70 SPEAKER_00 Например, в репозитории обычно сначала находятся секции о том, как склонировать репозиторий, как его сбилдить.
5065.70 5073.06 SPEAKER_00 В конце там находится какое-нибудь "Спасибо нашим контрибьюторам" или "Как законтрибьютировать наоборот в этот гид репозитории".
5073.06 5085.06 SPEAKER_00 Когда мы читаем Redmi про Nougat пакет, естественно там не должно быть никакой фразы о том, как склонировать репозиторий или как законтрибьютировать в репозитории, потому что мы находимся в контексте Nougat пакета, нет там никакого репозитория.
5085.06 5098.82 SPEAKER_00 И вот чтобы победить такую некрасивость, Nougatizer поддерживает query к MD файлам, который позволяет достать определенную секцию.
5098.82 5107.14 SPEAKER_00 Например, вы можете сказать "Дай мне Redmi файл", секцию только "Usage", секция это то, что с таким заголовком идет.
5107.14 5120.06 SPEAKER_00 А потом добавим в конце из документов футер для моего пакета, и тогда он добавит какую-то определенную часть, которая будет только в пакете, но не будет в Redmi на очередном гидхаб репозитории.
5120.06 5124.70 SPEAKER_00 В общем, вот такие действия может творить и при этом придавать красивость.
5124.70 5137.02 SPEAKER_00 Как я, наверное, не сказал, Nougatizer распространяется с помощью Global Tools, это позволяет ему легко и быстро кроссплатформенно вписаться в любой ваш проект.
5137.02 5142.38 SPEAKER_00 Его нужно запускать из Project Directory.
5142.38 5152.66 SPEAKER_00 Интересный момент, что если его просто запустить без всяких параметров, он выдаст вам быстрый отчет того, какие пакеты он сделает из этого репозитория, то есть какие пакеты будут сгидлены.
5152.66 5166.40 SPEAKER_00 Он вам удобно покажет там файлы, всю структуру, версию, какую DLL он куда положит, по какому пути, в какой платформе она будет, по каким папочкам он это все разложит.
5166.40 5168.18 SPEAKER_00 И это все будет показано очень быстро.
5168.18 5180.34 SPEAKER_00 Там специально есть оптимизация, которая использует не настоящую компиляцию для того, чтобы понять все эти зависимости, а специальную IDE, Debug Time, по-моему, или Debug Time компиляция, вот как-то так называется.
5180.34 5187.18 SPEAKER_00 То есть это специальный хак, специальная компиляция для IDE, которая используется для того, чтобы быстрее в верхнем уровне понять, что происходит.
5187.18 5198.14 SPEAKER_00 В общем, этот луза тоже это делает для того, чтобы мгновенно выдать вам вот такой красивый большой полноценный отчет с предсказуемым набором пакетов и с предсказуемой структурой, которая у вас там будет в результате.
5198.14 5209.18 SPEAKER_00 В общем, если вы страдаете от того, что у вас очень сложный проект, который упаковывается в очень сложные пакеты, то можно посмотреть на этот инструмент, кажется, что он вам может хорошо помочь.
5209.18 5226.74 SPEAKER_00 Я же, наверное, в своих проектах обычно стараюсь такого не делать, хотя у меня есть очень сложные Get пакеты, но как-то я обходился стандартным форматом, собирал их с помощью специального Nuspec файла, и тоже вроде как так было все хорошо, не вижу причин не меняться.
5226.74 5242.22 SPEAKER_02 Я более того скажу, я, по-моему, ни разу не пользовался возможностью сборки из Cessproj на прямую, я всегда писал Nuspec отдельный, где ты четенько можешь указать прям конкретный список файлов, конкретный там, что куда положить, какой редми взять и вот это все.
5242.22 5244.22 SPEAKER_00 Ну это ты просто старпер же.
5244.22 5245.22 SPEAKER_00 Спасибо.
5245.22 5248.30 SPEAKER_01 Когда появился новый, не знаю, обращайтесь, это
5248.30 5254.74 SPEAKER_00 же когда появился новый SDK формат, то как бы все стали собирать именно из Proj файлов для того, чтобы как раз вот эти Nuspec никому не были нужны.
5254.74 5257.82 SPEAKER_00 Ну это работает, естественно, только когда тебе нужно один к одному.
5257.82 5269.18 SPEAKER_00 Как только ты хочешь из нескольких проектов собрать один пакет, то там мы возвращаемся к нашему Nuspec, и я рад, что они были не забросили, не деприкетили, а до сих пор поддерживают, и это прекрасная мощная штука, которая часто выручает.
5269.18 5276.70 SPEAKER_02 Ну и продолжим пользоваться по старинке, как и пользовались пока не отделят и не забудут.
5276.70 5279.58 SPEAKER_02 Давай дальше, пойдем к теме.
5279.58 5298.98 SPEAKER_02 Я на самом деле не планировал ее исходно включать в этот подкаст, но раз уж вышел райдер 2022.3, и буквально за пару дней, наверное, до записи подкаста или около того, то решил включить, потому что это все очень подходит под те темы, которые мы сегодня обсуждаем.
5298.98 5311.98 SPEAKER_02 Итак, новый райдер 2022.3, там вышло большое количество E-апов, и теперь у нас поддержан .NET 7, то есть если вы хотели попробовать новый SDK, то вот как раз таки ставьте 2022.3, там будет поддержка седьмого .NET.
5311.98 5317.82 SPEAKER_02 Поддержан VSL 2, туда можно заканчиваться для Remote Development прямо из райдера.
5317.82 5328.02 SPEAKER_02 Можно теперь, ну мы про это рассказывали, таскать Tool Window к окошкам, которые вы вытащили из основного окна.
5328.02 5329.58 SPEAKER_02 Ты, кстати, пробовал, это реально работает?
5329.58 5332.42 SPEAKER_02 Я не пробовал еще, я обновился, но я не попробовал еще.
5332.42 5334.18 SPEAKER_02 Блин, клевый фича.
5334.18 5335.18 SPEAKER_02 Надо будет попробовать.
5335.18 5345.66 SPEAKER_02 Но я на самом деле очень редко пользуюсь многомониторной конфигурацией для редактирования кода, у меня всегда райдер, ну то есть если я работаю, то это максимальный расширяющий рендер на основном экране и все.
5345.66 5347.38 SPEAKER_02 Я второй монитор не использую.
5347.38 5350.10 SPEAKER_00 Да-да, это, конечно, для нескольких мониторов.
5350.10 5355.46 SPEAKER_02 Вот, то есть я не умею программировать на двух мониторах, мне нужен один, и по центру.
5355.46 5358.94 SPEAKER_01 Для решения твоей проблемы три монитора.
5358.94 5360.94 SPEAKER_01 Я пробовал, отличная штука.
5360.94 5361.94 SPEAKER_02 Да, возможно, возможно.
5361.94 5366.50 SPEAKER_02 Вопрос, как их подключать, да, ну в общем, там возникают другие вопросы, куда их ставить на стол.
5366.50 5379.42 SPEAKER_02 Так, новый Toolbar, ну вообще новый, немножко такой UI-чик, про который говорили, может быть, вы слышали в других разных EDG'ках, теперь он есть в райдере, там более чистенький и так далее.
5379.42 5384.30 SPEAKER_02 Тоже еще, я буквально сегодня обновился, поэтому не пробовал еще полностью, но так выглядит приятно.
5384.30 5386.34 SPEAKER_02 Посмотрю, как будет в работе.
5386.34 5396.86 SPEAKER_02 Поддержаны всякие новые C# фичи, там UTF-8 литералы, файл local type, статик abstract member, rostering literals, ref field, scope, значит, ключевое слово, ну и так далее.
5396.86 5400.46 SPEAKER_02 В общем, все, что мы знаем про C# 11, должно быть поддержано.
5400.46 5415.26 SPEAKER_02 В Blazor, сервер APOC завезли hot reload, теперь можно делать, завезли NuGet Central Package Management, и появилось early preview для ARM64 под Windows и Linux.
5415.26 5422.62 SPEAKER_02 Кроме того, DotMemory, теперь который встроенный в райдере и встроенный в DotMemory, стал доступен на Linux и на Mac.
5422.62 5429.66 SPEAKER_02 Короче, ну, много всяких разного, улучшений, грубо говоря, по сути, там, 7 из DK, новый UI-чик и Performance.
5429.66 5432.54 SPEAKER_02 Значит, с Performance тема отдельная.
5432.54 5446.30 SPEAKER_02 У нас на самом деле была статья, которая была опубликована в блоге nDependa довольно давно, от автора, собственно, этого самого nDependa, про то, что, а давайте сравним Performance райдера и Visual Studio.
5446.30 5452.66 SPEAKER_02 Ну, типа, много кто живет в райдере, много кто живет в Visual Studio, много кто живет в Visual Studio и в ReSharper.
5452.66 5454.82 SPEAKER_02 Давайте поймем, кто быстрее, кто медленнее.
5454.82 5457.82 SPEAKER_01 Ну, всем же известно, что ReSharper тормозит, правильно?
5457.82 5459.98 SPEAKER_02 Да, ясное дело, ReSharper тормозит, но вопрос на сколько.
5459.98 5469.22 SPEAKER_02 И на момент публикации статьи студия была версии 17.24, райдер был версии 20.22.1.2.
5469.22 5478.82 SPEAKER_02 Все это тестировал товарищ на своем компе, это Xeon с 2.7 ГГц, с 64 ГГ памяти, так что кажется памяти должно хватать IDE.
5478.82 5483.10 SPEAKER_02 Ну, понятно, SSD, винтовая десятка, вот это все.
5483.10 5488.70 SPEAKER_02 Тестировал это на двух Solutions, на nDependa, собственно, 38 проектов, примерно, ну, почти 6000 файлов.
5488.70 5494.58 SPEAKER_02 И есть такой Knob Commerce проектик, это 28 проектов и 5300 файлов.
5494.58 5507.22 SPEAKER_02 Сначала он замерял, сколько проходит времени до момента, когда мы просто берем и запускаем райдер или Visual Studio, не открывая никаких Solutions.
5507.22 5512.46 SPEAKER_02 Соответственно, студия чистая занимает 4 секунды, студия с ReSharper 6 секунд, райдер 5 секунд.
5512.46 5519.14 SPEAKER_02 Ну, окей, разница вроде небольшая, нормально, сойдет.
5519.14 5543.26 SPEAKER_02 Дальше если мы открываем nDepend Solution, это надо напомнить, примерно 6000 файлов, 38 проектов, то у студии это занимает 17 секунд, студии с ReSharper это занимает 20-25, то есть он называется First Responsive и Fully Responsive, то есть хоть как-то с ним можно работать через 20 секунд, со студией, в смысле с ReSharper, а так полноценно работать уже через 25.
5543.26 5546.58 SPEAKER_02 Райдер же занимает 13, то есть быстрее, чем студия на 4 секунды.
5546.58 5549.78 SPEAKER_01 Это на холодную, да, то есть кэширование всегда включено?
5549.78 5558.10 SPEAKER_02 Я подожди, ну, он говорил, что технология замеров это типа я много-много-много раз открывал, ну и брал, там, выкидывал аутлайер и брал что-то средненькое.
5558.10 5561.78 SPEAKER_00 А, понятно, значит кэш уже был и он просто переездался.
5561.78 5573.98 SPEAKER_02 Да-да-да, то есть это не полностью абсолютно свежий, свежесклонированный Solution, который ты вообще в жизни никогда не видел, нет, это твоя обычная рабочая работа, то есть ты просто берешь Solution, с которой ты в среднем работаешь и его там открываешь.
5573.98 5583.22 SPEAKER_02 А билд не сильно отличается, там 22, 22,3, 23 секунды, в общем, на билд можно не смотреть.
5583.22 5589.46 SPEAKER_02 С Solution, но в Commerce там чиселки примерно похожие, Rider секунд на 5 быстрее.
5589.46 5612.26 SPEAKER_02 И общие выводы у него были следующие, что как бы в целом Rider выглядит более респонсив, и это понятно почему, потому что у него UI-чик отдельно, а ReSharper, да, в бэкэндах смысле, который, ReSharper отдельный, это отдельный процесс, который там где-то там в бэкграунде фигачит, анализирует все, а UI-чик становится доступным быстрее, несмотря на то, что это Java.
5612.26 5623.06 SPEAKER_02 А в студии, когда студия с ReSharper, ну ReSharper, он хоть и потихонечку выносится в бэкграунд, там все-таки довольно много всего все еще происходит в самой студии, ну в смысле в основном потоке, и поэтому медленнее.
5623.06 5634.22 SPEAKER_02 Его очень огорчает, в принципе, время старта пустого, пустой IDE, что студии, что Rider, то есть 4-5 секунд, это прям как бы долго.
5634.22 5635.98 SPEAKER_02 Что там запускаться?
5635.98 5641.54 SPEAKER_02 Ну так, было бы круто, если пустая студия или пустой Rider запускалась бы за секунду, это было бы норм.
5641.54 5644.26 SPEAKER_02 Сейчас он действительно довольно долго запускается.
5644.26 5662.66 SPEAKER_02 И его вывод в статье такой, что ну как бы да, Rider быстрее, поэтому если вы как бы, вам нужна скорость, пользуйтесь Rider, но если вам нужны старые фреймворки, да, там Rider до сих пор не поддерживает WinForms на DotNet Core, ну и всякие другие типа там WCF и прочее, если вы чем-то таким пользуетесь, ну наверное вам придется жить в студии.
5662.66 5673.02 SPEAKER_02 Это одна из причин, почему я сейчас много живу в студии, я сейчас много работаю с WinForms, а Rider их не очень умеет на DotNet Core, ну в смысле он их не умеет.
5673.02 5676.02 SPEAKER_02 Отдельный вопрос, зачем WinForms на DotNet Core, но вот так сложилось.
5676.02 5701.26 SPEAKER_02 Я взял и когда я готовился, я попробовал это дело на одном из Solutions, который у меня был под рукой, который я довольно регулярно открываю, это 24 CS Proj, а там примерно 5000 CS File Lake, студия у меня без ReSharper, ReSharper у меня в принципе не стоит, у меня получилось, что студия без ReSharper запускалась 13 секунд открывалась, Solution я проверял это до момента, когда я смогу сказать Ctrl+T и что-нибудь поискать.
5701.26 5705.70 SPEAKER_02 То есть студия заняла 13 секунд, у Rider это заняло 16 секунд.
5705.70 5708.66 SPEAKER_02 То есть у меня Rider открывался дольше.
5708.66 5709.66 SPEAKER_02 Неожиданно.
5709.66 5710.66 SPEAKER_02 Да.
5710.66 5718.06 SPEAKER_02 То есть, ну это студия без ReSharper, то есть вот у меня как-то так, может они кэши как-то более оптимально раскладывают, я не знаю.
5718.06 5723.02 SPEAKER_02 И вот как раз вышел 22.3, обновленный Rider, который быстрее.
5723.02 5724.50 SPEAKER_02 Что они там сделали?
5724.50 5730.18 SPEAKER_02 Они завязали побольше от CPU ядер для сканирования файликов при старте.
5730.18 5737.02 SPEAKER_02 Они автоматически при инсталляции теперь себя добавляют в исключение Windows Defender, если мало ли кто-то этого не делает, то очень рекомендуется.
5737.02 5739.26 SPEAKER_02 Прям, теперь они сами это делают.
5739.26 5743.54 SPEAKER_02 А лучше всю эту папочку с исходниками тоже туда добавьте, иначе будет тормозить.
5743.54 5758.62 SPEAKER_02 ReSharper в бэкэнде, который у них крутится, стал побыстрее за счет того, что, по сути ReSharper как работает у них, он грузит всякие модули, просто сканируя все папочки, ну все длфки-папочки в округе и пытаясь понять, что нужно подгрузить.
5758.62 5766.14 SPEAKER_02 Вот они теперь там анализируют кастомные свои атрибуты, точнее всю нужную методат, но они пихают в свои кастомные атрибуты, за счет чего это побыстрее работает.
5766.14 5769.54 SPEAKER_02 Ну пооптимизировали memory traffic.
5769.54 5775.74 SPEAKER_02 В ReSharper бэкэнде стали использовать серверный вариант ГЦ, от этого получше перформанс.
5775.74 5785.90 SPEAKER_02 И еще, мы не обсуждали в подкасте, может быть как-нибудь обсудим отдельно, что вышел уже флит для C#, от JetBrains.
5785.90 5793.46 SPEAKER_02 И для того, чтобы штука эта работала, им пришлось написать новый C# парсер, который вообще никак не связан с ReSharper.
5793.46 5812.34 SPEAKER_02 Он такой типа легковесный и все дела, и поэтому теперь райдер работает таким образом, что пока не пригрузился полноценный ReSharper на бэкэнде, у тебя есть уже какой-то работающий на фронте простенький C# парсер, ну простенький, но при этом он что-то умеет, поэтому у тебя есть ощущение, что можно работать раньше.
5812.34 5821.30 SPEAKER_02 И вот в моем тесте до момента, когда я могу сказать Ctrl+T, у меня появляется Solution Explorer, я могу сказать Ctrl+T, вместо 16 секунд стало 11 секунд.
5821.30 5824.06 SPEAKER_02 О, это же заметно, это хорошо.
5824.06 5833.82 SPEAKER_02 На новой версии, да, то есть тут у меня на конкретном одном Solution, на конкретном одном моем компе, в абсолютно не научном тесте, назовем это так, видна экономия в 5 секунд.
5833.82 5842.18 SPEAKER_02 Я не знаю, буду ли я видеть это в каждодневной работе, я довольно часто меняю Solution, запускаю райдер, закрываю райдер и так далее, посмотрим.
5842.18 5844.86 SPEAKER_02 Но кажется, что действительно перформанс там стал получше.
5844.86 5856.18 SPEAKER_00 Отлично, будем смотреть, как развивается, как друг друга перегоняет, может студия это тоже подстегнет, пересмотреть что-то в своих запусках и кэшированиях.
5856.18 5859.58 SPEAKER_02 Да, ну что, давай последнюю тему обсудим.
5859.58 5868.50 SPEAKER_00 Да, темка подслушана, я расскажу, что я такого интересного нашел за это время среди наших коллег.
5868.50 5872.18 SPEAKER_00 Прежде всего хотелось бы отметить подкаст «Подлодка.
5872.18 5875.70 SPEAKER_00 273 выпуск» про интересную тему «Оценки не нужны».
5875.70 5884.30 SPEAKER_00 Потому что я очень часто сталкиваюсь с людьми, которые считают, что почему-то оценки нужны и очень много менеджеров хотят странного, они хотят каких-то сроков.
5884.30 5892.86 SPEAKER_00 В общем, и этот выпуск интересен тем, что он эту тему обсуждает довольно многогранно и разбирает там частые кейсы.
5892.86 5904.70 SPEAKER_00 В общем, например, чем оценка отличается от прогноза, это тоже для многих будет откровением, что мы называем не теми словами, которые должны называть всю эту терминологию, можно ли просто работать, а не вот это вот все.
5904.70 5913.34 SPEAKER_00 А как делать там осознанную разработку или выдумывать против того, чтобы выдумывать цифры и натягивать какие-то оценки на какие-то мифические сроки.
5913.34 5922.78 SPEAKER_00 Еще интересное рассуждение, как цепочка оценка, синдром самозванца и стресс приводят людей к выгоранию.
5922.78 5931.22 SPEAKER_00 Тоже никогда не прослеживал такую вещь, но оказывается, вот те команды, у которых есть какая-то оценка, какие-то строки, они чаще выгорают.
5931.22 5933.50 SPEAKER_00 Что со всем этим делать?
5933.50 5942.74 SPEAKER_00 И на куче конкретных примеров рассказывается очень много практических кейсов, какие-то научные пытаются к этому выводы все подвести и так далее.
5942.74 5963.58 SPEAKER_00 В общем, если вас интересуют оценки или если вам нужно каким-то образом убедить ваших менеджеров, что оценки это не всегда хорошо и может быть конкретно в вашей ситуации, они совсем и не нужны, то есть попытаться хотя бы это сделать, попробуйте послушать подкасты, много интересных, есть аргументов, с помощью которых можно дальше пообщаться с вашим руководством.
5963.58 5968.10 SPEAKER_00 Далее подкаст «Проветримся», ведущий подкаст Иван Ямщиков.
5968.10 5978.38 SPEAKER_00 Я Ваню очень много слушаю, очень много смотрю, очень много люблю и в принципе везде, где мне встречается Иван Ямщиков, я пытаюсь все эти выступления посмотреть.
5978.38 5990.74 SPEAKER_00 Кто не знает, это исследователь в основном искусственного интеллекта, он работал в Яндексе, в Эбби, он доцент высшей школы экономики, у него там еще куча всяких регалий международных.
5990.74 5998.74 SPEAKER_00 В общем, это такой нормальный ученый, можно так сказать, и уже после этого популяризатор искусственного интеллекта.
5998.74 6019.70 SPEAKER_00 Он очень интересно рассказывает вообще любую техническую тему, что бы он не затронул, но в частности в этом подкасте к нему приходит огромное число различных людей, которые увлекаются теми или иными технологиями, и кстати не только технологиями, и он с ними разговаривает с кем-то в формате интервью, с кем-то в формате просто дружественной беседы, в зависимости от гостя.
6019.70 6024.38 SPEAKER_00 Темы выбираются всегда интересные, обычно это околотехнические какие-то темы тоже.
6024.38 6036.22 SPEAKER_00 В общем, Ваня чрезвычайно начитан, чрезвычайно интересно говорит, у него прекрасно воставленная речь, и тот человек, с которым безусловно всегда интересно и пообщаться, и послушать его подкасты.
6036.22 6041.58 SPEAKER_00 В качестве примера, что у него последний сезон, например, он записывал про медитацию.
6041.58 6071.58 SPEAKER_00 Как я уже сказал, до этого у него были абсолютно технические все вещи, в основном в этом сезоне, даже в прошлом сезоне, можно сказать, он взял тему медитации, разобрал её, провёл несколько уроков медитации в своём подкасте, обсудил в то же самое время клёвые книги по психологии, о том, как их можно применить к нашей IT-жизни, о том, как относиться к окружающему миру.
6071.58 6074.98 SPEAKER_00 В общем, всё в этой теме разобрал, тоже очень хорошо.
6074.98 6088.70 SPEAKER_00 И, по-моему, сейчас уже у него начался новый сезон, когда он вернулся уже к техническим темам, недавно с Нобелевским лауреатом по физике общался, вот тоже очень интересный подкаст.
6088.70 6101.82 SPEAKER_00 Короче, если кому-то интересно встать в сторону популяризации физики искусственного интеллекта и прочего вот этого научного нормальным языком среди нормальными людьми и гостями, вот всячески советую Ивана.
6101.82 6107.10 SPEAKER_00 И опять, где бы его доклад не увидели, обязательно поэкспериментируйте, посмотрите, думаю, вам зайдёт.
6107.10 6113.82 SPEAKER_00 Так, и последняя на рассылочка, которую я хотел с вами поделиться, это Кадаза.
6113.82 6119.90 SPEAKER_00 Недавно мы в нашем чатике открыли для себя этот забавный ресурс, это ролики про обучение на C#.
6119.90 6138.78 SPEAKER_00 В принципе, обучение на C# на русском языке, их есть много в интернете, это даже не самый популярный, я так думаю, но что выделяет его среди всех остальных, это у него есть шоты ютубовские, это 30-секундные ролики, которые вам за 30 секунд рассказывают какую-то тему.
6138.78 6150.82 SPEAKER_00 И там очень клёвые темы, например, там топ 10 вещей в АСП.нете, которые должен знать каждый разработчик, типа как устроить перформанс, или как за 30 секунд объясняется, как устроен семафор.
6150.82 6154.78 SPEAKER_00 В общем, такие вещи, которые начинающему разработчику просто must have.
6154.78 6161.94 SPEAKER_00 И как бы потратить 30 секунд, пока ты там, не знаю, едешь где-нибудь в лифте или что-то в этом духе, каждый способен.
6161.94 6165.38 SPEAKER_00 Ролики классные, интересные, записаны прикольно.
6165.38 6169.98 SPEAKER_00 И ещё одна отличная фишка этого канала, это в том, что там прекрасная графика.
6169.98 6177.38 SPEAKER_00 Я не знаю, в чём это делается, если вы вдруг знаете, в каких редакторах или с помощью каких средств, инструментов, обязательно напишите нам в комментарии.
6177.38 6184.26 SPEAKER_00 В общем, графика там обалденная, то есть это всё показывается с цветной анимацией, красиво, наглядно, по делу.
6184.26 6190.54 SPEAKER_00 И что ещё раз прибавляет пользы того материала, который там и так очень хорошо подаётся.
6190.54 6203.82 SPEAKER_00 В общем, если вы начинающий разработчик или просто вам интересно, как можно сделать современные интересные ролики про программирование, красочно, бодро и занимательно, в общем, попробуйте, посмотрите на YouTube канал Кадаза.
6203.82 6207.26 SPEAKER_02 Да, интересно, там причём не только короткие, там есть и более длинные.
6207.26 6208.26 SPEAKER_02 Короче, всё.
6208.26 6215.22 SPEAKER_00 Да, да, длинные тоже с прекрасной графикой, с отличным объяснением, тоже миллион просмотров, поэтому да.
6215.22 6223.94 SPEAKER_02 Ну и там есть Telegram-каналчик, в котором чуть более часто выходят какие-то новости, хотя они в видеоформате, так что да, может быть действительно будет интересно, если вы изучаете C#.
6223.94 6232.22 SPEAKER_02 Ну что, на этом, наверное, на сегодня надо нам заканчивать, мы с тобой уже сидим почти 3 часа, всё это пишем, готовим
6232.22 6234.82 SPEAKER_00 и так далее, так что… Да, уже скоро утро.
6234.82 6240.70 SPEAKER_02 Ну ещё не утро, но да, на часах час ночи, чтобы вы знали, как мы всё это пишем.
6240.70 6258.90 SPEAKER_02 Так что да, сегодня мы посмотрели на то, быстрый ли у нас S/Panet Core, подумали, как раскладывать файлики в новых проектах с минимальной API, при этом давайте все будем использовать новый MemoryPack Serializer, который ещё сам супербыстрый, собирать это всё GitHub-экшенами на GitHub.
6258.90 6276.06 SPEAKER_02 А если вы собирались собрать .NET, то к вашим услугам теперь есть монолитный репозиторий всего .NET в месте, если же вы собираете ваши Nuget пакеты, берите Nugetizer, делайте это всё в райдере, который стал ещё быстрее, особенно по сравнению с Visual Studio, да ещё и с ReSharper.
6276.06 6279.46 None Ну а в свободное время слушайте подкасты, про которые говорил Толя.
6279.46 6284.70 SPEAKER_02 На этом всё, это был 63 выпуск Radio.net.
6284.70 6294.10 SPEAKER_00 Да, всем счастливо, подписывайтесь, шарьте, рассказывайте друзьям, жмите нам на колокольчик, мы ждём ваших комментариев и всячески нас распространяйте.
6294.10 6295.98 SPEAKER_00 Всем спасибо, всем пока!
6295.98 6296.70 SPEAKER_00 Всем пока!
6296.70 6313.98 None [музыка]
