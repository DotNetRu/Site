0.00 11.16 "Анатолий Кулаков" Здравствуйте, дорогие друзья, в эфире Радио.нет и выпуск 51-й.
11.16 13.64 "Анатолий Кулаков" Сегодня с вами в студии Анатолий Кулаков.
13.64 15.84 "Игорь Лабутин" И Игорь Лабутин, привет.
15.84 25.72 "Анатолий Кулаков" Большое спасибо за помощь нашим постоянным и весёлым патронам, среди которых Александр, Сергей, Владислав, Алексей, Шевченко Антон, Илья и Гурий Самарин.
25.72 30.64 "Анатолий Кулаков" А также много-много других лиц, которые пожелали остаться анонимными.
30.64 32.68 "Анатолий Кулаков" Большое спасибо вам, друзья, что нас поддерживаете.
32.68 34.24 "Анатолий Кулаков" И что у нас тут?
34.24 36.08 "Анатолий Кулаков" Парочку технических объявлений.
36.08 43.84 "Анатолий Кулаков" Я в прошлый раз говорил, что нас заблочили на Анкоре, соответственно заблокировали наш основной фид, через который кормились очень много наших слушателей.
43.84 54.64 "Анатолий Кулаков" Вот, мы попытались там всё перенести и кажется, что у нас получилось это сделать с минимальными потерями, но судя по статистике, у нас отварилось очень много слушателей из Белоруссии.
54.64 69.64 "Анатолий Кулаков" Поэтому, друзья, если вдруг у вас есть какая-то возможность нас там прокинуть в соцсеточки Белоруссии или там порекламировать в сети своих друзей или ещё что-то, то вот очень активно просим вас именно там рассказать, что у нас теперь новый фид.
69.64 80.00 "Анатолий Кулаков" И для того, чтобы всё это исправить, нужно зайти на наш сайт radio.dotnet.ru и соответственно подписаться заново на RSS-фид.
80.00 88.80 "Анатолий Кулаков" Или выбрать снова тот плеер, которым вы пользуетесь и просто перезаписаться, перерегистрировать наш подкаст в этом вашем плеере.
88.80 95.44 "Анатолий Кулаков" Вот, это поможет, опять же, получать новые выпуски и не потеряться среди наших слушателей.
95.44 109.00 "Анатолий Кулаков" Вот, во всём остальном у нас сейчас слушатели все на месте остались и отлично продолжаем расти, поэтому кат вас, как всегда, шар, репост, лайк и всё такое.
109.00 110.88 "Анатолий Кулаков" Это нам очень сильно помогает.
110.88 116.16 "Анатолий Кулаков" Также хочется напомнить про конференцию .next, которая пройдёт уже совсем скоро.
116.16 123.12 "Анатолий Кулаков" Примечательна она тем, что теперь будет не только онлайн-часть, как последние два года, но и офлайн-часть.
123.12 129.80 "Анатолий Кулаков" И на офлайн-часть собираются очень много наших старых закадычных спикеров, ну а также, естественно, новых интересных докладчиков.
129.80 135.04 "Анатолий Кулаков" И готовятся там потрясающие темы, о которых, я надеюсь, мы поговорим отдельно, в специальной выпуске.
135.04 143.92 "Анатолий Кулаков" А в этом выпуске хочется сказать, что если вы ещё не приобрели билетик почему-то, то у нас для вас есть промокод, который вы сможете найти в шоу-нотах.
143.92 148.12 "Анатолий Кулаков" И, соответственно, с скидочкой на персональный билет присоединиться к дружной компании.
148.12 152.32 "Анатолий Кулаков" Я уверен, что мы с Игорем там будем.
152.32 153.32 "Игорь Лабутин" Правда, Игорь?
153.32 155.16 "Игорь Лабутин" Да, я, по крайней мере, пока планирую быть.
155.16 157.52 "Игорь Лабутин" У меня никаких планов найти не нет.
157.52 169.00 "Анатолий Кулаков" Вот, поэтому можно пообщаться, как бы, уже будет физически со всеми нашими слушателями, кто доберётся в Санкт-Петербург к этим прелестными летними вечерами, деньками.
169.00 172.32 "Анатолий Кулаков" Мы, скорее всего, подготовим для вас каких-нибудь наклейчик.
172.32 174.44 "Анатолий Кулаков" Для всех слушателей радио ДотНета.
174.44 182.68 "Анатолий Кулаков" И с нас их можно будет честно требовать, если вдруг кто-то нас встретит или узнает или каким-то другим образом зашлёт своего казачка.
182.68 185.48 "Анатолий Кулаков" В общем, я думаю, наклейчик мы сделаем побольше, будем раздавать вовсю.
185.48 187.24 "Анатолий Кулаков" Поэтому ищите нас на конференции ДотНекст.
187.24 194.16 "Анатолий Кулаков" Вот, соответственно, промокодик в описании, я сказал.
194.16 196.48 "Анатолий Кулаков" И ещё у нас интересное объявление.
196.48 201.64 "Анатолий Кулаков" Мы, как бы, двигаемся всё время больше и больше, дальше и дальше, пытаемся экспериментировать.
201.64 202.92 "Анатолий Кулаков" Как я уже говорил ранее.
202.92 213.04 "Анатолий Кулаков" И вот у нас впереди ещё один интересный эксперимент, который, мне кажется, как раз-таки повышает нашу, так сказать, взрослость, уже как подкаста.
213.04 216.48 "Анатолий Кулаков" Игорь, ты как считаешь, это знак?
216.48 219.56 "Игорь Лабутин" Ну, надеюсь, что да.
219.56 224.28 "Игорь Лабутин" Хотя, не знаю, знаки, они как всегда бывают с плюсами, с минусами.
224.28 226.28 "Игорь Лабутин" Но надеюсь, что это исключительно с плюсом.
226.28 231.56 "Анатолий Кулаков" Ну, а если конкретнее, то, друзья, я хочу вам рассказать про одну интересную кампанию.
231.56 234.40 "Анатолий Кулаков" Представляем вам мир крутых IT-решений.
234.40 239.04 "Анатолий Кулаков" Когда начинаешь думать о завтрашнем днём, приходит понимание о своей индивидуальности.
239.04 242.96 "Анатолий Кулаков" Приходит время новых требований, и мыслить нужно масштабно.
242.96 247.96 "Анатолий Кулаков" Знать больше, видеть дальше, и поэтому стоит именно сейчас заявить о себе.
247.96 254.04 "Анатолий Кулаков" Компания Monopoly предлагает тебе создавать вместе платформы цифровой логистики на пике технологий.
254.04 259.32 "Анатолий Кулаков" IT-ландшафт компании разделён на продукты, востребованные клиентами и партнёрами.
259.32 266.72 "Анатолий Кулаков" Продукты, которые разрабатываются в современной Agile модели, опираются на микросервисный подход с использованием актуального стека.
266.72 273.60 "Анатолий Кулаков" Если .NET, то обязательно Core, если интеграция, то на брокерах сообщений, если DeepLoyd, то в Kubernetes.
273.60 278.24 "Анатолий Кулаков" Это продукты для вечно востребованной отрасли транспортной логистики.
278.24 283.60 "Анатолий Кулаков" Собственные машины компаний и партнёров, которые доставляют грузы по всей стране.
283.60 292.48 "Анатолий Кулаков" Уберизация грузовых перевозок - это направление актуальное и востребованное, что позволяет устойчиво держаться на рынке в любую погоду.
292.48 301.24 "Анатолий Кулаков" Внеси свой клад развития цифровой логистики и по ссылке в описании можно ознакомиться с более подробной информацией о ближайшем ярком будущем.
301.24 307.88 "Анатолий Кулаков" Вот такая интересная компания решила нас поддержать, поэтому друзья, посмотрите вакансии по ссылке.
307.88 324.00 "Анатолий Кулаков" Компания действительно интересная, развивается сейчас большими темпами, не собирается сдаваться и предлагает очень интересные вакансии, которые востребованы и направлены на абсолютно широкий спектр специалистов.
324.00 330.24 "Анатолий Кулаков" Там можно найти то, что вам по душе среди большого числа различных вакансий.
330.24 332.80 "Анатолий Кулаков" Ну что ж, наверное, на официальной части закончено.
332.80 336.56 "Анатолий Кулаков" Давай попробуем пробежаться и посмотреть, что у нас там по новостям.
336.56 343.28 "Анатолий Кулаков" По-моему, Microsoft у нас зарелизил как раз-таки Preview 4 и там много всего интересного.
343.28 352.16 "Игорь Лабутин" Да, бежать нам сегодня по новостям будет достаточно нужно долго, потому что новостей очень много и мы постараемся посмотреть на них все.
352.16 354.84 "Игорь Лабутин" Действительно, вышел DotNet 7 Preview 4.
354.84 365.84 "Игорь Лабутин" Там, как обычно, есть с одной стороны очень много изменений, с другой стороны очень немного изменений, так что пробежимся, постараемся по всем ним, кратенько, по крайней мере.
365.84 372.40 "Игорь Лабутин" Ну а если вас заинтересуют какие-то детали, изучайте внимательно GitHub, там всё, конечно, всё гораздо более подробно.
372.40 379.44 "Игорь Лабутин" Во-первых, как обычно, пройдем по основному DotNet, а потом по ISP.NET и Entity Framework.
379.44 388.76 "Игорь Лабутин" В основном DotNet закончилась аннотация библиотек всех в namespace Microsoft Extensions для nullability.
388.76 396.96 "Игорь Лабутин" То есть теперь все эти библиотеки в этом namespace, они все правильно работают с nullability и полностью готовы для этого.
396.96 399.48 "Игорь Лабутин" Причем надо сказать, что это был сторонний contribution.
399.48 407.04 "Игорь Лабутин" Это был сторонний contribution от человека, который не работает в Microsoft, но который нашел полезным.
407.04 412.12 "Игорь Лабутин" И вот такое замечательное дело потратил на это, я так понимаю, по-моему, не один месяц вроде даже.
412.12 416.44 "Игорь Лабутин" Такой полномерной работы, но теперь все готово.
416.44 426.44 "Игорь Лабутин" Дальше есть некоторый раздел про Observability, где есть, скажем так, довольно интересные изменения вокруг Activity Current.
426.44 437.68 "Игорь Лабутин" Если вы работали с Observability, вы наверняка знаете, что в DotNet информация о текущем контексте исполнения таскается вокруг через статическое поле Activity.Current.
437.68 446.60 "Игорь Лабутин" И вообще говоря, бывает нужно, чтобы можно было узнать, когда этот самый Activity.Current меняется зачем-то.
446.60 452.56 "Игорь Лабутин" Ну то есть, например, не знаю, мне, кстати, вообще говоря, не приходит в голову, зачем это может быть нужно.
452.56 453.56 "Игорь Лабутин" Зачем отлавливать?
453.56 456.52 "Игорь Лабутин" Как ты думаешь, есть идеи, зачем отлавливать изменения Activity.Current?
456.52 460.08 "Анатолий Кулаков" Не знаю, может какую-нибудь дополнительную информацию поднести.
460.08 471.76 "Анатолий Кулаков" Допустим, ты с одного потока на другое переключился, и ты хочешь расшарить, засунуть в контекст, разенричить его, так сказать, номером трейда или именем класса, который начинает быть активен для текущего.
471.76 472.76 "Игорь Лабутин" Вот что-то типа того.
472.76 474.60 "Игорь Лабутин" Да, наверное, может быть действительно так.
474.60 492.08 "Игорь Лабутин" И теперь такой способ, точнее, был возможен, когда вы создаете новый Activity, вы можете подписаться на его изменения, но проблема в том, что когда вы находитесь в контексте что-то по реквесту, то за вас этот Activity, который Current текущий, он вообще говоря был уже создан когда-то давно кем-то в начале обработки реквеста.
492.08 504.92 "Игорь Лабутин" Так вот, теперь есть у Activity.Current, теперь можно подписаться на его Change Event в любой момент времени и, соответственно, получать нотификации, когда у вас он меняется, зачем бы вам это ни было надо.
504.92 520.16 "Игорь Лабутин" А второе, что поменялось, и это полезная штука как раз для всяких Enrichers и прочих логинг-фреймворков вокруг них, это то, что у Activity есть три свойства, это Tags, Links и Events.
520.16 532.12 "Игорь Лабутин" И теперь у них есть нормальный, довольно быстрый и шустрый нумератор, который не будет кушать кучу памяти, то есть в лучших традициях правильных нумераторов, это структурка, которая будет работать без аллокации и все такое.
532.12 538.56 "Игорь Лабутин" Поэтому теперь, если вам нужно быстро занумерировать теги, линки, либо ивенты внутри Activity, у вас есть способ для этого.
538.56 551.36 "Игорь Лабутин" Следующее изменение касается наших любимых типов работы со временем, а именно это Timestamp, DateTime, DateTimeOffset и TimeOnly, там теперь добавили проперти явный для микросекунд и наносекунд.
551.36 561.44 "Игорь Лабутин" До этого момента у нас самый низко, так сказать, ну, проперти с самым высоким разрешением был Tick, это 100 наносекунд.
561.44 577.12 "Игорь Лабутин" Если вам нужно по какой-то причине измерять там микросекунды или наносекунды, вы вынуждены были переводить эти тики с помощью специальной API, получать сколько у нас наносекунд в тике или сколько микросекунд, сколько тиков в микросекунде и, соответственно, каким-то образом там что-то все вычислять в вашем коде.
577.12 580.84 "Игорь Лабутин" Теперь эти проперти есть напрямую в этих всех типах.
580.84 582.56 "Игорь Лабутин" RegaExp улучшились.
582.56 592.32 "Игорь Лабутин" Во-первых, закончилась, как я понимаю, так сказать, спанизация, то есть в тех местах, где еще не было поддержки спанов, теперь добавили.
592.32 598.84 "Игорь Лабутин" Это методы IsMatch, Count и EnumerateMatches, там теперь есть поддержка спана T.
598.84 621.84 "Игорь Лабутин" Добавили некоторое количество улучшений перформанса и улучшили то, что код, который генерирует SourceGenerator для RegaExp, чтобы он был более читаемым и более удобно отлаживаем, если вы, например, хотите отлазить, почему там ваш RegaExp как-то странно работает на ваших примерах, вы можете поотлаживать тот код, который сгенерирован SourceGenerator, но вот теперь он будет получше, поинтереснее.
621.84 623.96 "Игорь Лабутин" Кэширование претерпело изменения.
623.96 650.96 "Игорь Лабутин" Теперь у вас есть удобный тип, точнее, интерфейс iMemoryCache, и его реализация, которую все обычно используют, и к ним добавили метрики, то есть теперь у вас есть у интерфейса iMemoryCache есть метрики getCurrentStatistics, с помощью метода getCurrentStatistics вы получаете объект MemoryCacheStatistics, где можете посмотреть, сколько было кэш-хитов, ну и так далее, на сколько там долго живут объекты, в общем, всякую разную статистику.
650.96 664.72 "Игорь Лабутин" Это позволяет заэкспозить, например, эту самую информацию, как метрики, либо через EventSource в вашем приложении, и не нужно это все считать вручную.
664.72 676.04 "Игорь Лабутин" В .NET 7 завезли новиночку, это TAR API, то есть нативная пишка для работы с TAR архивами, TapeArch, которые в Linux очень популярны.
676.04 691.16 "Игорь Лабутин" Это все живет в сборке System.Formats.TAR, они абсолютно крод-платформы, все хорошо, там есть простенькая API, статический метод, типа tarfile.createFromDirectory и tarfile.extractFromDirectory.
691.16 700.20 "Игорь Лабутин" Это если вы хотите, допустим, директорию запаковать в один файлик, вы туда указываете путь к директории, путь к файлику, и оно само все упакует как надо.
700.20 720.16 "Игорь Лабутин" Но это можно делать не только в файлике, это можно делать в стримы, и кроме того, это позволяет, например, скомбайнить какой-нибудь gzip-стрим с вот этим новым TAR API и делать сразу по сути архивы tar.gz, как в Linux популярно, и их соответственно чейнить друг за другом.
720.16 733.48 "Игорь Лабутин" Дальше есть специальный лидер, итератор, который позволяет читать контент архива по файлово, то есть вам не нужно все распаковывать, а просто можно получать эти файлики поштучно, ну и писать их, соответственно, можно также поштучно.
733.48 740.68 "Игорь Лабутин" И последнее замечание — это то, что все API на данный момент синхронны.
740.68 750.40 "Игорь Лабутин" То есть сейчас вы пока не найдете асинхронных методов, хотя понятно, что это работа с файлами, поэтому должны быть асинхронные методы, они появятся в каких-то из последующих превьюшек, просто не успели.
750.40 752.64 "Игорь Лабутин" Пока все синхронно.
752.64 767.08 "Игорь Лабутин" Завезли некоторое количество улучшений в CodeGenie, не буду углубляться, смотрите ищите на GitHub, они очень уже специализированы, и я не думаю, что сильно интересно в них прям так углубляться поштучно, но зато одна из вещей, которые касаются CodeGene, она довольно интересная.
767.08 771.52 "Игорь Лабутин" Она теперь называется OnStackReplacement, еще ее теперь сокращают как OSR.
771.52 777.84 "Игорь Лабутин" И это штука, которая позволяет рантайму менять код методов, даже если этот метод сейчас исполняется.
777.84 808.28 "Игорь Лабутин" То есть мы знаем, что у нас существует TiredCompilation, то есть, так сказать, многоэтапная компиляция, то есть когда у вас метод компилируется, но потом, согласно статистике его исполнения, если какой-то из методов становится очень часто исполняемым, его JIT перекомпилирует в более оптимальном виде, с учетом статистики его исполнения, с учетом статистики переходов по разным бранчам, в какой-то более оптимальный вид, и подменяет тело этого метода на новое скомпилированное.
808.28 811.68 "Игорь Лабутин" Так вот эта штука не работала, если метод сейчас исполняется.
811.68 813.44 "Игорь Лабутин" Теперь так можно будет делать.
813.44 817.24 "Игорь Лабутин" Это по дефолту включено на x64 и на ARM64.
817.24 831.92 "Игорь Лабутин" И позволяет это, по сути, быстро запускать приложение, то есть они при своих бичмарках нашли, что это экономит примерно 25% от стартап-тайма, то есть время до обработки первого реквеста снижается на 10-30%.
831.92 856.72 "Игорь Лабутин" И все это достигается за счет того, что вы даже самые сложные методы, которые, допустим, у вас, не знаю, какой-нибудь цикл обработки чего-нибудь, вначале запускается, он быстро JIT-ится и запускается, но потом он доджитчивается, и несмотря на то, что он все еще работает, вы можете теперь подменить это тело, ну точнее JIT это делает на лету, даже прямо в самом исполняемом методе.
856.72 859.08 "Игорь Лабутин" И все работает замечательно.
859.08 866.72 "Игорь Лабутин" Ну и Central Package Management, про который мы говорили в прошлый раз, он тоже появился вот на 7.v4 финально.
866.72 867.72 "Игорь Лабутин" А SPNet?
867.72 876.84 "Игорь Лабутин" В SPNet не так много всего, хотя... хотя, наверное, я ошибаюсь, там тоже не так их мало.
876.84 879.96 "Игорь Лабутин" Давайте посмотрим на это по порядочку, как обычно.
879.96 881.92 "Игорь Лабутин" HTTP/2, Performance Improvements.
881.92 892.96 "Игорь Лабутин" Ну тут все понятно, что TPP/2 это JRPC во многом, и часто они практически синонимы, и соответственно работа над ними ведется более-менее параллельно.
892.96 900.44 "Игорь Лабутин" Они довольно сильно переделали, как вообще кестерол процессит все это дело, уменьшили расход CPU и увеличили пропускную способность.
900.44 905.24 "Игорь Лабутин" Звучит это прям как сказка, но на самом деле причина простая.
905.24 910.44 "Игорь Лабутин" В принципе, HTTP/2 по дефолту позволяет до 100 реквестов на 1 TCP connection.
910.44 916.20 "Игорь Лабутин" Мы помним, что HTTP/2 мультиплексирует реквесты и таскает все эти реквесты через 1 HTTP connection.
916.20 919.16 "Игорь Лабутин" Ну или через несколько, но много реквестов.
919.16 927.36 "Игорь Лабутин" До 4 превью для того, чтобы разобраться, кто должен сейчас писать в TCP connection, использовался самый обычный простой C# лог.
927.36 937.28 "Игорь Лабутин" Но выяснилось, что в высокопроизводительном коде это все ведет к довольно неприятным контеншенам на этом логе, и поэтому теперь сделали по-простому.
937.28 951.00 "Игорь Лабутин" Лог убран, вместо него добавлена thread_save очередь, и dedicated, соответственно, выделенный поток пишет в TCP connection, потихонечку разгребая эту очередь.
951.00 956.32 "Игорь Лабутин" В итоге по бенчмаркам, ну понятно, что это синтетические бенчмарки, но выглядят довольно приятно.
956.32 966.20 "Игорь Лабутин" То есть 6.dotnet позволяет обрабатывать примерно 500 тысяч сообщений в секунду, ну, какие-то тривиальные обработки, но тем не менее, пропускать через pipeline, собственно, обработки.
966.20 976.44 "Игорь Лабутин" В Golang умеет где-то 2.5 миллиона сообщений в секунду, а вот новый dotnet 7 preview 4 аж 6.5 миллионов сообщений в секунду, то есть в два раза больше, чем на Go.
976.44 982.16 "Игорь Лабутин" Мы, в общем, тут мы победили с большим отрывом, но правда это довольно синтетическая штука.
982.16 984.44 "Игорь Лабутин" Посмотрим, как в реальных приложениях.
984.44 988.32 "Игорь Лабутин" Для minimal API завезли опять новую пачку улучшений.
988.32 1010.24 "Игорь Лабутин" Во-первых, это typed results, то есть вы теперь можете достучаться до, собственно, классов, которые типизированы результат, то есть всегда вы видели интерфейс iResult, но все типы, которые его реализуют и которые реально возвращаются, когда вы используете всякие разные методы типа .ok или .что-нибудь другое, они были internal.
1010.24 1015.72 "Игорь Лабутин" Теперь они сделаны public, чтобы они были более доступны и более удобны для unit-тестов.
1015.72 1023.16 "Игорь Лабутин" И есть аналог класса http.results, есть класс http.typedresults.
1023.16 1031.56 "Игорь Лабутин" Дальше, для minimal API есть еще добавление в openAPI импровментов, появился новый пакетж, называется microsoft.aspinadcore.openapi.
1031.56 1044.76 "Игорь Лабутин" Его можно добавить автоматически, если вы гневите новое приложение с флагом --enable --openapi, ну либо просто зарефинитить его как обычный ssproj.
1044.76 1060.56 "Игорь Лабутин" После этого вам становится доступен extension метод with openapi, который генерирует штуку под названием openapi.operation, автоматически угадывая все наполнение из, соответственно, route-хендлера и метаданные, которые там атрибутами заданы.
1060.56 1076.28 "Игорь Лабутин" Можно использовать перегрузку этого метода, где можно задать все явно, и после этого, соответственно, это все автоматически собирается в openapi-спецификацию за вас.
1076.28 1088.88 "Игорь Лабутин" Иначе, если вы помните, что можно было это все задавать большим количеством атрибутов, сейчас можно использовать этот метод with openapi, и он сам попытается угадать из всех остальных метаданных, что там нужно делать.
1088.88 1096.56 "Игорь Лабутин" Это все делается с помощью двух магических интерфейсов --indpoint_metadata_provider и indpoint_parameter_metadata_provider.
1096.56 1107.96 "Игорь Лабутин" Вы можете, если вы используете какие-то свои кастомные типы для параметров, например, реализовать эту штуку, либо все встроенные типы, естественно, используются.
1107.96 1109.20 "Игорь Лабутин" Но возникает проблема.
1109.20 1120.24 "Игорь Лабутин" Предположим, что у вас есть метод minimal API, route-хендлер, который умеет возвращать либо ok, если все хорошо, либо он, например, умеет возвращать 404.
1120.24 1129.16 "Игорь Лабутин" Если мы хотим хорошую openapi-спецификацию, нам нужно уметь говорить, что вот в таких-то условиях он возвращает 200, в таких-то условиях он возвращает 404.
1129.16 1149.64 "Игорь Лабутин" Чтобы вот эта мудрая логика могла понять, что вообще-то бывает и то, и то, а в C#, как известно, мы не можем вернуть из метода или то, или другое, мы всегда должны вернуть один тип, завели специальный шаблончик, шаблонистый тип такой, называется results, и у него там n параметров типов.
1149.64 1162.44 "Игорь Лабутин" То есть и для таких методов, которые умеет возвращать либо ok, либо, допустим, not found, предполагается использовать results, дальше внутри в качестве типов вы указываете ok, и потом запятая not found, например.
1162.44 1178.04 "Игорь Лабутин" То есть такой tuple, но конкретно называемый results, видимо, он реализует тот самый endpoint метода provider и позволяет этому extension-методу, право, withoutOpenAPI, корректно найти все используемые возвращаемые типы и их корректно преобразовать в нормальную openapi-аспеку.
1178.04 1191.28 "Игорь Лабутин" В общем, если вы используете minimal API, если вы хотите видеть нормальную openapi-спецификацию и у вас, так сказать, called first, а не API first, то посмотрите в эту сторону, кажется, что Microsoft очень много вкладывается, чтобы получать нормальные openapi-аспеки.
1191.28 1202.20 "Анатолий Кулаков" Интересно, смотри, у тебя для minimal API есть теперь специальная библиотечка, которую, соответственно, Swagger поддерживает, а для обычного API используется, насколько я помню, свеш-бакл сейчас по дефолту в темплейте.
1202.20 1204.24 "Анатолий Кулаков" Как это, не конфликтует все?
1204.24 1215.04 "Игорь Лабутин" Насколько я понимаю, нет, просто свеш-бакл, то он же, по-моему, контроллеры ищет, и свеш-бакл вряд ли будет уметь искать вот эти все route and point, если их не разметить атрибутами, конечно.
1215.04 1218.84 "Игорь Лабутин" То есть, предполагается, либо ты размечаешь атрибутами, либо вот этот extension метод.
1218.84 1233.28 "Анатолий Кулаков" Свеш-бакл использует IAP Explorer, то есть это тоже штука, которая собирает контроллеры в том числе, ну а также те, кто помечен атрибутами route, те, кто пронаследованы там от какого-то еще какой-то чуши.
1233.28 1237.92 "Анатолий Кулаков" Ну, в общем, она пытается, пытается собрать действительно тоже все максимально многое.
1237.92 1245.88 "Анатолий Кулаков" Конечно же, minimal API она не находит, и те endpoints, которые там регистрируются напрямую в middleware, она тоже не находит.
1245.88 1248.68 "Анатолий Кулаков" Но, скорее всего, эта штука тоже не решит эти проблемы.
1248.68 1249.68 "Игорь Лабутин" Ну, вот посмотрим.
1249.68 1256.48 "Игорь Лабутин" Я пока не видел ни одного упоминания, чтобы это кто-то использовал, ну, никаких как бы статей, никаких как бы примеров, how to.
1256.48 1257.48 "Игорь Лабутин" Посмотрим.
1257.48 1261.84 "Игорь Лабутин" Надо будет дождаться статьи от Andrew Locke, который уже заберет, как она работает внутри, и мы все узнаем.
1261.84 1263.32 "Игорь Лабутин" Обычно это так работает.
1263.32 1264.32 "Игорь Лабутин" Подождем.
1264.32 1268.84 "Игорь Лабутин" Да, дальше про minimal API, это не все.
1268.84 1271.16 "Игорь Лабутин" Есть еще штука, под названием route groups.
1271.16 1317.80 "Игорь Лабутин" То есть, если, например, у вас есть набор endpoints, и вы хотите выставить их несколько раз, например, с разными префиксами, то есть, ну, вы хотите там, не знаю, /new, /delete, да, я знаю, что это может быть не самый правильный пост, рест, соответственно, стиль, но, тем не менее, например, вам надо выставить там /new, /delete, /что-нибудь еще с одним префиксом и ровно такой же набор, но с другим префиксом, вы теперь можете это объединить в route group, выбрать из нее group route builder, ну, то есть, это специальный класс, в смысле, используя класс group route builder, вы получаете всю эту конструкцию, и дальше вы ее используете как будто это один route для minimal API, а оно будет, по сути, рекурсивно внутри заходить и разбирать уже дальше внутри группы все рауты.
1317.80 1320.80 "Игорь Лабутин" Уж удобный способ переиспользовать разные endpoints.
1320.80 1329.44 "Игорь Лабутин" Мне никогда на практике такое не надо было, но, действительно, может быть, если вы, допустим, эмулируете какой-то API, где нужно повторить несколько одинаковых endpoints с разными префиксами, почему нет?
1329.44 1334.64 "Игорь Лабутин" А может, кстати, версионность так можно будет сделать с разными v1, v2 префиксами.
1334.64 1335.64 "Игорь Лабутин" Интересно.
1335.64 1347.72 "Анатолий Кулаков" В общем, нам нужно больше причин, зачем они столько много вкладываются в minimal API и что с этим совсем делать, потому что кажется, что на практике это не так полезно, как звучит в документации, сколько туда вбухиваются сил.
1347.72 1356.76 "Игорь Лабутин" Ну, справедливости ради, надо сказать, что я, например, не читал документацию по route группам, а Microsoft сейчас довольно много пишет именно такой.
1356.76 1364.72 "Игорь Лабутин" Не документация в стиле старого MSDN, а вот параметры такие, функции такие и так далее, а больше статей, зачем это может быть надо и как это использовать.
1364.72 1367.16 "Игорь Лабутин" То есть, может быть, на самом деле такие статьи скоро появятся.
1367.16 1368.16 "Игорь Лабутин" Подождем.
1368.16 1373.40 "Игорь Лабутин" Давайте дальше пока, тут не так много уже осталось конкретно про .NET 7.
1373.40 1378.64 "Игорь Лабутин" Значит, в SignalARIA появились улучшения, а именно client results.
1378.64 1389.04 "Игорь Лабутин" То есть, раньше сервер мог вызвать метод на клиенте, но он не мог ждать ответа, то есть он просто мог такие fire and forget, то есть какие-то такие notification слайды, но не получать ответ от них.
1389.04 1407.24 "Игорь Лабутин" Теперь, соответственно, можно использовать такой метод под названием isingleClientProxy.invokeAsync, и тогда, соответственно, в клиенте срабатывает метод .on, ну, то есть handler, и в нем, если вы из него что-то вернете, оно, соответственно, вернется обратно на сервер из SignalARIA.
1407.24 1409.12 "Игорь Лабутин" То есть, в принципе, такое теперь работает.
1409.12 1418.20 "Игорь Лабутин" Есть фича, мы про нее поговорим чуть-чуть отдельно, про нее есть отдельная большая статья, это gRPC.jsonTranscoding.
1418.20 1419.96 "Игорь Лабутин" Дальше нас наконец-таки услышали.
1419.96 1447.64 "Игорь Лабутин" Ну, нас не нас, но в общем, глас народа был услышан, и в опциях визарда, а также при создании нового приложения в .NET 7 Preview 4 вы можете в визарде поставить чекбоксик, а в командной строчке указать флаг useDeficeProgramDeficeMain, и у вас не будет использованный top-level statement, а родится старый добрый main, там вот это все, как положено, без top-level.
1447.64 1450.76 "Игорь Лабутин" Фу, а шутчики, я старпер, сделайте мне все, как было.
1450.76 1464.20 "Игорь Лабутин" Да, но не все, как было, я так понимаю, что стартап тебе не будет сделан, то есть тебе будет именно main вернется, а вот стартап-класс вроде как нет, то есть minimal API там все еще будет, внутри main.
1464.20 1489.76 "Игорь Лабутин" Добавились rateLimitingMiddleware, то есть теперь есть extension метод под названием useRateLimiter, и там есть некоторое количество разных rate-лимитеров, concurrency, token-bucket, no-operation, тоже полезный лимитер, может быть нужен в разных случаях, но в общем если вам нужен зачем-то rate-лимитинг и вы не использовали для этого какие-то другие библиотеки, посмотрите, или наоборот, если вы использовали, и вам интересно посмотреть, что сделал Microsoft, посмотрите в эту сторону.
1489.76 1500.36 "Игорь Лабутин" Ну и наконец, Entity Framework Core, тут особых больших изменений нет, единственное, что сделали, это сделали фичу под названием Domain Driven Design and Guarded Keys.
1500.36 1520.48 "Игорь Лабутин" Идея в следующем, одна из идей Domain Driven Design в том, чтобы использовать value-обжекты в качестве ключков, ну то есть не int что-нибудь, а это должно быть там, не знаю, userId, прям вот заводим тип userId, который ведет себя как int, со всех сторон int, но он все-таки отдельный класс.
1520.48 1534.80 "Игорь Лабутин" Проблема была в том, с HeaveCore, что если вы такой тип хотите сохранять, то вам нужно на него навесить конвертер, понятное дело, чтобы HeaveCore знал вообще, что его-то надо конвертить в int.
1534.80 1547.68 "Игорь Лабутин" Но также, если это id объекта, то обычно вы туда могли навесить атрибут для value generation, чтобы он автоматически отдавал, допустим, его на откуп в базе данных для генерации idшника.
1547.68 1549.92 "Игорь Лабутин" Так вот это было нельзя совмещать.
1549.92 1573.48 "Игорь Лабутин" Теперь совмещать можно, теперь вы можете вместе и конвертер навесить, и навесить флаг value generation, в общем, там изменения конкретно для этого случая, поэтому если вы используете такие ключики, которые не примитивных типов, а обертка над ним value объектом, то знаете HeaveCore 7 прям то, что вам надо, Preview 4.
1573.48 1583.64 "Игорь Лабутин" На этом все про Preview 4, больше там новостей нет, но есть у нас новости про другие библиотеки.
1583.64 1591.84 "Игорь Лабутин" А новости про другие библиотеки это .NET MAUI, релиз кандидата 3, потихонечку готовят релиз кандидата, потихонечку движемся к релизу.
1591.84 1602.24 "Игорь Лабутин" Напоминаю, что по исходным планам у нас релиз должен был состояться во втором квартале 22 года, половина его прошла, так что ждем интересно, успеют или не успеют.
1602.24 1628.72 "Игорь Лабутин" Но вот уже релиз кандидата 3, там нет каких-то супер больших изменений, видимых пользователю, в смысле всех о чем стоило бы написать большую статью, однако если посмотреть на GitHub release notes, видно, что там порядка сотни багов пофикшено по сравнению с прошлым релиз кандидатом, и поэтому, ну в общем, фаза стабилизации, что с нее взять, особо новых фич не ждем, зато фиксим баги.
1628.72 1656.04 "Игорь Лабутин" Значит, MAUI релиз кандидата 3 требует Visual Studio 2022 Preview 17.3 Preview 1, про это чуть-чуть позднее расскажем, это тоже вышло новое, но это все работает пока только на Windows, а для того, чтобы это заработало на Mac, вам нужно использовать Command Line, и для этого на Вике есть отдельные инструкции, смотрите линк в шоуноутах, там будет ссылка на новость, где будет ссылка на Вике.
1656.04 1666.40 "Игорь Лабутин" Для нативной Visual Studio на Mac пока поддержки нет, и оно будет выпущено чуть-чуть позднее в следующих Preview или релиз кандидатах.
1666.40 1670.00 "Игорь Лабутин" Так что вот, MAUI потихонечку готовится.
1670.00 1677.80 "Анатолий Кулаков" Уже очень смешной такой кроссплатформенный фреймворк получается, когда он на половине редакторов работает, на половине не работает, а на третьем через командную строку войдете.
1677.80 1681.72 "Анатолий Кулаков" Как-то тут кроссплатформенностью уже не пахнет, даже не дожидаясь релиза.
1681.72 1682.72 "Игорь Лабутин" Ну да, да.
1682.72 1683.72 "Игорь Лабутин" Все так.
1683.72 1690.12 "Игорь Лабутин" Ну нет, оно как бы кроссплатформенно, то есть работает оно кроссплатформенно.
1690.12 1693.04 "Анатолий Кулаков" Если заставить, если разработаете, если запустите.
1693.04 1699.48 "Игорь Лабутин" Ну да, но это же Linux Way, что там, командная строка, все дела, там, brew, install, ну это на маке, так далее.
1699.48 1700.48 "Игорь Лабутин" Так что все нормально.
1700.48 1706.60 "Игорь Лабутин" Если он заработает из командной, тем более ты все-таки это делаешь один раз, по сути.
1706.60 1709.80 "Игорь Лабутин" Если не обновляешься на каждое Preview.
1709.80 1711.84 "Анатолий Кулаков" Ну хорошо, давай дождемся релиза.
1711.84 1719.60 "Анатолий Кулаков" Так, а я бы хотел вернуться к вот еще одной интересной по моему теме, это как раз таки gRPC JSON Transcoding.
1719.60 1721.76 "Анатолий Кулаков" Блин, такое сложное название.
1721.76 1724.28 "Анатолий Кулаков" А за ним лежит довольно просто концепция.
1724.28 1727.20 "Анатолий Кулаков" Давайте для начала вспомним, что такое gRPC.
1727.20 1731.88 "Анатолий Кулаков" Это прежде всего современный путь для того, чтобы обмениваться данными между приложениями.
1731.88 1737.48 "Анатолий Кулаков" Он работает поверх HTTP/2 и нацелен на стриминг, на бинарную сервизацию.
1737.48 1739.80 "Анатолий Кулаков" У него есть предефайнятые контракты.
1739.80 1747.84 "Анатолий Кулаков" То есть все сделано максимально для того, чтобы создавать high-performance приложения и создавать сервисы реального времени.
1747.84 1753.56 "Анатолий Кулаков" И, соответственно, в дотнете сейчас шикарная поддержка gRPC.
1753.56 1764.48 "Анатолий Кулаков" Там очень много сделано, библиотек, генераторы, все оптимизировано под лучшие структуры, без залокаций, с SMS'ками и так далее.
1764.48 1766.48 "Анатолий Кулаков" То есть там сейчас отличная поддержка идет.
1766.48 1771.84 "Анатолий Кулаков" Сам Джеймс Ньютон Кинг этой темой занимается и подробно описывает все в статейках.
1771.84 1775.64 "Анатолий Кулаков" В общем, в дотнете gRPC все прекрасно.
1775.64 1781.76 "Анатолий Кулаков" Но остается куча как легаси приложений, так и приложений, которые, в принципе, не хотят на gRPC.
1781.76 1783.04 "Анатолий Кулаков" И их можно понять.
1783.04 1790.08 "Анатолий Кулаков" Потому что существует в мире давно признанный, давно устоявшийся подход, как REST и JSON.
1790.08 1792.84 "Анатолий Кулаков" И он сейчас абсолютно везде.
1792.84 1807.20 "Анатолий Кулаков" То есть если gRPC можно рекомендовать для взаимодействия между сервисами внутри какой-то своей интерпрайс-группы, то REST и JSON, он, в принципе, как мировой стандарт сейчас стоит и вряд ли его оттуда кто-то в ближайшее время сможет сбить.
1807.20 1809.52 "Анатолий Кулаков" Поэтому они существуют параллельно.
1809.52 1820.36 "Анатолий Кулаков" REST и JSON, в отличие от high-performance, scalability, wallability gRPC, прекрасны тем, что он основан на текстном протоколе.
1820.36 1826.20 "Анатолий Кулаков" То есть его легко человеки могут читать и, соответственно, легко очень дебажить.
1826.20 1831.32 "Анатолий Кулаков" И куча инструментария уже есть, встроенная в каждый браузер, который все это помогает делать.
1831.32 1834.76 "Анатолий Кулаков" Соответственно, у нас таких вот два мира появляется.
1834.76 1847.52 "Анатолий Кулаков" И разработчики ASP.NET решили, а нельзя ли сделать так, чтобы наши разработчики, которые выставляют наружу свой public API, одновременно могли работать и через gRPC, и через REST.
1847.52 1861.28 "Анатолий Кулаков" И вот один из таких подходов, их несколько, который мы с вами уже раньше обсуждали, и вот один из таких подходов, новый, самый хороший, самый лучший, самый прекрасный, сейчас выходит в первую превью.
1861.28 1864.08 "Анатолий Кулаков" Называется он как раз-таки gRPC JSON-транскодинг.
1864.08 1875.20 "Анатолий Кулаков" Эта штука, она была очень сильно требовалась на всяких микрософтовских формах по тому, куда дальше развиваться фреймворку.
1875.20 1877.80 "Анатолий Кулаков" В общем, там за нее отдали много-много голосов.
1877.80 1882.68 "Анатолий Кулаков" И вот, наконец, мы можем лицезреть то, что непосредственно у Microsoft получилось.
1882.68 1895.16 "Анатолий Кулаков" Прежде всего, это библиотечка, которая расширяет стандартный ASP.NET Core, и она помогает вам создавать REST API сервисы поверх уже готовых ваших gRPC сервисов.
1895.16 1911.32 "Анатолий Кулаков" Соответственно, она помогает маппить методы gRPC на знакомые уже нам HTTP концепты, такие как HTTP глаголы, бандинг параметров через URL или через BODY, и также JSON-реквест и JSON-респонс.
1911.32 1919.24 "Анатолий Кулаков" Вот все эти штуки она помогает автоматически вам создать, сделать и замапить на уже готовый gRPC API, если он в вашем приложении уже есть.
1919.24 1923.44 "Анатолий Кулаков" И внедрить эту вещь не так уж сложно.
1923.44 1931.24 "Анатолий Кулаков" То есть, вам нужно стандартное gRPC приложение, которое вы создаете, как обычно, без всяких наворотов и ухищрений.
1931.24 1937.00 "Анатолий Кулаков" Дальше к нему добавляется специальный пакетик, который как раз-таки содержит все вот эти бандинги.
1937.00 1941.60 "Анатолий Кулаков" И самое интересное, вам нужно добавить аннотации к вашему протофайлу.
1941.60 1957.16 "Анатолий Кулаков" Это HTTP-бандинг аннотаций, которые как раз-таки и позволяют рассказать протофайлу, каким образом смапить роуты, реквесты, респонсы, как раз как их смапить в терминологию REST.
1957.16 1970.64 "Анатолий Кулаков" И, соответственно, добавив такой обычный атрибутик, описав необходимые роуты, у вас при поднятии вашего endpoint, при поднятии вашего приложения, возникает несколько точек обмена информацией.
1970.64 1975.84 "Анатолий Кулаков" Стандартное gRPC, под которое вы создавали приложение, и REST API.
1975.84 1992.72 "Анатолий Кулаков" И к этому REST API вы можете, естественно, обратиться там из браузера, из VGET, откуда еще угодно, из Курла, дернуть стандартный глагол, если вы прописали GET, обратиться к стандартному URL, который вы прописали в своем протофайле, и получить нормальный JSON-результат.
1992.72 1996.72 "Анатолий Кулаков" Таким образом, ваше приложение может отвечать сразу по двум протоколам.
1996.72 2002.04 "Анатолий Кулаков" Как я уже сказал ранее, в принципе, эта идея не нова.
2002.04 2013.76 "Анатолий Кулаков" Сама концепция у мира довольно часто встречается, и есть несколько подходов, которые позволяют добиться примерно то же самого, но не сильно отличаются по реализации.
2013.76 2016.56 "Анатолий Кулаков" Первый из них, это, конечно, gRPC Web.
2016.56 2033.16 "Анатолий Кулаков" gRPC Web как раз создавался в те годы, когда HTTP/2 был не столь распространен, да в принципе, сейчас он, наверное, уже не столь распространен, и это была такая промежуточная прокси-заготовка в основном для веб-браузеров.
2033.16 2037.08 "Анатолий Кулаков" То есть, веб-браузер мог сгенерить специальный gRPC клиент.
2037.08 2047.92 "Анатолий Кулаков" Вот этот gRPC Web-клайент общался как раз с сервером и отдавал в качестве полезной нагрузки, в качестве пейлода, маленькие сообщения, которые были в формате протобафа.
2047.92 2071.72 "Анатолий Кулаков" Это был, соответственно, чистый протобаф, и он обменивался каким-то там сервисом, который ловил эти сообщения по стандартному HTTP/1 протоколу и конвертил их куда нужно уже внутри вашей интерпрайс-сети, уже передавал сервису, который работал непосредственно по gRPC.
2071.72 2097.08 "Анатолий Кулаков" Вот, в отличие от этого подхода, JSON-транскодинг он позволяет браузерам вообще ничего не знать об gRPC и позволяет просто-напросто общаться с стандартными REST подходами, REST-поинтами, REST-клиентами и вообще использовать как бы те клиенты, которые, может быть, существовали до появления технологии gRPC и никаким образом об этом не заботятся.
2097.08 2100.64 "Анатолий Кулаков" В общем, еще один подход – это gRPC Gateway.
2100.64 2110.48 "Анатолий Кулаков" Это тоже такое специальное приложение, отдельное, обычно, прокси, которое ставится посередине между вашими внутренними gRPC-сервисами и внешними клиентами.
2110.48 2127.96 "Анатолий Кулаков" Он генерирует, соответственно, тоже gRPC-клиентов и обменивается по протоколу HTTP/2 со своими gRPC-сервисами, а на вход получает от внешних потребителей обычный JSON API.
2127.96 2148.68 "Анатолий Кулаков" Его основная фишка заключается в том, что он способен поддержать, то есть такой подход способен поддержать абсолютно любые языки, неважно на каком языке у вас написан gRPC-сервис, неважно с каким языком вам приходит клиент, так как это промежуточное ПО, оно просто-напросто конвертит туда-сюда результаты и, соответственно, отдает обратно.
2148.68 2173.88 "Анатолий Кулаков" В отличие от этого подхода gRPC-транскодинг, он встраивается внутрь вашего ISPNet-приложения и непосредственно децентрализует JSON-овские реквесты, которые к нему пришли, конвертит их в Protobuf-месседж и напрямую отдает вашему сервису без какой-то пересылки по сети, без использования дополнительного там, что-то типа 2 канала и без дополнительных каких-то конвертаций, потому что это все происходит in-process.
2173.88 2194.04 "Анатолий Кулаков" И, соответственно, так как это единый процесс, то есть тот, который занимается и конвертацией, и обработкой ваших JSON-реквестов и обработкой обратных JSON-респонсов, это сильно позволяет увеличить перформанс и убрать накладные расходы между взаимодействиями вот этих двух узлов, что есть в gRPC Gateway подходе.
2194.04 2206.64 "Анатолий Кулаков" И, соответственно, команда Microsoft рассчитывает на то, что благодаря вот этим преимуществам подход как раз-таки с транскодингом будет намного быстрее и эффективнее по памяти.
2206.64 2210.28 "Анатолий Кулаков" В общем, вот такая интересная штука.
2210.28 2224.40 "Анатолий Кулаков" То есть у нас пытаются помириться два мира, теперь мы можем не выбирать, что мы хотим, gRPC или REST API, а описывать оба контракта в файле прота и, соответственно, вставлять оба endpoint.
2224.40 2242.96 "Анатолий Кулаков" И тем, кому нужно быстро, бинарно и, может быть, даже как-то секурно, те могут использовать gRPC подходы, а тем, кому нужно в публичную сеть выставить и, может быть, совместимость для старых клиентов обеспечить, те могут использовать REST API подход.
2242.96 2248.00 "Анатолий Кулаков" Я напомню, что это был всего лишь на все первый превью.
2248.00 2263.40 "Анатолий Кулаков" Релиз планируется сделать как раз вместе с .NET 7, и в будущих превьюшках команда хочет сосредоточиться на перформансе, чтобы все это работало без всяких там нареканий, чтобы это был полностью production ready код, и также поддержкой OpenAPI.
2263.40 2269.56 "Анатолий Кулаков" Это тоже очень востребованная штука, ее многие просят, и без OpenAPI сейчас вообще никто жить не может.
2269.56 2273.72 "Анатолий Кулаков" Вот такая вот интересная технология, соответственно, будем следить, что у команды получится.
2273.72 2281.60 "Игорь Лабутин" Да, мы пойдем дальше рассказывать про то, что же Microsoft нам выкатил еще, и это Visual Studio.
2281.60 2286.08 "Игорь Лабутин" На этот раз у нас даже две Visual Studio, обе 2022.
2286.08 2288.16 "Игорь Лабутин" Во-первых, вышла 17.2.
2288.16 2296.60 "Игорь Лабутин" Это официальный уже релиз вполне, мы много раз видели всякие разные превьюшки, теперь у нас получился официальный полный релиз.
2296.60 2298.68 "Игорь Лабутин" Напомню аккуратненько, что в него вошло.
2298.68 2307.56 "Игорь Лабутин" Это SourceLink, то есть теперь, когда вы идете в GoToImplementation, в гауте будет использоваться SourceLink, ну либо EmbeddedSource, если они есть.
2307.56 2320.92 "Игорь Лабутин" В C# поддержали Rows, Strings, Literal, Add, вы помните, когда там можно много-много кавычек написать в строчках, и тогда там переносы строк хитро учитываются, точнее, они не учитываются, и всякие смещения строк учитываются в начале строки.
2320.92 2329.12 "Игорь Лабутин" Новый Visualizer для коллекции при отладке, обновили немножко редактор для Razer.
2329.12 2359.08 "Игорь Лабутин" Дальше, если вы пользуетесь SPNet Web Forms почему-то, то у вас теперь есть там правильный Live Preview, улучшился, как обычно, туллинг для Ажура, улучшился гитовый туллинг, и напоминание от Microsoft, что 17.2 это так называемый Long Term Support Channel, то есть он не настолько лонг, как в дотнете, но тем не менее он довольно лонг, это значит, что версия 17.2 для студии будет поддерживаться 18 месяцев до 9 января.
2359.08 2378.72 "Игорь Лабутин" И одновременно с этим вышло 17.3 Preview 1, там пока ничего нового, кроме того, что это официальный релиз для того, чтобы работать с MAUI, то есть если вы работаете с MAUI, то берите его, ну либо если вы почему-то любите превьюшки студии, а так пока там ничего принципиально нового нет.
2378.72 2387.64 "Игорь Лабутин" Ну и куда же мы без еще одной студии, это Visual Studio 22 for Mac, это релиз кандидат.
2387.64 2403.32 "Игорь Лабутин" Там тоже каких-то сильно больших нововведений нету, туда, как мы уже много раз описали, внесли часть изменений из большой студии, то есть туда потихонечку переезжают всякие гетовые изменения и так далее.
2403.32 2428.44 "Игорь Лабутин" Но в целом, значит, в этом релиз кандидате полностью нативный macOS UI, а бэкэнд IDE полностью работает на шестом дотнете, нативно поддерживается Apple M1, вы можете использовать эту студию для сборки, ну для того чтобы делать ваши espnet core приложения, консольные приложения, ну и конечно же клауд, ажер фанкшнс, вот это все.
2428.44 2434.20 "Игорь Лабутин" Поддерживается до шестого дотнета, как я сказал, и десятое C#.
2434.20 2447.24 "Игорь Лабутин" MAUI Tooling будет в следующей версии, 17.1, ну и в целом примерно так, какие-то небольшие UI-ные улучшения, типа Tool Window можно теперь драгон дропать, ну и вот все такое прочее.
2447.24 2463.60 "Игорь Лабутин" Так что студия потихонечку движется к релизу, но по сути это причесанное к замолинда приложение, которое с нативным UI, и по фичам, конечно, отстает от большой студии от виндовой, но потихонечку пытается ее догнать.
2463.60 2464.60 "Игорь Лабутин" Как-то так.
2464.60 2480.20 "Анатолий Кулаков" Я нашел статейку Андрю Лока, нашего замечательного автора, который тут немножко рассуждает не то чтобы об SPNet, как он всегда любит, а о такой более концептуальной интересной теме, как генерация вообще айдишников.
2480.20 2489.24 "Анатолий Кулаков" И вот, и соответственно затрагивает много концептуальных тем, поэтому мне она показалась очень интересным и решил, вот давай мы сейчас ее с тобой примерно и обсудим.
2489.24 2499.24 "Анатолий Кулаков" Итак, прежде всего у нас есть сущности, у сущности есть айдишники, которые ты уже прямо сегодня успел упомянуть, и обычно сущности у нас хранятся в базах данных.
2499.24 2506.80 "Анатолий Кулаков" Вот рассматриваем такую стандартную концепцию, стандартный шаблон, и есть несколько подходов, а каким же образом вообще создается сам айдишник.
2506.80 2514.00 "Анатолий Кулаков" Самый простой, элементарный, когда у нас есть база данных, то позволить базе данных сгенерить идентификатор.
2514.00 2519.64 "Анатолий Кулаков" Наверное самыми распространенными типами для идентификаторов являются Int, Long и Skyfuse.
2519.64 2522.88 "Анатолий Кулаков" Игорь, ты вот какие предпочитаешь использовать для идентификаторов
2522.88 2533.68 "Игорь Лабутин" в своих приложениях? Ну, обычно, скорее всего, лонги у нас используются, но для некоторых сущностей, особенно если мы применяем там какое-нибудь шардирование и так далее, то там, конечно,
2533.68 2546.60 "Анатолий Кулаков" гуиды. Ну вот, удобно использовать базу данных тем, что она вам отдает, соответственно, сама следит, зачем какие идентификаторы выбрать, и отдает вам уже готовые какие-то полезные айдишники.
2546.60 2554.00 "Анатолий Кулаков" Эти айдишники обычно характеризуются тем, что они монотонно возрастают и, соответственно, обычно они последовательные.
2554.00 2561.68 "Анатолий Кулаков" То есть они такие красивенькие, особенно если мы говорим о лонгах и интах, они обычно у вас красивенькие и, соответственно, в урлах смотрится приятно.
2561.68 2565.92 "Анатолий Кулаков" Там User1, User2, User3 без всяких там страшных огромных хвостов.
2565.92 2568.76 "Анатолий Кулаков" Но у этого подхода есть, конечно же, и минусы.
2568.76 2579.52 "Анатолий Кулаков" Прежде всего, минус заключается в том, самый главный, наверное, что айдишники появляется лишь тот момент, когда вы отдадите вашу сущность в базу данных, ну то есть по сути ее заинсертите.
2579.52 2581.52 "Анатолий Кулаков" И только тогда у вас будет на руках айдишник.
2581.52 2585.04 "Анатолий Кулаков" А это приводит к куче различных ограничений.
2585.04 2597.36 "Анатолий Кулаков" Например, вы не можете хорошо сущность залогировать до того, как вы ее сохраните в базу данных, потому что, по сути, у нее нет идентификатора, и логировать вы будете каким-то вторичным половым признаком.
2597.36 2613.08 "Анатолий Кулаков" Также неудобно убирать, например, дедупликацию, неудобно сделать референсы на другие сущности, если у вас есть три сущности, которые связаны между собой, то до тех пор, пока вы ее не сохраните, не узнаете ее айдишник, вы, соответственно, не можете прописать этот айдишник друг к другу.
2613.08 2627.40 "Анатолий Кулаков" Это, конечно же, все пытается нивелировать как какой-нибудь entity framework с помощью своих умных референсов, но все-таки проблема есть, и если мы используем какое-то более низковыровневый фреймворк или более сложную ситуацию, она всплывает вообще во весь рост.
2627.40 2636.84 "Анатолий Кулаков" Также из минусов стоит отметить, что у нас существует теперь проблема, когда, например, клиент создает какую-то сущность на сервере.
2636.84 2644.20 "Анатолий Кулаков" Нам теперь необходимо клиенту каким-то образом вернуть этот идентификатор, чтобы клиент дальше смог с этой сущностью работать.
2644.20 2656.32 "Анатолий Кулаков" Соответственно, мы должны сначала данные отправить на сервер, сервер их там должен как-то заинсертить, обработать, соответственно, какой-то workflow, создать этот айдишник и вернуть еще к клиенту.
2656.32 2662.36 "Анатолий Кулаков" То есть это лишнее какое-то взаимодействие, туда-сюда гонять данные только для того, чтобы айдишник узнать.
2662.36 2665.56 "Анатолий Кулаков" В общем, это обычно тоже вливается в какие-то грустные кейсы.
2665.56 2674.56 "Анатолий Кулаков" Ну и, наверное, самая очевидная, самая главная штука, которая просто убивает весь этот подход, это если вы пытаетесь свое приложение заскалировать.
2674.56 2697.00 "Анатолий Кулаков" Когда вы пытаетесь написать туда тысячи и тысячи запросов в секунду, ваша база данных может стать bottleneck, потому что возникает огромный contention, и некоторые сценарии, такие даже high-performance распределенные сценарии, просто невозможно будет реализовать, когда у вас база данных отвечает за то, чтобы генерить все эти айдишники.
2697.00 2700.28 "Анатолий Кулаков" То есть вы можете упереться в этот непосредственно айдигенератор.
2700.28 2705.48 "Анатолий Кулаков" И, соответственно, логи на таблицах и прочие-прочие интересные вещи, которые решаются очень-очень сложно.
2705.48 2713.08 "Анатолий Кулаков" В качестве альтернативы бывают еще user-client-generated айдишники.
2713.08 2719.44 "Анатолий Кулаков" То есть не база данных их может генерить, а вы можете их сгенерить на клиенте непосредственно.
2719.44 2746.88 "Анатолий Кулаков" И в качестве такого промежуточного между сервер-бастой и юзер-бастой, client-based, есть, соответственно, я даже не знаю какое официальное название у этой штуки, но, в общем, я видел такие проекты, где ты айдишник непосредственно генерируешь, то есть ты фиксируешь какой-то блок, какой-то определенный слот на сервере, резервируешь какой-то range айдишников и уже на клиенте их раздаешь.
2746.88 2749.64 "Анатолий Кулаков" Например, такой алгоритм можно встретить в RavenDB.
2749.64 2759.96 "Анатолий Кулаков" Это high-load подход, когда Raven просто посылает на сервер и говорит, вот следующие 100 айдишников я резервирую за моим вот этим локальным клиентом, и они больше никому не отдадутся.
2759.96 2763.20 "Анатолий Кулаков" А локальный клиент их по одному раздает своим сущностям.
2763.20 2777.68 "Анатолий Кулаков" Таким образом, мы и не ходим к серверу за каждым айдишником, и, соответственно, на клиенте у нас красивые айдишники получаются, потому что они выдаются точно так же по порядочку, упорядоченно, через один и монотонно возрастают.
2777.68 2787.48 "Анатолий Кулаков" В общем, этот подход сложен в реализации, сложен в поддержке, у него там еще есть куча разных каких-то минусов, поэтому есть чисто вообще клиентский подход.
2787.48 2793.36 "Анатолий Кулаков" Никуда ходить не надо, нигде резервировать ничего не надо, вам нужно просто-напросто сгенерить гуд.
2793.36 2798.56 "Анатолий Кулаков" И использовать этот гуд в качестве промо-реключа для клиента.
2798.56 2800.72 "Анатолий Кулаков" Соответственно, это безумно легко.
2800.72 2805.96 "Анатолий Кулаков" Вы делаете гуд-неугуд на вашем локальном клиентике, и все.
2805.96 2816.36 "Анатолий Кулаков" У вас нет никакого контеншена, у вас нет никаких bidirection workflow, то есть клиент отсылает к базе данных какие-то данные, и все.
2816.36 2819.44 "Анатолий Кулаков" Обратный результат с идентификатором ему уже не нужен.
2819.44 2825.08 "Анатолий Кулаков" Он знает, какой айдишник у этой сущности, если она успешно сохранилась, он дальше может использовать этот айдишник везде.
2825.08 2829.00 "Анатолий Кулаков" В логировании, в релейшенах, когда угодно, где угодно.
2829.00 2832.16 "Анатолий Кулаков" Поэтому это безумно приятно и безумно легко.
2832.16 2834.56 "Анатолий Кулаков" Но есть и небольшие минусы.
2834.56 2839.04 "Анатолий Кулаков" Во-первых, это уже не так красиво выглядит, как монотонный возвращающий инт.
2839.04 2848.56 "Анатолий Кулаков" То есть в урлах вы уже будете передавать какие-то страшные гуды, и для отладки, и для визуального восприятия это уже не так красиво.
2848.56 2850.16 "Анатолий Кулаков" Но это все в принципе мелочи.
2850.16 2856.40 "Анатолий Кулаков" Самая главная проблема заключается как раз-таки в рандомности этого айдишника, то что он мегарандомный.
2856.40 2865.04 "Анатолий Кулаков" Именно это помогает избежать конфликтов на различных клиентов, потому что каждый клиент сгенерирует свой гарантированно уникальный идентификатор.
2865.04 2876.32 "Анатолий Кулаков" Но для индексов в базе данных это может служить большим минусом, потому что мегарандомные айдишники приводят к фрагментации индекса.
2876.32 2896.60 "Анатолий Кулаков" И соответственно, как еще один небольшой минус, это увеличивает размер вашей базы данных и влияет на перформанс, не только на перформанс вставки новой записи, но и на перформанс селекта, потому что у вас уже получается разряженный сфрагментированный индекс, и соответственно, селект тоже может тормозить в этих случаях.
2896.60 2904.88 "Анатолий Кулаков" И чтобы решить эту проблему, соответственно, была придумана такая концепция как sortable айдишник, sortable GUID.
2904.88 2922.28 "Анатолий Кулаков" То есть это тот же самый айдишник, но он уже не мега такой рандомный, который бросает во все стороны каждый битик, а он отсортирован, то есть у него первая часть она сортируемая, то есть она вставляется в индекс очень красиво, очень близко и очень правильно.
2922.28 2937.08 "Анатолий Кулаков" И соответственно, для микрософтовского SQL-сервера есть даже специальная функция new sequential ID, которая вам позволяет автоматически сгенерировать вот такой вот GUID, который сортируется.
2937.08 2945.68 "Анатолий Кулаков" И уже он лишен всех этих недостатков, у него уже нет никакой фрагментации индексов, он вставляется в базу нативно и красиво.
2945.68 2950.72 "Анатолий Кулаков" Для Postgres существует только третисторонний плагин, который делает всю штуку.
2950.72 2958.36 "Анатолий Кулаков" В стандартной поставке Postgres не поддерживает генерацию таких sequential ID, и объясняется это довольно-таки просто.
2958.36 2973.56 "Анатолий Кулаков" Делали в том, что только кластерный индекс, когда у вас вся таблица хранится в кластерном индексе, то есть тот подход, который использует Microsoft SQL, только он страдает от рандомного GUID.
2973.56 2988.16 "Анатолий Кулаков" Но если мы берем heap-таблы, структуру, которую использует Postgres для схранения своих данных, то там таких проблем нет, там все это heap и вставляется туда все равно все с одинаковой скоростью, не важно, насколько он там рандомный или нет.
2988.16 2995.92 "Анатолий Кулаков" Поэтому Postgres, скорее всего, от таких проблем не страдает, это все актуально только для MS SQL.
2995.92 3014.52 "Анатолий Кулаков" Соответственно, на sequential ID это прекрасно, но опять же мы возвращаемся к том, что для того, чтобы сгенерить sequential ID, нам нужен Microsoft SQL сервер, это единая точка отказа, это единый bottleneck, единое место генерации одишников, это плохо, мы не хотим им пользоваться.
3014.52 3021.28 "Анатолий Кулаков" Поэтому люди придумали очевидную вещь, что sequential ID можно, в принципе, генерировать и на клиенте, никакой магии там нет.
3021.28 3029.48 "Анатолий Кулаков" И вот одно из таких библиотек, которые позволяют вам сгенерить нормальный sequential ID на клиенте и является той библиотекой, которую обнаружил, наконец, Andrew Locke.
3029.48 3042.92 "Анатолий Кулаков" Называется она NewID, и это обычный генератор sequential ID, который можно использовать между различными узлами множества клиентов и ожидать, что между ними не будет никаких коллизий.
3042.92 3054.44 "Анатолий Кулаков" То есть одишники обязательно уникальны, как обычный GUID, но при этом они могут сортироваться по времени, если вдруг вы захотите вставить какой-то общий persistent, какой-то общий сторож.
3054.44 3065.72 "Анатолий Кулаков" Алгоритм NewID довольно-таки не нов, о нем рассказывал еще Twitter много-много лет назад, называется он Snowflake, который базируется на более раннем подходе, который называется Flake.
3065.72 3068.80 "Анатолий Кулаков" Пейпер можно найти легко в интернете.
3068.80 3071.88 "Анатолий Кулаков" И, соответственно, самая главная фишка в том, что он сортируемый.
3071.88 3076.84 "Анатолий Кулаков" Если копнуть поглубже, то этот NewID состоит из трех секций.
3076.84 3091.60 "Анатолий Кулаков" Во-первых, самая большая, 64 бита, первая секция — это TimeSpan, то есть именно как раз-таки время, текущее время позволяет создать вот эту сортируемую часть, и соответственно у вас все данные, все одишники, они будут сортироваться именно по времени.
3091.60 3093.56 "Анатолий Кулаков" Вот это первая часть.
3093.56 3102.40 "Анатолий Кулаков" Вторая часть — это непосредственно worker ID какой-то, то есть это уникальный идентификатор клиента, который не должен в вашем кластере каким-то образом повторяться.
3102.40 3111.48 "Анатолий Кулаков" То есть, соответственно, если клиент будет одинаков, то есть вот этот worker ID будет одинаков, у вас тогда могут быть дубли.
3111.48 3114.44 "Анатолий Кулаков" Если он уникален в вашем кластере, то никаких дублей не будет.
3114.44 3127.32 "Анатолий Кулаков" Ну и, соответственно, если вы в одну и ту же миллисекунду на одном и том же клиенте попытаетесь сгенерить несколько идентификаторов, то для этого есть последняя третья часть, которая называется Sequence.
3127.32 3142.44 "Анатолий Кулаков" Sequence часть, она вам позволяет как раз-таки в рамках одного worker ID в одну миллисекунду генерить множество одишников, в частности 2 в 16 степени одишников за одну миллисекунду, но вы можете сгенерить без какой-то потери уникальности.
3142.44 3146.80 "Анатолий Кулаков" То есть все эти одишники будут гарантированно уникальны в пределах вселенной.
3146.80 3160.36 "Анатолий Кулаков" И, соответственно, благодаря вот этим трём частям вы можете сделать одишники, которые у вас будут сортируемые, которые будут уникальные и которые, соответственно, будут быстрые и неповторяемые.
3160.36 3165.24 "Анатолий Кулаков" Вот, в принципе, и весь секрет данного подхода.
3165.24 3179.76 "Анатолий Кулаков" Далее Андрилок не остановился, он взял Docker Container с msql-сервером, вставил туда 10 тысяч гуидов, вставил туда 10 тысяч new id-шников с помощью вот этой новой библиотечки и сравнил, что же в конце концов получилось.
3179.76 3189.12 "Анатолий Кулаков" И, соответственно, для сравнения есть специальные в msql-команды, которые показывают подробную статистику о том, какие были индексы построены, сколько они памяти занимали и прочее-прочее.
3189.12 3194.64 "Анатолий Кулаков" Вы можете сами попробовать воспроизвести на своих системах и посмотреть, в каком состоянии находятся ваши SQL-сервера.
3194.64 3197.92 "Анатолий Кулаков" Итак, по итогам.
3197.92 3203.24 "Анатолий Кулаков" Если мы используем одишники, то где-то 99% мы получали фрагментированные индексы.
3203.24 3204.24 "Анатолий Кулаков" Это очень-очень много.
3204.24 3209.92 "Анатолий Кулаков" Вот, если мы использовали new id, то у нас фрагментация была всего на 5%.
3209.92 3222.44 "Анатолий Кулаков" И, соответственно, Андрю ещё заметил, что при использовании гуидов стандартных, обычных, рандомных, у нас также очень сильно сжалось место, то есть использовалось много пустого места в страницах.
3222.44 3226.12 "Анатолий Кулаков" И, соответственно, страниц нужно было больше для хранения одних и тех же данных.
3226.12 3236.68 "Анатолий Кулаков" И, для примера, для гуидов нам потребовалось 77 страниц для сохранения одной таблицы, а для new id-шников 59 страниц.
3236.68 3239.68 "Анатолий Кулаков" То есть намного меньше размер таблицы получился.
3239.68 3243.96 "Анатолий Кулаков" Не только, если мерить вообще одни id-шники и ничего больше.
3243.96 3251.80 "Анатолий Кулаков" Вот так можно, в принципе, закратить не только скорость выборки, скорость вставки ваших сущностей, но и место, на котором они хранятся.
3251.80 3257.48 "Анатолий Кулаков" Здесь стоит отдельно упомянуть, почему не нужно использовать sequential id.
3257.48 3260.40 "Анатолий Кулаков" Есть и такие случаи.
3260.40 3268.44 "Анатолий Кулаков" Прежде всего, sequential id, и в частности, вот эту библиотечку new id, не нужно использовать, если вы рассчитываете на хоть какую-то секьюрность или керептографию.
3268.44 3282.48 "Анатолий Кулаков" Например, с помощью неё не надо генерить пароли, не надо генерить security токены и не надо генерить всё то, все те id-шники, которые не должны быть предсказаны как-то или дешифрованы, потому что это абсолютно не криптография, это просто чисто случайные цифры.
3282.48 3284.96 "Анатолий Кулаков" В случае, все случайные цифры можно предсказать.
3284.96 3290.04 "Анатолий Кулаков" В частности, вот эти id-шники, они тоже при должной сноровке, при должном умении, они предсказываются.
3290.04 3294.04 "Анатолий Кулаков" Поэтому, если что-то касается секьюрности, вот там это не надо делать.
3294.04 3302.96 "Анатолий Кулаков" Ну и раз мы пошли говорить об идентификаторах, тут хотелось бы вам ещё парочку библиотек посоветовать, которые лично мне очень нравятся.
3302.96 3315.94 "Анатолий Кулаков" Это NanoitNet, это библиотека, которая позволяет вам генерить url-friendly id-шники, которые легко подставляются в урлы, как бы не конфликтуют, имеют специальные символы, их не надо скепить, они гарантированно проходят через эти урлы.
3315.94 3341.54 "Анатолий Кулаков" Соответственно, она генерит уникальный строковой id-генератор и использует более богатый алфавит, чем стандартный GUID, то есть она использует полностью буквы от A до Z, верхнюю и нижнюю регистры, а также цифры, что позволяет ей умещать полный id-шник вместо 36 символов, которые использует стандартный GUID, в 21 символ.
3341.54 3365.10 "Анатолий Кулаков" То есть получается тот же самый GUID, но короче, как альтернатива стандартному GUID, а также она интересна тем, что она портирована на 20 языков программирования, естественно, включая .NET, и вы можете какие-то взаимные генерации, уже предсказуемые, делать, которые, в принципе, id-шники будут генерироваться однообразно на всех языках, если для вас это, в принципе, актуально.
3365.10 3377.90 "Анатолий Кулаков" И еще одна интересная библиотека, которая называется Hash IDS, она интересна тем, что она не генерирует id-шники, она их как раз-таки кодирует.
3377.90 3410.34 "Анатолий Кулаков" Она способна сделать из обычных циферок, вот если у вас в базе данных используется 1, 2, 3, 4, 5, она способна сделать урлы, например, как вы увидите в YouTube, то есть вы в YouTube, когда открываете какой-то видосик, у вас вместо какого-то странного идентификатора или огромного GUID такая строчка, которая есть, в которой содержатся там всякие буковки, циферки в разных регистрах, но несложно заметить, что она довольно маленькая, особенно если представить, сколько терабайт там заливается на YouTube каждый день, сколько там количества видосиков, я уже себе просто не представляю.
3410.34 3415.62 "Анатолий Кулаков" А эта строка, которая является уникальным идентификатором, она все еще продолжает быть довольно маленькая.
3415.62 3427.78 "Анатолий Кулаков" И вот если вы хотите себе сделать точно такую же небольшую строчку, но которая внутри себя там способна хранить какие-то петабайтные IT-шники, то как раз эта библиотечка и позволяет вам такое чудо сделать.
3427.78 3443.90 "Анатолий Кулаков" И соответственно у вас появляются очень маленькие уникальные идентификаторы, эти идентификаторы генерятся из интежеров, из лангов или из массива интежеров и массива лангов, если вам почему-то нужно скомбанить там какой-то сложный идентификатор, она это тоже умеет делать.
3443.90 3452.22 "Анатолий Кулаков" Также она может подставлять кастомный алфавит, то есть только те символы, только те буковки, которые вы хотите использовать в ваших идентификаторах, вы можете сделать.
3452.22 3460.14 "Анатолий Кулаков" Также у нее есть возможность разбавить ваши ID-шники солью, что позволит вам не так легко предсказать идентификаторы с другой стороны.
3460.14 3485.38 "Анатолий Кулаков" Еще одна интересная особенность этой библиотеки в том, что у нее внутри есть специальный словарик некрасивых слов в английском языке и она проверяет все сгенерированные ID-шники, так как они генерятся из обычного английского алфавита, в том, что они не выражают какую-то нетолерантность или какую-то обиду в этих словах, чтобы ваши ID-шники как бы в урле смотрелись вполне толерантно и политкорректно.
3485.38 3492.98 "Анатолий Кулаков" Это тоже довольно важная штука и многие библиотеки из этой серии учитывают такие словари.
3492.98 3517.02 "Анатолий Кулаков" И еще раз, лишний раз хочу напомнить, что все эти библиотеки, которые выдают вам какие-то псевдослучайные, там набор цифр, это все не для криптографии, это все не для секьюрности, это вот чисто какие-то визуальные трюки, которые помогают вам избежать какого-то контентшена или сделать красивые урлы, но не пытайтесь это использовать в качестве паролей или криптотокинов.
3517.02 3528.42 "Анатолий Кулаков" Вот такой интересный рассказ получился Андре, соответственно используйте библиотечки, нужные и важные, именно в тех целях, которых они вам нужны.
3528.42 3538.10 "Игорь Лабутин" Ну и проверяйте, как ведет себя ваша база данных на тех или иных конструкциях, которые вы используете, на рандомных гуидах или на sortable гуидах или еще на чем-нибудь.
3538.10 3543.86 "Игорь Лабутин" Измеряйте, измеряйте, еще раз измеряйте при любых подобных изменениях.
3543.86 3548.14 "Игорь Лабутин" А мы пойдем дальше и продолжим про библиотечки.
3548.14 3559.10 "Игорь Лабутин" И мы сегодня поговорили про новые модные gRPC, вот это все, а теперь давайте окунемся в мир прошлого и поговорим про WCF.
3559.10 3569.38 "Игорь Лабутин" Когда-то это была технология, которую я использовал очень много, в последнее время я ей практически не занимаюсь, но однако есть еще немножко старого кода, который надо поддерживать.
3569.38 3578.62 "Игорь Лабутин" Но если вдруг вам нужно очень сильно и вы много работаете с WCF, но тем не менее хотите жить на современном нутнете, то посмотрите в сторону core.wcf.
3578.62 3596.10 "Игорь Лабутин" Это библиотека, которая пишется как замена, так скажем, старого dotnet framework с точки зрения WCF, она поддерживает далеко не все, но основные и популярные штуки поддержаны, и поэтому возможно вы сможете ее использовать в качестве замены.
3596.10 3617.86 "Игорь Лабутин" Она поддерживается dotnet standard 2.0, давненько мы уже не слышали такой штуки в панкасте, но тем не менее она его поддерживает, и это значит, что библиотеку можно использовать на dotnet framework 4.6.2+ и на dotnet core 3.1, и понятно, что на пятом, шестом и седьмом дотнете это все будет можно использовать.
3617.86 3621.10 "Игорь Лабутин" Причина, почему так сделано, довольно проста.
3621.10 3633.46 "Игорь Лабутин" Поддержка dotnet framework, с одной стороны, казалось бы, зачем, там же есть нормальный большой WCF, который прекрасно работает и полнофункциональный, но эта штука сделана ровно для того, чтобы было проще мигрировать.
3633.46 3654.10 "Игорь Лабутин" То есть не так, что вы переписываете все приложение на новый dotnet и начинаете пытаться туда встроить обратно WCF, а так, что вы заменяете использование стандартного WCF из dotnet framework на вот эту новую библиотеку, и если все работает, значит можно мигрировать весь остальной проект, продукт на современный dotnet.
3654.10 3667.26 "Игорь Лабутин" При этом, как я сказал, в core WCF функциональность поддержана не вся, и из того, что поддержана, это HTTP и нет TCP транспорта, поэтому если вы используете какие-нибудь там MSMQ, либо нет пайпа, пока их нету.
3667.26 3674.26 "Игорь Лабутин" Из байдингов поддержаны basic HTTP, нет HTTP, нет TCP, WS-HTTP, а ну еще и Web-HTTP.
3674.26 3688.38 "Игорь Лабутин" Секьюрити все неплохо, хотя не полный комплект, это транспорт секьюрити всех видов, нет TCP, и сертификаты, и Windows авторизация поддержана, аудентификация, простите, поддержана.
3688.38 3699.22 "Игорь Лабутин" Если вы используете HTTP-байдинг, нужно тогда всю аудентификацию конфигурировать через стандартные средства SPNetCore, потому что там по сути используется тот же kestrel внутри, ну и SPNetCore framework.
3700.22 3710.26 "Игорь Лабутин" Транспорт с MS-креденциалами поддержана, юзернейм, сертификаты, как я сказал, и даже поддержана Federation.
3710.26 3717.34 "Игорь Лабутин" Поддерживается WSDL-генерация, можно конфигурировать как через конфиг, по-моему, так и через код.
3717.34 3730.54 "Игорь Лабутин" Да, нам же приходили, если я правильно помню, был же у нас выпуск в подкасте, где нам рассказывали, что кто-то контрибьютил, как раз таки контрибьютор нам рассказывал про то, как он делал конфигурацию через код.
3730.54 3746.58 "Игорь Лабутин" Поддержана конфигурация сервисов endpoints, и при этом поддержана extensibility, то есть есть интерфейсы IServiceBehaviour и EndpointBehaviour, если вам эти слова о чем-то говорят, значит вы знаете, что такое WCF Extensibility и сможете это использовать.
3746.58 3753.70 "Игорь Лабутин" При этом часть хитча не поддержана, то есть, как я сказал, нет других транспортов, кроме HTTP и нет TCP.
3753.70 3760.38 "Игорь Лабутин" Message Security не поддержана, кроме, как в случае Transport или Transport with Message Credentials.
3760.38 3763.30 "Игорь Лабутин" Не поддержана Distributed Transaction, не поддержана Message Queue.
3763.30 3766.54 "Игорь Лабутин" Это из основных таких вещей, которые пока не работают.
3766.54 3779.90 "Игорь Лабутин" Непонятно, насколько они в планах, то есть будут или не будут, библиотека пишется, ну не то чтобы прям сильно большим коллективом авторов, и поэтому фичи приходится как-то выбирать.
3779.90 3783.18 "Игорь Лабутин" Кому нужно использовать ее по мнению авторов?
3783.18 3795.66 "Игорь Лабутин" Во-первых, для тех, кто использовал, конечно же, старый .NET, и тех, кто вынужден по какой-то причине старые проекты до сих пор поддерживать, но возможно переводя их на новый .NET фреймворк.
3795.66 3798.06 "Игорь Лабутин" На новый .NET, конечно же.
3798.06 3803.10 "Игорь Лабутин" При этом авторы настоятельно не рекомендуют использовать эту библиотеку для новых проектов.
3803.10 3806.66 "Игорь Лабутин" Они говорят, возьмите лучше gRPC или что-нибудь подобное.
3806.66 3815.22 "Игорь Лабутин" Не надо Core WCF использовать в новых проектах, SOAP сейчас не модно и вообще только для того, чтобы поддержать какие-то старые проекты.
3815.22 3839.10 "Игорь Лабутин" Надо сказать, что Core WCF, если бы меня спросили полгода назад, да даже месяц назад, про то, насколько она официальная, серьезная и так далее, я бы сказал, ну это просто какая-то библиотека, которая пишется ребятами из Microsoft, но так по принципу в свободное время, ну может быть даже не свободное, но по крайней мере это просто чтобы всем было попроще мигрировать.
3839.10 3842.58 "Игорь Лабутин" Но фактически, на самом деле, оказалось интереснее.
3842.58 3858.62 "Игорь Лабутин" У этой библиотеки будет официальный саппорт от Microsoft, и для версии 1.x будет поддержана последняя мажорная и минорная версия, то есть при выходе следующая минорная и предыдущая будет объявляться уже вне саппорта.
3858.62 3872.22 "Игорь Лабутин" И поддержка версии будет зависеть от поддержки основных платформ, то есть насколько долго будет поддерживаться 5, 6 или Core 3.1, настолько же долго будет поддерживаться Core WCF 1.x.
3872.22 3878.58 "Игорь Лабутин" Предыдущая версия, соответственно, при выходе новой версии поддерживается в течение 6 месяцев после выхода новой.
3878.58 3892.74 "Игорь Лабутин" Если же будут новые мажорные релизы Core WCF, а там 2.x и дальше, то там скорее всего будет сокращаться количество поддерживаемых рантаймов, то есть я допускаю, что какой-нибудь 3.1 довольно скоро следующую мажорную выпилят, а может быть и до этого фреймворк выпилят уже, к тому моменту, кто знает.
3892.74 3893.74 "Игорь Лабутин" Посмотрим.
3893.74 3910.06 "Игорь Лабутин" Но в целом интересно, что библиотека развивается, в принципе, ожидалось, но довольно неожиданно, что она обрела такой довольно суперофициальный саппорт от Майкрософта, то есть это значит, что всякие секьюрити патчи, вот это все будет вполне выходить и можно будет пользоваться.
3910.06 3925.62 "Анатолий Кулаков" Да, у меня в голове почему-то сложилось вообще, что это какой-то там больше комьюнити-проект, Майкрософт просто ее выплюнул и все, комьюнити само начало его разрабатывать, само поддерживать, и то, что Майкрософт дает какие-то гарантии по лайфтайму, это довольно интересно.
3925.62 3939.54 "Игорь Лабутин" Ну видимо поняли, что этого кода, как бы мы, может быть, не хотели бы сказать, что сооба это все прошлое век и не надо им пользоваться, но нет, код этот живет, работает, и его тоже надо поддерживать, и видимо коммерческих продуктов, где такой саппорт нужен, довольно много.
3939.54 3967.02 "Анатолий Кулаков" Смотри, вот этот подход, который сейчас в gRPC проповедуют, когда ты просто транскопируешь некий API в абсолютно другой протокол, с абсолютно другими схемами и другими форматорами, может быть, им стоило бы пойти в эту сторону, то есть может быть, его можно было как-то проксировать, написать какой-то gateway, который работал бы стабильно на одном протоколе и транспилировал это все в другой протокол.
3967.02 3970.02 "Анатолий Кулаков" Чем вот такими штуками заниматься и просить всех перейти?
3970.02 3983.50 "Игорь Лабутин" Ну вот как раз-таки к вопросу о перейти, если у вас все работает на дотнет-фреймворке, то скорее всего, если у вас нет каких-то больших планов на новый дотнет, вы как бы и останетесь на дотнет-фреймворке.
3983.50 4007.18 "Игорь Лабутин" Если же перейти, то тут вариантов два, либо тебе нужно переводить все твои контракты на тот же gRPC, например, либо использовать core-wcf, ну либо, да, как ты говоришь, можно было бы что-нибудь куда-нибудь транспилировать и так далее, но все-таки выставить gRPC как SOAP, ну мы увидели, что в Akrest можно, но они все-таки довольно близки, надо сказать, идеологически, а вот как SOAP все-таки тяжело.
4007.18 4023.66 "Анатолий Кулаков" Ну все равно у нас до сих пор нет каких-то понятных четких инструментов, как все-таки это перевести, потому что один в один это не мапится, вам нужно руками с нуля практически все переписать, а какой-нибудь автоматизации или какой-нибудь генерации или транскомпиляции вот в этом ничего не предоставляют.
4023.66 4030.54 "Анатолий Кулаков" Несмотря на то, что там для gRPC и REST там уже три или четыре подхода, там уже десятки тулзов, которые
4030.54 4034.06 "Игорь Лабутин" пытаются одно и то же сделать. А я боюсь, что это не так просто.
4034.06 4043.30 "Игорь Лабутин" То есть чисто API, набор методов с параметрами, переделать из SAP в REST и обратно, я думаю, что не сложно.
4043.30 4049.42 "Игорь Лабутин" Но стоит задуматься о каких-нибудь вот всех этих extensibility endpoints, хитром ушифрованием и так далее.
4049.42 4060.30 "Игорь Лабутин" То есть я так понимаю, что сделать чисто вызов метода через SOAP или через REST, оно более-менее одинаково и понятно, как одно в другое переводить.
4060.30 4077.82 "Игорь Лабутин" Но как только дело доходит до всякой security и вот этого всего вокруг, транзакции, транспорта и опять же разные, то сразу становится тяжело и непонятно, как это вообще ложится, потому что многие протоколы, ну тут для gRPC да, это что-то P2, там в принципе один вид security, это транспортная security.
4077.82 4081.34 "Игорь Лабутин" А у нас, например, в проекте использовался message security одно время.
4081.34 4083.90 "Игорь Лабутин" Как такое делать, не очень понятно.
4083.90 4085.78 "Анатолий Кулаков" Да, да, ты прав.
4085.78 4090.26 "Анатолий Кулаков" Ладно, у меня есть тема, которая готова поддержать твое Legacy уныние.
4090.26 4093.18 "Анатолий Кулаков" Я сейчас говорю про Libman.
4093.18 4102.06 "Анатолий Кулаков" И в качестве, ну в общем, обычно нормальным разработчикам с JavaScript сталкиваться не приходится.
4102.06 4113.70 "Анатолий Кулаков" Но, к сожалению, Blazor и всякие Mayui, они еще далеко от нас, поэтому иногда с миром, адом Legacy JavaScript сталкиваться все-таки приходится.
4113.70 4138.50 "Анатолий Кулаков" Вот, и если мы говорим, что нам хочется каким-то образом получить какой-то стандартный project dependency, по package dependency подход, такой, как мы привыкли видеть в нашем Nuget, то как только вы переходите в этот Ata Israel под названием JavaScript, package dependency, там становится все с ног на голову и волосы становятся дыбом.
4138.50 4167.94 "Анатолий Кулаков" То есть на вас наваливается куча каких-то непонятных NPM, YARM, GULP, GRUNT, Webpack, Parcel, Avrolap и еще тысячи всяких менеджеров зависимости, которые не просто менеджеры зависимости, а с какими-то магическими пайплайнами, конвертерами, оптимайзерами и прочими глупостями, что невольно начинаешь скучать по своему стандартному Nuget, который простой, понятный, работает и один на всех.
4167.94 4178.94 "Анатолий Кулаков" И как раз-таки, чтобы решить эту проблему, Microsoft выпустил замечательную утилитку, замечательный инструмент, который называется Library Manager, сокращенно Libman.
4178.94 4187.26 "Анатолий Кулаков" И это облегченный инструмент для того, чтобы собирать client-site dependency, то есть по сути JavaScript dependency.
4187.26 4198.30 "Анатолий Кулаков" Все, что он делает, это просто-напросто инсталирует пакеты, третисторонние пакеты к вам в ваш репозиторий, к вам в ваш проект.
4198.30 4216.94 "Анатолий Кулаков" И, соответственно, это не какой-то сложный большой комбайн, он работает только с уже какими-то финальными артефактами, то есть то, что не надо как-то билдить, как-то собирать, каким-то образом еще компилировать, то, что любят многие делать UI-ные фреймворки.
4216.94 4232.10 "Анатолий Кулаков" А вот если у вам уже что-то есть, уже конкретная библиотека есть, например, тот же самый Bootstrap, jQuery, Vue, D3, в общем, стандартные нормальные фреймворки, которые выпускают свои пакеты, которые можно уже достать в виде финальных артефактов, вот он работает только с ними.
4232.10 4237.70 "Анатолий Кулаков" Соответственно, он их заберет и положит туда в вашем проекте, куда это нужно.
4237.70 4244.22 "Анатолий Кулаков" Он работает с множеством популярных CDN, JavaScript библиотек, то есть там не один какой-то хостинг этих пакетов, а их множество.
4244.22 4247.10 "Анатолий Кулаков" Вот Libman поддерживает многие из них.
4247.10 4253.86 "Анатолий Кулаков" И, соответственно, просто-напросто достает из CDN пакет, складывает в ту директорию, которую скажете.
4253.86 4263.84 "Анатолий Кулаков" Как я уже сказал, у него нет каких-то встроенных фич по компилированию, транспилированию и прочей глупостями, которые очень любят гордиться всякие JavaScript пакеры.
4263.84 4268.56 "Анатолий Кулаков" Поэтому это не замена таким мощным средством, как Webpack, Rollup или Parcel.
4268.56 4279.48 "Анатолий Кулаков" То есть он не может их реплейсить, поэтому если вы какой-то пораженный UI-щик, который любит собирать модульные эти фронтенды, то, соответственно, это инструмент не для вас.
4279.48 4290.36 "Анатолий Кулаков" Но если вы бэкендер, которому нужно всего лишь навсего затащить Bootstrap и обновить Vue, и скачать, то есть проинсталлировать D3, то вот это вот именно инструмент для вас.
4290.36 4293.92 "Анатолий Кулаков" И не загоняться на все вот эти глупости.
4293.92 4305.52 "Анатолий Кулаков" То есть это очень просто, очень понятно и хорошо вписывается в концепцию того, что должен делать настоящий инструмент поддержки зависимости, инсталляции и обновления зависимости.
4305.52 4308.92 "Анатолий Кулаков" Так, а давайте пробежимся по основным фичам.
4308.92 4315.48 "Анатолий Кулаков" Соответственно, как я уже упомянул, множество CDN-ов поддерживается, то есть, скорее всего, ваш пакет найдется и куда он не денется.
4315.48 4326.32 "Анатолий Кулаков" Можно инсталлировать пакеты не только из известных JavaScript-репозиториев, JavaScript-CDN-ов, но также и из файловой системы, из какой-то Network-шары или просто затянуть по URL.
4326.32 4337.12 "Анатолий Кулаков" И, соответственно, он не тащит каких-то кучу зависимостей, из которых было это все скомпилировано, кучу левых ненужных артефактов, каких-то символов, еще какой-то глупости.
4337.12 4340.40 "Анатолий Кулаков" Он вам складывает только то, что вам нужно, чисто, минимально и красиво.
4340.40 4346.28 "Анатолий Кулаков" И, соответственно, можете инсталлировать любую папочку, куда вы скажете, прямо куда вы настроите.
4346.28 4349.68 "Анатолий Кулаков" Разные пакеты могут настраиваться в разные директории, складываться.
4349.68 4352.44 "Анатолий Кулаков" Он очень быстрый и он написан на C#.
4352.44 4355.76 "Анатолий Кулаков" Наверное, это одна из тех причин, почему я это рассказываю.
4355.76 4364.76 "Анатолий Кулаков" То есть, это прекрасный инструмент, который написан на C# и работает просто чрезвычайно быстро, особенно если мы будем сравнивать с вот этими JavaScript-овым адом.
4364.76 4371.52 "Анатолий Кулаков" Также из фишек он полностью интегрирован в Visual Studio, начиная от 2017-й.
4371.52 4378.76 "Анатолий Кулаков" Также у него есть аддон для Visual Studio for Mac, что вообще, в принципе, поразительно, что такие аддоны вообще бывают.
4378.76 4386.48 "Анатолий Кулаков" Ну и самое главное, он доступен в виде инструмента командной строки для .NET Tool.
4386.48 4389.04 "Анатолий Кулаков" Использовать его чрезвычайно просто.
4389.04 4392.40 "Анатолий Кулаков" Самый легкий способ — это как раз-таки через .NET Global Tool.
4392.40 4397.92 "Анатолий Кулаков" Инсталируем пакет, который называется Microsoft Web Library Manager CLI.
4397.92 4406.48 "Анатолий Кулаков" Далее делаем libman init, и, соответственно, он позволяет пронициализировать тот проект, где он будет орудовать со всеми зависимостями.
4406.48 4412.08 "Анатолий Кулаков" По умолчанию используется папочка /lib, туда будут складываться абсолютно все.
4412.08 4417.60 "Анатолий Кулаков" И основные зависимости, то есть все свои зависимости, которыми он управляет, он будет хранить в файлике libman.json.
4417.60 4419.72 "Анатолий Кулаков" Это обычный JSON-файл.
4419.72 4432.24 "Анатолий Кулаков" Прекрасно то, что в нем есть IntelliSense, у него есть специальная подсветка, у него даже есть QuickFixes с помощью которых вы можете пакеты обновлять, вставлять, еще с ними какую-то магию творить.
4432.24 4435.36 "Анатолий Кулаков" Также вы можете задекларировать C&N, которые вы хотите поддерживать.
4435.36 4436.96 "Анатолий Кулаков" Все в одном файлике.
4436.96 4440.68 "Анатолий Кулаков" И понятные команды libman install, libman update.
4440.68 4446.08 "Анатолий Кулаков" Соответственно, можно управлять зависимостями пакетов без всяких заморочек.
4446.08 4456.24 "Анатолий Кулаков" Почему-то в этом жутком мире JavaScript принято ассеты, то есть вот эти пакеты, которые вы заинсталировали, прямо вот эти пакеты, там куча миллиардов зависимостей обычно у них бывает.
4456.24 4459.44 "Анатолий Кулаков" Их принято засовывать в source control.
4459.44 4461.16 "Анатолий Кулаков" Звучит это как полная дичь.
4461.16 4475.44 "Анатолий Кулаков" И так как эту утилиту писали люди нормальные на C#, они поняли, что альтернативный подход этому миру тоже нужен и они сделали поддержку восстановления этих зависимостей во время билда.
4475.44 4477.56 "Анатолий Кулаков" То есть то же самое, что мы творим с Nuget.
4477.56 4485.00 "Анатолий Кулаков" Вы просто заливаете файлик, в котором описаны все пакеты, но все эти пакеты заливать не нужно, не обязательно, даже вредно.
4485.00 4491.88 "Анатолий Кулаков" А эти пакеты будут восстановлены автоматически во время билда, если вдруг почему-то их у вас еще нет.
4491.88 4498.12 "Анатолий Кулаков" Вот это тоже делается с помощью дополнительного пакета, который вы ставите, library-manager-build, и все.
4498.12 4501.84 "Анатолий Кулаков" И, соответственно, при каждом билде, если у вас этих пакетов нет, они восстанавливаются.
4501.84 4507.76 "Анатолий Кулаков" Если есть, они берутся из кэша, соответственно, время на скачивание и восстановление не тратится, и все счастливы.
4507.76 4526.60 "Анатолий Кулаков" Вот такой легкий инструмент, если вам нужно управлять зависимостями, которые нужны фронтенду, и если вам не хочется сталкиваться и изучать огромные, мастрозные инструменты, специализированные, большие, официальные для этого, которые любят сами фронтенщики.
4526.60 4536.84 "Анатолий Кулаков" Ну, если вы сам фронтенщик, и вам для каких-то мелких проектов, может быть, нужно собирать и обновлять зависимости, может быть, вам тоже этот инструмент будет полезен.
4536.84 4560.24 "Анатолий Кулаков" В принципе, Microsoft его рекомендует не только как каким-то бэкендером, который вы должны гонять, который вы должны сталкиваться с этим миром и гонять все эти пакетики туда-сюда, как я для себя его открыл, а на официальном сайте это в принципе подается как более-менее нормальный, лайтовый пакет-менеджер, но с естественным подчеркиванием того, что он не заменит больших комбайнов.
4560.24 4561.40 "Анатолий Кулаков" Вот такая полезная утилитка.
4561.40 4562.40 "Анатолий Кулаков" Прекрасно.
4562.40 4569.20 "Игорь Лабутин" Я не сильно работаю с фронтом, но если меня вдруг потребуется, я обязательно попользуюсь.
4569.20 4570.56 "Игорь Лабутин" Пойдем дальше по утилиткам.
4570.56 4584.48 "Игорь Лабутин" По либам точнее, в данном случае мы когда-то давно упоминали про такую либу как YARP, а в этот раз хочется упомянуть ее снова, потому что вышла версия 1.1.
4584.48 4589.52 "Игорь Лабутин" Напомню, что YARP — это специальная либа от команды Microsoft для построения Reverse Proxy.
4589.52 4599.28 "Игорь Лабутин" Это не сама Reverse Proxy, это не как Nginx, но если вы хотите написать свою собственную Nginx, хотя бы его простенькую версию, то YARP — это то, что вам нужно.
4599.28 4608.00 "Игорь Лабутин" То есть это штука, которая работает поверх стандартного кистрела и сп.net core и умеет довольно оперативно и шустро раутить запросы куда-то дальше.
4608.00 4612.88 "Игорь Лабутин" Релиз 1.0 был в ноябре, это уже полгода назад примерно.
4612.88 4620.40 "Игорь Лабутин" В 1.1 с тех пор добавили довольно много улучшений, то есть мы много из этого касались, на самом деле.
4620.40 4634.72 "Игорь Лабутин" То есть всякие и Zero Byte Reads, и Multi-Value Header Matching, и HTTP3 Support — они все пролетели из, понятное дело, поддержки всего этого добавки стреля, и сделаны теперь нормально на YARP, тоже доступны.
4634.72 4654.32 "Игорь Лабутин" Кроме того, можно задавать несколько Configuration Sources, то есть если вы хотите, например, задать разные конфигурации для разных ваших кусочков Reverse Proxy в, допустим, разных файлах, а что-то добавить программно, то это все теперь можно объединить, и будет использоваться объединение этих конфигураций.
4654.32 4668.76 "Игорь Лабутин" Дальше есть такая штука под названием HTTPS Delegation, то есть если какая-то обработка есть в драйвере HTTP Sys, то он теперь умеет отдавать ему на откуп и раутинг тоже, как я понимаю, что еще больше ускоряет.
4668.76 4684.88 "Игорь Лабутин" Важное изменение, если вы зачем-то хотите модифицировать вот те самые рауты, которые вы сконфигурили через конфигурацию в рантайме, то у вас теперь есть API, то есть вы теперь можете посмотреть на реквест и как-то подкрутить, куда он там раутится в динамике прямо во время реквеста.
4684.88 4688.68 "Игорь Лабутин" Ну и довольно сильно улучшилась документация.
4688.68 4727.60 "Игорь Лабутин" Поэтому если вы рассматриваете, что вам нужен, например, какой-то простенький реверс-прокси, ну я не говорю здесь API Gateway, хотя почему нет, API Gateway тоже в принципе пишется на тех же технологиях, и вы хотите использовать .NET, а не использовать какие-то готовые тулы, например, Nginx или что-то подобное, то посмотрите на библиотечку YARP, мы в принципе используем ее довольно активно у себя в работе, и она, ну у нас нет больших нагрузок, она в основном для всяких таких девелопментных задач используется, но в целом все довольно легко и просто, легко конфигурится, легко пишется, так что в качестве такого простого реверс-прокси она вполне замечательно работает.
4727.60 4731.36 "Анатолий Кулаков" Да, хорошенький проект, согласен с такмой.
4731.36 4736.52 "Анатолий Кулаков" Так, я еще нашел интересную статейку про довольно забавную тему.
4736.52 4743.44 "Анатолий Кулаков" Автор предлагает нам задуматься о том, а почему мы не используем HTTPS в нашей девелопмент-связи.
4743.44 4747.24 "Анатолий Кулаков" Вот ты как думаешь, нам HTTPS в девелопменте нужен
4747.24 4770.28 "Игорь Лабутин" или нет? Слушай, у меня на самом деле используется, по некоторым end-point, так скажем, просто по привычке, потому что ну так сложилось, а в некоторых случаях у нас он был, я вот сейчас что-то не могу сказать почему, но почему-то я помню, что он был обязательным, и мы без HTTPS вообще не могли работать.
4770.28 4778.40 "Игорь Лабутин" То ли клиент у нас был очень сильно привередливый и хотел только HTTPS, то ли еще что-то, и поэтому приходилось работать в девелопменте тоже со HTTPS.
4778.40 4785.00 "Игорь Лабутин" Ну, что там, сгенерил сертификатик себе и все, никаких особых проблем нет, ты сам себе доверяешь и все.
4785.00 4799.28 "Анатолий Кулаков" Тут наверное основной вопрос в принципе зачем, потому что у тебя HTTPS это протокол, который тебе гарантирует прежде всего достоверность, что ты общаешься с тем узлом, с которым прописан сертификат, и во-вторых шифрованием трафика.
4799.28 4808.28 "Анатолий Кулаков" Естественно, когда ты разрабатываешь какой-то сервис, тебе о достоверности наплевать, ты среди своих же сервисов общаешься, и шифрования тебе тоже не нужно, тебе там прятаться не от кого.
4808.28 4810.60 "Анатолий Кулаков" То есть тут вопрос возникает, а зачем?
4810.60 4830.80 "Игорь Лабутин" Ну не знаю, ну как бы он не добавляет сильно ничего плохого, ну то есть сертификат сгенерен, он висит на этом порту и готов, и он же добавлен в доверенный у меня же на компе, и как бы ASP.NET Core позволяет довольно легко выставить все, и как HTTPS, поэтому оно просто работает.
4830.80 4840.68 "Игорь Лабутин" Я на самом деле последний, вот несколько там маленьких проектов, которые начинал, я просто даже не задумываюсь это HTTP или HTTPS, оно просто работает, в этом смысле это все очень здорово.
4840.68 4856.84 "Анатолий Кулаков" Ну вот не скажи, это у тебя там сертификат сгенерен, зарегистрировал и так далее, а если вдруг теперь твой проект захочет запустить, допустим, тестер на своем компьютере, у него этого сертификата нет, у него ничего не зарегистрировано, ему нужно как-то настраивать, это уже лишние какие-то проблемы.
4856.84 4863.76 "Игорь Лабутин" Ну, у нас тестеры обычно делают News of Science сертификат в PowerShell, так что они-то как раз сделают.
4863.76 4870.72 "Игорь Лабутин" Но нет, да, я согласен с тобой, что, конечно, в целом проще, когда оно все пасет HTTP, вот, тут вопросов нет.
4870.72 4886.20 "Анатолий Кулаков" Ну ладно, давай теперь попробуем разобраться вместе с автором, а зачем же все-таки нам это может быть нужно, и может быть нашим слушателям тоже, которые никогда не задумывались, а для чего им шифровать трафик во время разработки, в общем, может быть, это тоже будет интересно, поэтому давайте поговорим.
4886.20 4888.20 "Анатолий Кулаков" Итак, начнем сначала.
4888.20 4894.28 "Анатолий Кулаков" Прежде всего HTTPS – это протокол, который, в принципе, в продакшене уже ни у кого не вызывает никаких вопросов.
4894.28 4907.80 "Анатолий Кулаков" Для обычных веб-сайтов, для публичных веб-сайтов, для продакшен API все работает по HTTPS, и это нормально, потому что именно HTTPS обеспечивает нам доверенность и защиту, и секьюрность.
4907.80 4918.88 "Анатолий Кулаков" И, соответственно, главные фишки HTTPS, как я уже упомянул, это гарантировать, что мы общаемся с тем узлом, с которым мы хотим общаться, что его не подменили, и шифровать трафик.
4918.88 4929.44 "Анатолий Кулаков" И в разработческой среде обычно разработчики всего этого не хотят, им это не нужно, поэтому они просто не заморачиваются, то есть по дефолту HTTPS не включен.
4929.44 4938.24 "Анатолий Кулаков" Обычно у нас на разработчиком Environment TE никто не загоняется установкой всяких этих сертификатов и установкой шифрования, потому что не нужно.
4938.24 4947.80 "Анатолий Кулаков" И, соответственно, давайте подумаем, а может все-таки нужно, может быть все-таки есть проблемы, которые решаются, когда мы используем HTTPS при разработке тоже.
4947.80 4960.80 "Анатолий Кулаков" И, наверное, самая главная причина – это равенство сред, на которые мы деплоим, то есть равенство продакшена и равенства дев-среды.
4960.80 4972.60 "Анатолий Кулаков" Это довольно старое утверждение, оно даже встречается в 12-факторных приложениях, то есть это те принципы, которые рекомендуются для приложений, чтобы они начали работать в клауде.
4972.60 4980.64 "Анатолий Кулаков" Эти принципы были выработаны довольно давно, только когда клауды зарождались для того, чтобы ваши приложения каким-то образом лучше к ним подходили.
4980.64 4986.56 "Анатолий Кулаков" И даже там есть эта штука, которая называется Environment Parity.
4986.56 4992.48 "Анатолий Кулаков" Соответственно, очень важно держать вашу дев-среду и продакшн-среду одинаковыми.
4992.48 5001.16 "Анатолий Кулаков" Это позволяет вам убрать кучу различных ошибок, которые вы могли бы встретить в продакшене, но при этом бы в деве никогда их не встретили.
5001.16 5009.28 "Анатолий Кулаков" В общем, чтобы таких глупостей не было, чтобы у вас ошибки более или менее были одинаковыми там и там, среды нужно держать, соответственно, тоже одинаковыми.
5009.28 5016.68 "Анатолий Кулаков" И как раз-таки использование одного и того же протокола – это довольно-таки весомый аргумент в одинаковость сред.
5016.68 5030.24 "Анатолий Кулаков" Потому что отсутствие HTTPS может сказываться абсолютно на поведении вашего браузера или вашего клиента, который к вам ходит по HTTPS или по HTTP.
5030.24 5043.68 "Анатолий Кулаков" Допустим, очень легко клиенты, особенно браузеры, могут отказываться от загрузки ресурсов, если, допустим, они зашли на HTTPS-сайт, а в это время этот сайт использует HTTP-ресурсы.
5043.68 5056.96 "Анатолий Кулаков" В общем, есть специальные правила, которые говорят, что если вы на безопасном сайте, то есть на HTTPS, не надо загружать те ресурсы, которые потенциально на опасных сайтах, то есть на сайтах, которые доступны по HTTP.
5056.96 5067.88 "Анатолий Кулаков" Соответственно, эти ресурсы просто будут проигнорированы и все, и вы об этом никогда не узнаете до тех пор, пока не начнете тестировать там на продакшене или на площадке, которая более-менее совместима с продакшеном.
5067.88 5079.32 "Анатолий Кулаков" Вот, соответственно, такие ограничения, они сделаны для того, чтобы понизить вероятность даунгрейда HTTPS до протокола HTTP.
5079.32 5081.56 "Анатолий Кулаков" Есть такие своеобразные атаки тоже.
5081.56 5087.88 "Анатолий Кулаков" И, соответственно, давайте немножко ближе разберемся с вот этой атакой, когда мы даунгрейдим HTTPS пониже.
5087.88 5116.40 "Анатолий Кулаков" И, соответственно, у нас есть специальные атрибуты, из специальной технологии, которая называется Content Security Policy, которая как раз-таки позволяет избавиться от подобных атак, а так, когда у нас смешан контент с секьюрными и несекьюрными ресурсами, и, соответственно, помогает уменьшить вот эту площадку, площадку для атаки, позволяет уменьшить вот эти вот ресурсы, через которые ваш сайт может быть уязвим.
5116.40 5132.72 "Анатолий Кулаков" И, соответственно, защищая ваши ресурсы с помощью Content Security Policy, возможно, уменьшить вероятность того, что ваш протокол будет понижен с HTTPS на HTTP.
5132.72 5141.84 "Анатолий Кулаков" И, соответственно, если он не будет понижен, то, соответственно, у нас уже не будет каких-то там атак того же, допустим, того же самого man-in-the-middle провести будет гораздо сложнее или даже невозможно.
5141.84 5151.16 "Анатолий Кулаков" И, соответственно, вот этот протокол, вот эти договоренности, вот эти атрибуты Content Security Policy, они не работают с HTTP.
5151.16 5164.40 "Анатолий Кулаков" Вот такой интересный случай, что вы можете напороться на то, что у вас на одной площадке это будет работать, а на второй точно такой же площадке с точно такими же API-ами, библиотеками и версиями оно работать не будет, только потому что у вас не настроено HTTPS.
5164.40 5168.24 "Анатолий Кулаков" Также, зачем нам еще нужен может быть HTTPS?
5168.24 5178.56 "Анатолий Кулаков" Многие современные фичи в браузерах, например, они работают только с HTTPS, например, ServiceWorker, например, Security Cookie, например, Prefixed Cookie.
5178.56 5181.56 "Анатолий Кулаков" В общем, для них, для всех требуется именно HTTPS.
5181.56 5188.28 "Анатолий Кулаков" Без этого они работать не будут и, как в предыдущем случае, поведение на ваших сетях может различаться, если вы проигнорируете этот интересный факт.
5188.28 5205.00 "Анатолий Кулаков" Еще одна прекрасная неочевидная штука заключается в том, что некоторые браузеры позволяют вам работать с Localhost или с IP-адресом 127.0.0.1 очень специальным образом.
5205.00 5212.44 "Анатолий Кулаков" Они позволяют игнорировать некоторые принципы, например, те же самые Security Cookie, которые не будут у вас никогда работать с HTTP.
5212.44 5218.48 "Анатолий Кулаков" Это правило игнорируется, если вы вдруг заходите на свой сайт под Localhost или под 127.0.0.1.
5218.48 5225.92 "Анатолий Кулаков" То есть, если вы даже заходите на HTTP Localhost, то Security Cookie в некоторых случаях у вас прекрасно работает.
5225.92 5245.60 "Анатолий Кулаков" Вот именно с такой проблемой я недавно столкнулся, настраивая Identity Service, потому что тоже изначально в Identity Service я не подключал HTTPS, не подключал никаких сертификатов, все прекрасно настроило, у меня все прекрасно работает на Localhost, и как только я его задеплойил на Staging, начал тестировать там, и вдруг внезапно все отвалилось.
5245.60 5254.76 "Анатолий Кулаков" Сети не принимаются, гип снимают, клиент уезжает, вообще непонятно, как это диагностировать, почему это не работает, и в логах ничего не понятно.
5254.76 5262.60 "Анатолий Кулаков" В общем, вот это банальная ошибка, что некоторые браузеры вам под Localhost ведут себя не так, как обычно.
5262.60 5264.84 "Анатолий Кулаков" Даже не только браузеры, но и серверы тоже.
5264.84 5274.64 "Анатолий Кулаков" То есть, у многих серверов тоже стоит вот такой вот хук, что для Localhost там можно в принципе HTTP, а потом в будущем кто-нибудь там настроит HTTPS.
5274.64 5281.08 "Анатолий Кулаков" Это такая очень полезная для разработчиков фишка, но она может помочь выстелить себе в ногу.
5281.08 5282.60 "Анатолий Кулаков" Поэтому тоже с этим будьте внимательны.
5282.60 5287.24 "Анатолий Кулаков" Так, следующая фишка, почему вам может понадобиться шифрованный протокол.
5287.24 5311.92 "Анатолий Кулаков" Это если вы все-таки не можете использовать Localhost из 127.0.0.1 в своем приложении, а по каким-то особым причинам вам нужно использовать какой-то custom-хост, то есть это обязательно должен быть какой-нибудь myhost.dev или myapplication или что-то еще, то браузер не будет считать этот сайт, соответственно, безопасным, потому что исключение бывает только для Localhost.
5311.92 5325.80 "Анатолий Кулаков" Если вам какой-то вы используете, соответственно, сторонний домен, но вы у себя его прописали и он мапится на ваш локальный адрес, то это, соответственно, браузерами не будет считаться секьюрно, и многие протоколы и фичи, соответственно, работать там не будут.
5325.80 5332.12 "Анатолий Кулаков" Но, соответственно, это должно заработать, как только вы подключите сюда HTTPS.
5332.12 5333.12 "Анатолий Кулаков" Другие причины.
5333.12 5350.00 "Анатолий Кулаков" Из других причин автор отмечает, что если вы используете HTTP/2, допустим, который по умолчанию требует HTTPS, обязательно вам сюда, если вы используете то же самое gRPC, которое требует HTTP/2 или другие третий-сторонние библиотеки, которые обязательно требуют HTTPS, то, соответственно, у вас тоже ничего работать не будет.
5350.00 5362.12 "Анатолий Кулаков" И, соответственно, если вы надеетесь на то, что стартуете проект на HTTP, потом очень легко переключитесь на HTTPS попозже и никаких проблем вам это не доставит, то это тоже большое-большое заблуждение.
5362.12 5365.68 "Анатолий Кулаков" Вам может доставиться очень-очень куча больших интересных проблем.
5365.68 5376.52 "Анатолий Кулаков" В частности, есть отдельная ссылка на Stack Overflow, где там ребята как раз, сами Stack Exchangers приезжали с такого принципа и перезжали на HTTPS после разработки на HTTP.
5376.52 5382.20 "Анатолий Кулаков" В общем, они там столкнулись с кучей интересных веселых историй, в общем, кого есть время, почитайте.
5382.20 5390.00 "Анатолий Кулаков" И, соответственно, суммируя все эти выводы, можно сказать, что лучше всего начинать разрабатывать прямо сразу с HTTPS.
5390.00 5403.32 "Анатолий Кулаков" И, в принципе, точно так же по дефолту, как у нас уже по дефолту обычно на продакшене HTTPS везде включен, точно так же надо стараться уже локально разработчикам его у себя локально тоже включать на самом старте, на моменте прямо разработки.
5403.32 5413.16 "Анатолий Кулаков" Теперь давайте посмотрим, а как же все-таки настроить это, как у себя локально сделать HTTPS.
5413.16 5419.12 "Анатолий Кулаков" Прежде всего нужно знать, что HTTPS – это как раз-таки надстройка, это расширение протокола HTTP.
5419.12 5428.00 "Анатолий Кулаков" И, соответственно, там всего лишь навсего появляется отдельный слой шифрования, который называется Transport Layer Security, сокращенно TLS.
5428.00 5432.20 "Анатолий Кулаков" Это протокол для обмена шифрованными данными.
5432.20 5437.76 "Анатолий Кулаков" Этот протокол работает на концепции публичной криптографии, то есть паблики криптографии.
5437.76 5441.00 "Анатолий Кулаков" И, соответственно, у него есть приватный и публичный ключ.
5441.00 5452.24 "Анатолий Кулаков" И для того, чтобы, соответственно, вам настроить такое соединение, у вас у сервера должен быть специальный цифровой сертификат, который предоставляет публичный ключ.
5452.24 5467.68 "Анатолий Кулаков" И при каждом соединении, то есть когда браузер подключается к вашему сервису, он скачивает публичный ключ от сервиса и устанавливает как раз-таки доверенное соединение.
5467.68 5470.92 "Анатолий Кулаков" Но перед тем, как он это сделает, он проверяет несколько базовых концепций.
5470.92 5479.20 "Анатолий Кулаков" Например, что имя вашего домена, по которому работает ваш сервис, он совпадает с именем, которое задекларировано в сертификате.
5479.20 5485.08 "Анатолий Кулаков" Что у сертификата не заэкспарилось время его действия, то есть что он еще актуален.
5485.08 5497.04 "Анатолий Кулаков" И, соответственно, проверяет сертификат авторити, что этот сертификат действителен, что его выписал какой-то знатный доверенный центр, что этому сертификату можно доверять, и никто его не подменил.
5497.04 5508.88 "Анатолий Кулаков" Именно вся вот эта цепочка различных проверок и гарантирует то, что вы не можете каким-то образом подменить домен, не можете подделать сертификат, не можете сделать просто main and middle.
5508.88 5513.48 "Анатолий Кулаков" И вот эти базовые концепции, к которым мы все с вами уже давно, в принципе, привыкли.
5513.48 5524.18 "Анатолий Кулаков" После этого устанавливается шифрование, и весь трафик проходит между клиентом и сервером через шифрованный канал.
5524.18 5530.94 "Анатолий Кулаков" Соответственно, в продакшене вам нужен настоящий сертификат авторити, то есть настоящий центр, который выписал вам сертификат.
5530.94 5535.94 "Анатолий Кулаков" Сейчас очень много, например, пользуются опенсорсные проекты, пользуются Let's Encrypt.
5535.94 5538.02 "Анатолий Кулаков" Да, в принципе, не только опенсорсные проекты.
5538.02 5545.22 "Анатолий Кулаков" В общем, Let's Encrypt сделал здесь большую революцию, именно благодаря ему у нас как бы сейчас CTPS практически на всех сайтах.
5545.22 5548.42 "Анатолий Кулаков" До Let's Encrypt с этим было все довольно плачевно.
5548.42 5553.10 "Анатолий Кулаков" В разработчика среде вам, соответственно, настоящий сертификат не нужен.
5553.10 5564.34 "Анатолий Кулаков" В общем, заморачиваться с ним можно не обязательно, потому что есть такое понятие как self-signed сертификаты, то есть сертификаты, которые вы сами себе сгенерировали, сами себе подписали и сами себе доверяете.
5564.34 5567.50 "Анатолий Кулаков" Сгенерировать такой сертификат достаточно просто.
5567.50 5572.10 "Анатолий Кулаков" Очень много уже инструментов вокруг этой инфраструктуры есть.
5572.10 5575.74 "Анатолий Кулаков" Прежде всего, самый популярный и самый мощный – это OpenSSL.
5575.74 5581.34 "Анатолий Кулаков" Но чтобы там сгенерировать сертификаты, вам нужна ученая степень, ну или с такой коврой слова, неважно.
5581.34 5588.26 "Анатолий Кулаков" Но более такой нативный для разработчиков, для C-Sharper – это все-таки для .NET DevSert.
5588.26 5598.14 "Анатолий Кулаков" Это Global Tool Utility, которая позволяет вам сгенерировать self-signed сертификат у себя локально, а также его там заинсталлировать, доверить ему и, соответственно, подключить.
5598.14 5609.90 "Анатолий Кулаков" Если для удаленных компов или для администраторов или для скриптования еще может быть полезен Command Let на PowerShell, который называется New Self-Signed Certificate.
5609.90 5621.10 "Анатолий Кулаков" Также в этом модуле для PowerShell можно легко найти специальные команды для экспорта приватного ключа и шифрования для тестирования.
5621.10 5622.74 "Анатолий Кулаков" В общем, все, чтобы поработать с сертификатами.
5622.74 5626.38 "Анатолий Кулаков" В PowerShell отличный огромный пакет.
5626.38 5631.70 "Анатолий Кулаков" PowerShell плавненько и прекрасно подготовился.
5631.70 5634.10 "Анатолий Кулаков" У него очень много интересных инструментов есть.
5634.10 5641.26 "Анатолий Кулаков" Если же у вас под рукой нет .NET, нет PowerShell, то есть маленькая утилитка, которая называется MKSERVE.
5641.26 5652.54 "Анатолий Кулаков" Это хороший выбор для того, если вы хотите быстро сгенерировать self-signed сертификат и у вас никаких зависимостей под рукой нет.
5652.54 5654.14 "Анатолий Кулаков" Это тоже такая полезная маленькая утилитка.
5654.14 5657.98 "Анатолий Кулаков" Я думаю, этот набор отлично может покрыть все ваши кейсы.
5657.98 5662.50 "Анатолий Кулаков" Ну и, соответственно, очень легко это все настраивается в Kestrel, в S/P/NET.
5662.50 5672.90 "Анатолий Кулаков" Вы можете это настроить как из кода, вы можете настроить это из командной строки, вы можете даже прописать с помощью UserSecrets пароль к сертификату, если у вас запаролен сертификат.
5672.90 5676.74 "Анатолий Кулаков" В общем, все остальное – это уже мелочь и настраивается довольно легко.
5676.74 5686.86 "Анатолий Кулаков" Вот такое внушение, которое автор предлагает нам освоить и в будущем использовать HTTPS везде, даже в том числе на вашей девелопмент среде.
5686.86 5691.50 "Игорь Лабутин" Ну, в общем, как я и сказал, new self-signed certificate и поехали.
5691.50 5708.70 "Игорь Лабутин" Ну, в целом, да, S/P/NET Core позволяет все довольно легко все это дело использовать, как я сказал, поэтому да, как только у вас есть генерированный сертификат и скриптик, как это сделать, или инструкция, как это сделать для тестеров, чтобы запустить у себя, и все будет хорошо.
5708.70 5711.22 "Игорь Лабутин" На этом, я думаю, мы на сегодня закончим.
5711.22 5714.98 "Игорь Лабутин" Мы довольно много сегодня успели проговорить разных всяких утилиток.
5714.98 5720.94 "Игорь Лабутин" Начали мы с такой небольшой утилитки под названием .NET 7 Preview 4.
5720.94 5723.98 "Игорь Лабутин" Фреймворк наш зарелизился с очередным превью.
5723.98 5729.66 "Игорь Лабутин" Потихонечку идем к релизу, который уже всего через сколько, месяцев пять состоится.
5729.66 5732.42 "Игорь Лабутин" Половина пути пройдена практически.
5732.42 5737.50 "Игорь Лабутин" MAUI Release Candidate 3 с небольшим количеством изменений, в основном bug-фиксы.
5737.50 5749.26 "Игорь Лабутин" JRPC JSON Transcoding - это кусочек .NET 7 Preview 4, который позволяет экспозить ваши JRPC сервисы как JSON REST сервисы, практически автоматически.
5749.26 5763.58 "Игорь Лабутин" Visual Studio 2022 обновилось, появился нормальный стабильный релиз 17.2 финальный, появился 17.3 Preview 1, и Visual Studio for Mac появился релиз Candidate, там идет работа над стабилизацией.
5763.58 5771.86 "Игорь Лабутин" Кроме этого, мы почитали статью Andrew Locke про то, как генерировать Sortable GUIDы, стоит ли это делать вообще, на что обращать внимание.
5771.86 5794.42 "Игорь Лабутин" И посмотрели на набор различных тулов и библиотек, это Core WCF 1.0 зарезался, утилитка Libman для того, чтобы мейнтенить ваши фронтендерские зависимости, YARP для реверс-проксии версии 1.1 вышел, и обсудили вопрос, нужно ли нам использовать RTTPS в локальной разработке, если нужно, то зачем, как это сделать, как облегчить себе жизнь.
5794.42 5817.62 "Анатолий Кулаков" Ну что ж, хороший списочек, вроде много всего интересного успели, соответственно, если вам понравилось, ставьте там звездочки, подписывайтесь на колокольчики и прочие глупости тоже творите, потому что никто не поможет нам распространиться сильнее, чем ваши рекомендации, шары, репосты, в общем алгоритмы всяких рекомендательных систем обманываются только честными пятизвездочками и честными комментариями.
5817.62 5823.74 "Анатолий Кулаков" В общем, мы ждем ваших комментариев к нашему подкасту, и всячески будем их прислушиваться и придерживаться.
5823.74 5828.46 "Игорь Лабутин" И на этом все, это был 51 выпуск подкаста Radio.net, с
5828.46 5833.02 "Анатолий Кулаков" вами были Игорь Лабутин и Анатолий Кулаков, всем пока.
5833.02 5833.02 None Пока.
5833.02 5845.02 "Анатолий Кулаков" [музыка]
