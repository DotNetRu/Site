0.00 18.56 "Анатолий Кулаков" Здравствуйте, дорогие друзья. В эфире радио .NET выпуск номер 103. И в эфире его, ее, его, их, они. Короче, в эфире постоянный ведущий этого радио Анатолий Кулаков. И Игорь
18.56 24.72 "Игорь Лабутин" Лабутин. Всем привет от нас. Вас, нас, их. Вы вот давно не слышали, если уже слова стали
24.72 71.12 "Анатолий Кулаков" попутать. Так, и большое спасибо, конечно же, нашим главным помогаторам. Это Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей и Дмитрий Сорокин. Большое спасибо, друзья, всем, кто нам помогает. И благодаря вам мы можем выходить без всякой рекламы, за что вам отдельное большое спасибо. Ну что ж, давай посмотрим, что у нас сегодня есть интересного. В принципе, новостей у нас на сегодня не много, зато много интересных статейчик, которые у нас были в загашниках, а также что-то новое. Сравнимся с растом, померяем API, посмотрим бестпрактисы по эррорам. В общем,
71.12 89.32 "Игорь Лабутин" горячий выпуск ожидается. Да, действительно, новостей от Майкрософта особо нет. Так что сегодня разбираем одни сплошные статьи. Давай начнем с первой и вернемся немножко назад, наверное. Когда у нас 12 C# вышел? Сколько уже? Да я что-то уже после 10 перестал их считать.
89.32 94.40 "Игорь Лабутин" Я вот тоже что-то не помню, но по идее это год назад, Витя. Или какой сейчас вообще C# выходит,
94.40 99.16 "Анатолий Кулаков" 13-й, 14-й? Так, не пались, не пались, мы вообще это подкаст про C#, мы должны были все про это знать, так что…
99.16 106.84 "Игорь Лабутин" Ты настолько давно на Майкрософт ничего не выпускал, что мы уже забыли. Ладно, давай, рассказывай про Experimental Attribute. С другой стороны, видишь, он столько
106.84 110.16 "Анатолий Кулаков" навыпускал, что мы можем теперь последние два года обсуждать то, что было раньше.
110.16 296.28 "Анатолий Кулаков" Хочется немножко остановиться на Experimental Attribute, потому что у Мартина Беловью в блоге вышла замечательная статья. Небольшая, емкая, но, как всегда, практичная и интересная, как Мартин любит. Поэтому давайте же посмотрим, а что это за зверь и какую пользу на практике он нам может принести. Итак, напомню, что Experimental Attribute вышел в 12-м C#, так что, скорее всего, большинство из вас уже могут его использовать в своем коде, а давайте же посмотрим, а как вы его можете использовать. Ну, прежде всего, любой, кто писал библиотеки или фреймворки, или даже, можно сказать, компоненты, которые переиспользуются в другом коде, наверняка сталкивались с такой ситуацией, когда хочется написать какой-то метод или какой-то классик, или какой-то набор классиков, которые хочется пометить атрибутом Experimental. Что означало бы, типа, я вам даю это попробовать, но ничего не гарантирую. Оно может не работать, оно может бажить, но самое главное, в будущих версиях, так как я над этим куском экспериментирую, его API может кардинально меняться. Мы можем делать breaking changes, мы можем переименовывать, мы можем вообще удалить его к чертовой матери. В принципе, это тоже мы можем. И хочется, чтобы пользователь сознательно это понимал, и если вдруг он этот кусок заюзал, то он осознавал, что в будущем его, возможно, придется переписать тот код, который он заюзал, или вообще удалить его, или поискать альтернативы. В общем, он полностью подписывается под теми проблемами, которые у него будут в будущем. И это довольно нужная фича в языках. Например, некоторые языки уже давно встроены имеют. Например, язык Kotlin. В нем точно также с помощью специального атрибута возможно сообщить, что это экспериментальная фича, и если ты согласен на все риски, которые я выше озвучил, то явно согласись с этим. И как раз многие авторы библиотек хотят такую штуку. Вот почему очень важно поддержать ее на уровне языка, фреймворков, стандартных классов, потому что очень многим она нужна. Очень многие хотят добавлять экспериментальные фичи и иметь право на то, чтобы их поменять. Потому что как только они выпускают, допустим, какую-то фичу в релиз, они подписываются под семантическим версионированием, и на них накладываются и прочие такие негативные вещи, из-за которых они не могут развивать ту фичу, которую в принципе не планировали никому отдавать на такое уж прямое использование. Они хотели, чтобы какая-то может быть группа бета-тестеров для личного использования всего лишь на все поэкспериментировала, потестировала с этой функциональностью. И вот явного показания, что можно эту фичу пометить специальным атрибутом, его раньше не было. До тех пор, пока в 12 C# не появился экспериментальный атрибют. Итак, давайте представим себе примерчик. Есть, допустим, у нас какая-то библиотечка. В этой библиотечке есть классик и есть экспериментальный метод, которым мы хотим менять сигнатуру, как захотим, и вообще в будущем мы хотим удалить его, если вдруг нам не понравится то, как он себя в будущем поведет. Плохо себя вести будет. Так вот, чтобы декларировать это намерение нашим будущим пользователям, мы можем проаннотировать его с помощью специального experimental атрибута.
296.28 632.72 "Анатолий Кулаков" Специального атрибута, который нам как раз таки и укажет всем действующим лицам, которые его заюзают, что этот метод экспериментальный. В качестве параметра в экспериментальный атрибут нужно передать специальный диагностик ID. То есть, это строка, с помощью которой вы будете идентифицировать ошибку, связанную с тем, что кто-то заюзал ваш метод. Ну, допустим, в Visual Studio наверняка вы сталкивались с такими ошибками, как IDE 0.18 или CS 53, вот что-нибудь такое. Вот это и есть диагностика ID. То есть, какой-то сокращенный код и порядковый номер ошибки в этом сокращенном коде. Сокращенный код обычно указывает на инструмент, который проводил анализ, а номер ошибки уже идентифицирует конкретное предупреждение, конкретный анализ внутри этого инструмента. Итак, атрибут мы добавили на наш метод, и что же он, собственно, сделал? Сделан следующее. Как только ваш метод, неважно в библиотеке, или там в встроенном каком-то проекте, или в заринкованном проекте, в общем, ваш метод в любом виде заюзается кем-то еще, тут же компилятор вам кинет ошибку. То есть, вы не сможете скомпилировать такой код, который заюзает ваш этот экспериментальный метод. И компилятор человеческим языком вам скажет, что "внимание, вот этот метод, он типа только для ознакомления, он в будущем может быть изменен, он в будущем может быть удален, и если вы вдруг хотите его точно использовать, вы не ошиблись, ничего не попутали в здравом уме и твердой памяти, ну, то тогда подавите это сообщение об ошибке". И это сообщение довольно ясно дает понять, что вы на что-то подписываетесь, на что-то страшное. И если вы действительно осознаете, что вы делаете, вы можете сознательно эту ошибку подавить. И тогда у вас в коде явно будет написано, что вот, пожалуйста, такой-то человек заюзал экспериментальный метод, и он это понимает, потому что вот специальный код по подавлению этой ошибки, и он подписался под этим коммитом, грубо говоря. Вот, что очень хорошо, очень явно, очень понятно. Также в этот experimental attribute можно добавить параметр, который называется url-формат. Это специальная форма url, с помощью которой вы можете предоставить пользователю какую-то дополнительную информацию о том, почему случилась эта ошибка. Компилятор во время выдачи exception, он этот url отформатирует и передаст в output. То есть, пользователь может кликнуть по url, и на вашем сайте, допустим, вы можете разместить подробную информацию, что же в этом случае надо делать или как правильно использовать ваш компонент. Также experimental attribute работает не только над классом, но и для целой сборки. Поэтому вы можете пометить сборку как экспериментальную и распространять ее на все четыре стороны. Итак, давайте немножко подробнее поговорим про подавление, про избавление от этой ошибки. То есть, мы метод прекрасный написали, attribute нормальный повесили, но что с ним делать, если компилятор не хочет компилировать ваш код? Кому нужен такой метод? Вся задача компилятора - лишь предупредить вас о том, чтобы вы сознательно сделали свой выбор. Допустим, вы свой выбор сделали сознательно. Какие у вас есть варианты? Вариант первый - вы сами пишите экспериментальный код и сами понимаете, что ваш код тоже будет меняться, тоже будет экспериментальным, он может в будущем удалиться, и вы полностью это осознаете. Тогда самый правильный вариант - это пометить ваш метод тоже этим experimental attribute. Как только вы это пометили, то компилятор уже выдаст ошибку тому, кто заюзает ваш метод. Итак, по цепочке до самого последнего метода, пока кто-то не сознается, что все, я или корневой метод, и сознательно использую целую иерархию нерадивых экспериментальных кусков, или одно из двух. Следующий шаг, то есть вы дошли до какого-то рутового элемента, или вы уже здесь понимаете, что вы используете экспериментальный метод, и вы с этим согласны, вы можете подавить это исключение, как предлагал компилятор. Подавить можно двумя способами - это прописать в project-файле специальный элемент no_warn, указав в качестве значения тот самый Diagnostic ID, который мы обсуждали, или можно же непосредственно подавить прямо в коде с помощью pragma_warning_disable и указав ему точно так же ваш Diagnostic ID. Наверняка такие подавления у вас уже есть, то есть какие-то варнинги вы, наверное, подавливали, какие-то прагмы вы, наверное, использовали, поэтому синтаксис привычный, стандартный для языка C#, ничего нового здесь нет. Что же делать, если у вас вдруг старый фреймворк, а не такой новый, красивый, который есть экспериментальный атрибют? Вы можете использовать атрибут, который уже давным-давно есть в дотнет-фреймворке, еще даже в старых больших дотнет-фреймворках он был, который называется Absolute Attribute, и он почти совпадает по своей функциональности, поэтому если немножко прижмуриться, закрыть глаза, то вполне можно его завязать на этом этапе до тех пор, пока вы не обновитесь. И даже начиная с дотнет-шестого, у нашего старенького Absolute Attribute появилось такое свойство ненавязчее, которое называется Diagnostic ID. Зная это Diagnostic ID, вы можете подавить конкретный Absolute, при этом не подавляя все Абсолюты, а в нашем случае вы можете использовать его точно так, как мы обсуждали в случае с Experimental Attribute. Вот такие забавные атрибуты предоставляет наш фреймворк для того, чтобы разрабатывать в библиотеке можно было более уверенно и не опасаясь за какой-нибудь шейминг и буллинг со стороны тех, кто заюзает ваши экспериментальные
632.72 656.72 "Игорь Лабутин" методы. Ну, шейминг они все равно смогут, потому что поменял каким-то атрибутам и с ним ничего не компилируется, пока прагмы не добавишь. Но действительно позволяет. Абсолютить тоже, в принципе, нормально. Я Абсолютами точно пользовался, вот Эксперименталам еще не довелось ни разу. Надо будет что-нибудь запилить такое экспериментальное внутри продакшен-кодовой базы. Да-да,
656.72 660.76 "Анатолий Кулаков" внутри своей же библиотеки самому же заюзать и самому на продакшене же его подавить. Да-да. Нет,
660.76 671.08 "Игорь Лабутин" я заюзаю в какой-нибудь библиотеке, а команда потом пусть думает, что с этим делать, и ищет погиб репозиторию, кто же это закоммитил. Ну ладно. Все равно же это твой код. Все равно,
671.08 687.64 "Анатолий Кулаков" мне кажется, Экспериментал атрибут, он больше для каких-то библиотек, которые ты распространяешь среди кого-то. В своих наших больших Enterprise приложениях использовать Эксперименталы. Не, ну почему, если у тебя много команд, да, ты делаешь какую-нибудь коммунальную библиотеку и хочешь там что-нибудь поделать, поэкспериментировать, то остальным командам ты, наверное, хочешь сказать,
687.64 697.60 "Игорь Лабутин" что... Не трогайте это, не надо пока это трогать, например, потому что я это использую в каком-нибудь своем одном продукте, там я знаю и подконтрольно включаю Экспериментал флаг, а остальные пока
697.60 705.92 "Анатолий Кулаков" не трогайте. Да, там ты, например, отладишь, опробуешь, месяцок погоняешь на продакшене, а потом может разрешишь всем остальным. Нормальный риск есть. Да-да. Пользуйтесь.
705.92 732.48 "Игорь Лабутин" Так, пойдем дальше. Дальше у нас интересная статья. Она не то чтобы супер свежая, она была обновлена некоторое время назад, поэтому мы к ней вернулись, точнее, заново ее нашли, я бы так сказал. Она про сравнение RASTA и C#. Но не просто сравнение языков таковых. Понятно, что их не то чтобы правильно, наверное, сравнивать друг с другом, потому что они немножко, вероятно, для разного сделаны. Потому что C# в любом случае победит.
732.48 771.92 "Игорь Лабутин" Да, RASTA это больше как такой типа безопасный C, да, позиционируется. Ну, в основном, как мне кажется, его позиционируют как для такого типа. Очень безопасный, но достаточно low-level разработки при этом. Но в RASTA есть штука, ну, наверное, первое, что приходит в голову, когда говорим RASTA, это, соответственно, borrow-checker так называемый. То есть всяческая разная проверка lifetime в компиляторах на тему того, чтобы вы там правильно работали со ссылками на те или иные объекты, правильно их передавали туда-сюда, мутировали только в нужных местах, и вот это все. И казалось бы… Ну, я же правильно понимаю, что это страдание языков,
771.92 774.28 "Анатолий Кулаков" у которых нет garbage-компилятора? Коллектора.
774.28 779.08 "Анатолий Кулаков" О, garbage-коллектора, да. Когда нужно там вручную считать ссылки, контролировать,
779.08 915.52 "Игорь Лабутин" кому они нужны, кому еще не нужны. Ну, на самом деле это можно делать и в языках с garbage-коллектором, никто не мешает тебе точно так же сделать такую же, в принципе, в теории проверку и в C#, просто непонятно зачем. Это лишнее усложнение, которое действительно в языках с garbage-collection немножко, ну, вообще говоря, не требуется. Хотя некоторые фичи… Ну, то есть, как мы как раз увидим, в принципе, C# движется немножко, по мнению автора статьи, забегая вперед, можно сказать, что, по его мнению, и C#, и RASTA двигаются, на самом деле, примерно в одном и том же направлении, только RASTA двигается из разряда low-level языков, но давайте мы попробуем сделать хоть как-то удобно писать безопасный код, а в C# скорее подход, давайте сделаем на нашем безопасном языке удобно писать low-level код. То есть, ну, как бы, к одной и той же парадигме они двигаются немножко с разных сторон. И вот как раз статья про это, про сравнение borrow-checker RASTA и сопутствующих или похожих технологий, которые предлагают… Ну, не технологии, а, как сказать, методов, да, средств, которые предлагает C#. И… Ну, давайте сначала… Сейчас мы детально разберемся, давайте сначала сообразим… Сообразим неправильное слово… Разберемся по верхам, по крайней мере, что такое borrow-checker RASTA. Значит, в RASTA вы не можете объявить, например, переменную в некотором скоупе, да, и потом присвоить в ссылку, да, которая живет где-то вне этого скоупа, ссылку на переменную из внутреннего скоупа, давайте так скажем. То есть, в принципе, то же самое нельзя сделать в C#. Если вы объявите некоторую переменную в C#, возьмете на нее ссылку через оператор или, как сказать, ключевым словом ref, да, и попробуйте присвоить ее в ref-переменную, которая объявлена во внешнем скоупе. Компилятор вам скажет, ай-яй-яй, так нельзя. По понятным причинам, потому что скоуп у вас закончится, со stack эти переменные уйдут, а ref-ы хранить вроде как нельзя на них. То есть, в этом смысле и RASTA, и C# похожи, и как бы и RASTA-овский borrow-checker не даст тебе такого сотворить, ну или lifetime-manager, скорее даже. Ну и в C# вроде то же самое.
915.52 1834.40 "Игорь Лабутин" Но, соответственно, в C#, давайте, наверное, все-таки в статье больше про C#, и мы все-таки подкаст про C#, давайте чуть-чуть про C# я как раз скажу. Что же такое аналог этого borrow-checker? Аналог этого borrow-checker — это все те концепции, про которые сейчас довольно много посмеиваются, так скажем, иногда над C#, потому что, когда у нас появились read-only, ref-only структуры, и вот это все, да, а также ref-поля, ref-стракты, ref-переменные, не переменные, как они называются, ref-аргументы функций, и вот это все, количество ключевых слов ref может быть довольно большим. И это немножко выглядит действительно странновато, но это все началось относительно недавно, в 2017 году, начиная с седьмого C#, ref стал довольно сильно развиваться, потому что до этого у него была единственная функция ключевого слова — это передача параметров функции. Можно было передать параметры по ссылке, для этого использовалось ключевое слово ref. И это был способ передать, например, ссылку на какую-то большую структуру, не передавая ее по значению, а передавая, ну, типа указатель, да, ссылку. Но начиная с седьмого C#, начались всякие ref-локалы, ref-ретурны, вот это все, добавились всякие read-only, те самые стракты, ref-стракты, in-ref, read-only-параметры, ref-филды, потом, соответственно, для того, чтобы ref-филды нужны, те самые ref-стракты, смотрите, спаны, и вот это все пошло-пошло-поехало. В итоге, в принципе, вы сейчас можете писать код на C#, который довольно низкоуровневый в этом смысле, оперирует ссылками туда-сюда, но при этом оставаясь в безопасном мире. И для того, чтобы оставаться в безопасном мире, в C# были выработаны некоторые, так называемые, правила, ну, назовем это правилами, да, называемые, ну, по-английски это называется ref-safe-context, то есть когда и куда вы можете безопасно передавать или возвращать ссылки. И это очень похоже на те самые лайфтаймы в Rust. Но в Rust BorrowChecker, который работает с лайфтаймами, он, вы эти лайфтаймы определяете, вы можете, там, есть неявные, но в целом вы можете определять их явно, если вам очень надо, вы можете определять лайфтаймы независимо там для каждого параметра функции, вот это все в C# ничего этого нет. У нас в C# лайфтаймы определяются неявно, и по факту, на самом деле, в отличие от Rust, как я сказал, где вы можете лайфтаймы явно связывать с каждым из параметров функции, причем разные параметры могут иметь разные лайфтаймы, то есть вы можете указать, что вот у этого параметра он, там, лайфтайм, в смысле, этот параметр будет, возможно, жить, ссылка на этот параметр будет жить за пределами лайфтайма этой функции, а вот этот параметр будет только внутри строк этой функции использоваться и наружу никуда не выдаваться не должен. В C# такого способа нет, поэтому лайфтайм, соответственно, возвращаемого значения считается на базе лайфтайма параметров, причем непонятно каких, ну то есть вы же можете передать несколько реф-параметров в C# и нет возможности сказать, что вот не было до некоторого времени возможности сказать, что одного параметра это мы только передали референс, но мы его будем использовать только внутри функции, а у другого параметра вот этот референс мы можем вернуть и наружу тоже. И поэтому с этой точки зрения лайфтайм, вот этот менеджмент внутри C#, он несколько более слабый, чем в Rust, но тем не менее позволяет довольно сильно и виртуозно поприседать с этими реф, реф с readonly и прочим остальным, что позволяет довольно писать неплохой и быстрый код. Раз позволяет более точный контроль, а C#, как я сказал в самом начале, что он движется больше от как бы простого и мощного языка в сторону безопасного low-level кода, у него все-таки в приоритеты легкость использования, нежели чем более явный контроль всего и вся, то есть мы больше полагаемся на компилятор, это вообще в стиле в каком-то смысле дотнета, меньше давать ручек покрутить, да, больше считать, что дефолтное поведение, ну плюс-минус дефолтное, да, то, которое компилятор может вывести, оно лучше всего. И чем меньше возможности покрутить ручек, чем в каком-то смысле, или тем меньше необходимости крутить эти ручки, да, на какой-то тонкой настройке чего-либо, тем лучше для программистов, потому что можно меньше думать и больше сосредотачиваться на вашем бизнес-коде. Хотя мы видели это по прошлому подкасту, когда там добавляются всякие оверлоут, resolution attribute, или как он там назывался, когда мы уже вмешиваемся в порядок того, как компилятор будет определять оверлоут, ну видно, что местами это все-таки не совсем этому следует, но в основном стараются. Как ты правильно заметил, в языках с garbage collection, в принципе, есть некоторые послабления, которые позволяют немножко ослабить этот контроль за lifetime, и действительно сделать жизнь немножко проще. Например, где это может помочь? Предположим, что у нас есть функция, которая принимает массив, и которая хочет вернуть ссылку на какой-то элемент массива, ну например, не знаю, мы ищем элемент по какому-то ключу, и хотим вернуть ссылку на элемент в массиве, по значению ищем, чтобы нам нужно, допустим, обновить потом этот элемент, мы ссылку на него отдадим наружу, и все бы хорошо, поскольку массив нам пришел снаружи, то отдать референс на него, на элемент массива мы можем, тут как бы ни C#, ни Rust, никаких проблем не как бы предоставляют нам, нет никаких проблем это сделать, но а что делать, если мы не нашли такой элемент? То есть можно, конечно, вернуть там null, или какой-нибудь optional, но это не очень здорово, тем более, если optional и внутри там ref, то это нужно, этот optional должен быть ref структурой, ну в общем, там свои трудности начинаются, поэтому хотелось бы вернуть ссылку на что-нибудь, что означает, что этого элемента нет, но как? Тут непонятно, вы не можете объявить какую-нибудь локальную переменную и вернуть в нее ссылку, потому что локальная переменная будет в стэке, и можно вернуть в Rust, например, референс на константу, если я правильно помню, а в dotnet можно сделать другую штуку, в dotnet вы можете объявить массив, прям создать там var, там какой-нибудь array, присвоить ничью int от единички, и сказать return ref array от нуля, то есть вы возвращаете ссылку на нулевой элемент массива, а ссылка на массив, это уже не референс, это нормальный, ну не ref ссылка, это нормальная обычная ссылка, локальная переменная исчезает, как только вы выйдете из scope, но ссылка на элемент массива остается, и garbage-коллектору достаточно знать, что на какой-то из элементов массива, это, насколько я помню, называется interior pointer, то есть это ссылка куда-то в середину объекта на самом деле, но garbage-коллектор умеет такие ссылки трекать, и соответственно он понимает, что этот массив должен жить, пока на него живет ссылка, только такая ссылка умрет, несмотря на то, что на начало массива ссылок нет, на сам объект, то тогда такой массив аккуратно garbage-коллектором соберется, поэтому вот такие вот моменты с garbage-collection позволяют немножко действительно ослабить контроль, и если что, вернуть такую какую-нибудь ссылку, ну куда-нибудь, насколько это полезно, другой вопрос, но тем не менее. В Rust есть некоторая аналогия, можно сказать, что соответственно хипу в каком-то смысле соответствует так называемый static lifetime, который на время жизни всего приложения, как я понимаю, но это некоторая такая, мне кажется, аналогия с натяжкой, да, при этом C# не разрешает рефы хранить на хипе, потому что, ну, непонятно, на что был реф, да, насколько реф будет долго жить, и реф должен контролировать, то есть рефы для того, чтобы упрощать контроль над тем, как долго и где они живут, они остаются жить всегда на стейке, именно в каком-то смысле у нас появляется разделение на объекты, типы, точнее, которые живут на стейке и типы, которые живут на куче, вот именно отсюда давным-давно появилось, да, в стандартном опросном собеседовании, что структуры живут обязательно в стейке, а классы живут обязательно в куче, но на самом деле это не так, да, структуру можно забоксить, и она будет жить в куче, вот, но, а класс на самом деле в современном дотнете может даже не попасть в хип, ну, кстати, про класс я не уверен, структуры точно могут расползаться по регистрам процессора и в хип формально не зайти, если они там как-то переменно используются только в пределах одного метода про классы, я, кстати, не уверен, может быть, не могут, не помню наизусть, вот, но, по крайней мере, реф-типы точно не могут, реф-типы живут строго на стейке, и вот как раз всякие спаны и прочие живут, представляют, являются представителями этих реф-типов, и это одна из причин, почему их нельзя положить в класс, потому что реф-типы в кучу класс нельзя, они, поскольку могут задерживать ссылки с учетом скоупа, а хип он живет вечно, ну, в каком-то смысле, и вне скоупа там конкретного потока, контекста, какого-либо метода или еще чего-нибудь, и поэтому невозможно контролировать, насколько ссылка там остается безопасной, а мы же в C# все про безопасность, мы должны иметь гарантию, что реф всегда правильный, вот, поэтому мы, вроде как, менее мощные из-за этих рефов, которые невозможно явно указать, но при этом у нас есть некоторая гибкость за счет garbage collection, дальше есть следующая интересная штука, у Rasta есть довольно строгие правила про то, как эти ссылки можно шарить и изменять, значит, ссылка может быть shared, и тогда, ну, то есть есть вариант shared, это когда вы можете иметь несколько ссылок, но вы можете только читать из них, писать туда нельзя, либо вы можете эксклюзивно владеть чем-то, и тогда вы можете и писать, и читать, но такая ссылка имеет право быть только одна. В C# все попроще, в C#, поскольку референсы у нас живы только внутри соответствующего скоупа, то как раз вот этих всех строгих Rastовых borrow-чекеров вроде как не надо, пока мы в скоупе все валидно, пока мы вышли из скоупа, оно, рефы становятся невалидными, это звездочка еще, чуть дальше скажу, что это звездочка, поэтому как бы borrow-чекер в C#, ой, borrow-чекер в C#, borrow-чекер в Rasta пытается осознать, куда же вы передали реф и правильно ли вы это сделали, независимо от того, в каком скоупе это происходит, а C# все это делает на основе скоупа. При этом, ну вот дальше автор как бы уходит в некоторые такие пространные рассуждения, перед этим скажу еще одну штуку, при этом в C# 11 принесли на самом деле некоторые улучшения и изменения в этой всей области, как я говорил, у C# нету возможности, если вы при меня принимаете несколько реф-параметров, сказать, что будет с lifetime этих параметров, то есть и как я говорил, компилятор предполагает, что они должны быть и в них нельзя бы ничего записать такого, что будет невалидно за пределами скоупа функций, то есть вы не можете в такой реф-параметр, например, залокетить массив стеколоком и записать, потому что как только вы выйдете из функции, такой массив будет удален. Но в C# 11 появилось новое ключевое... не помню новое оно или нет, по крайней мере появилось ключевое слово в контексте как раз передачи параметров, это называется scoped_ref, и это означает, что мы по-моему про это говорили в каком-то из обзоров 11 в C#, это стало означать, что тот реф, который передали, будет использоваться только внутри этой функции, наружу передаваться не будет, соответственно, ему можно присваивать всякие стеколоки и прочие из этой функции, потому что они никогда гарантированно не уйдут наружу, то есть таким образом мы получили теперь два таких контекста lifetime, lifetime-контекст, что на английском статье называется. Один - это уровня функции, то есть внутри мы заскопим, а второй - это уровня, так сказать, возвращаемого значения функции, в том плане, что мы должны иметь возможность вернуть реф на что-нибудь, то есть мы можем использовать только рефы, пришедшие снаружи к нам для того, чтобы что-то вернуть. Например, вот как я говорил в примере, это ссылка на элемент массива, который к нам пришел снаружи, такое можно. А в scoped_ref можно было бы присвоить и какой-нибудь стеколог, будет тоже нормально. Дальше у нас есть еще новая аннотация на классе, новый атрибутик, это называется unscoped_ref, который позволяет возвращать ссылки, ну грубо говоря, ссылки на this из классов, это тоже бывает полезно для всяких там сборки всяких билдеров и прочего, но это уже такой совсем advanced штука, я так не готов сейчас голосом это рассказывать, где, как это используется и зачем. Поэтому потихонечку в C# это все развивается, при этом не так много разговоров об этом, то есть я говорю, что в основном все разговоры вокруг рефа и всего остального это либо, ну, практические оптимизации в районе, всем надо использовать спаны и бежим использовать спаны, потому что спан - это, наверное, один из немногих таких практически полезных, широко применяемых, ну, относительно широко применяемых классов в обычном программировании, надо тут найти, а все остальное - это, да, шутечки про то, что readonly, refreadonly - это, значит, то, куда катится современная C#, может быть, это не совсем правильное направление, но с другой стороны, может быть, это как раз, вот автор как раз рассуждает про то, что, может быть, это из-за того, что, ну, в разде все исходно помешаны на таком безопасном кодировании, просто пытаются сделать его чуть более удобным, а в C# наоборот, ну, как бы у нас и так все достаточно хорошо и быстро, и редко кому нужно спускаться до таких деталей про readonly, рефов и всего остального, и тем более unsafe'а какого-нибудь. Так что интересное сравнение, если вам интересно покопаться, почитайте статью, там есть прям примеры, там довольно много примеров, которые очень тяжело приводить, потому что, особенно синтаксис раса, там угловая скобочка, апостроф, что-нибудь, запятая, апостроф, что-нибудь, угловая скобочка - это читать прям очень сложно, вот, поэтому это лучше почитать глазками, посмотрите, подумайте, если вы действительно заинтересованы в таком low-level коде, и, например, думаете, а не попробовать ли что-нибудь написать на Rust, может быть, интересно, попробуйте в том числе это написать на каком-нибудь этих рефах на C# и посмотреть, как это будет выглядеть. Такие дела. Слушай, а ты встречал реально людей,
1834.40 1841.28 "Анатолий Кулаков" настолько психанутых, чтобы они писали с помощью реф, реф readonly, ретурн реф и вот
1841.28 1883.44 "Игорь Лабутин" эти вот прочие глупости? Мне за всю свою карьеру, по-моему, один или два раза пригодились реф-параметры, это была какая-то супероптимизация, чтобы мне что-то куда-то там действительно были почему-то структуры, я не помню почему, скорее всего, потому что мы их как-то мапили в каком-нибудь интеропе, и мне нужно было передать эту структуру куда-то в еще один метод, и чтобы не преобразовывать это все во что-то и не боксить, я тогда через реф ее передал, вот это единственное место, где я это видел и мне, ну я понятно, что, наверное, если почитать профильные чатики, там много таких будет, но в среднем нет, конечно, в бизнес-коде такого почти нет. Ну как много, я думаю, за пределами
1883.44 1889.48 "Анатолий Кулаков" там фреймворка и микрософта не будет такого много. Да, наверное, нет, конечно, ну либо каких-нибудь
1889.48 1921.48 "Игорь Лабутин" действительно супер, знаешь, библиотек, которые прям пытаются, знаешь, там это вот как он назывался, это utf-8 jason parser какой-нибудь, ну то есть вот такие, знаешь, это супер-вычищенные, да, так сказать, последнего байтика библиотеки, вот где, ну там, скорее всего, опять же, там спаны, просто, наверное, хорошая работа на спанах, все, там ничего такого-то не надо, ну правда, со спанами приходится там рефом иногда передавать, видимо, чтобы как раз, если его возвратить, то нужно
1921.48 1953.60 "Анатолий Кулаков" еще как-нибудь. Ну то есть, наверное, это структурки все-таки не для большого интерфейс-приложения, это какие-то узкие библиотечки, которые должны мега быть оптимизированными. Да, да, но в Raspberry на каждом шагу. Ну да, раз уж он весь оптимизированный, на нем невозможно писать нормальный бизнес-код, только оптимизированные библиотечки. Ну да, потом используйте C#. А может быть еще для этих, для аишных всяких библиотек, которые там, они тоже вроде помешаны на перформансе, но не знаю, на сколько они там опускаются до всяких RefReadOnly. Я думаю, что там больше времени занимает условная
1953.60 1959.36 "Игорь Лабутин" математика и просто перекачка огромных объемов данных в память видеокарты, поэтому там может быть
1959.36 1984.44 "Анатолий Кулаков" не настолько много вот этого. Ну ладно. Заканчиваем тогда спекуляцию, если вы вдруг знаете, где на вашем коде применяются такие штуки, обязательно напишите в комментариях, потому что интересно, концепция сама прикольная, сами штуки интересные, наверное, если бы я там был, каким-нибудь мега-оптимизатором, то мне бы классно было бы с этим поработать. Ну вот, хочется понять, а в нормальном коде, в человеческом, в повседневном есть ли они где-то или вообще
1984.44 2058.36 "Игорь Лабутин" их нет? Напишите в комментариях. Да, еще вы можете написать, если я что-нибудь какую-нибудь фигню рассказал, потому что я раз так не сильно захожу в него, немножко знаю про него, немножко интересовался, но не практикую каждый день, поэтому мог что-нибудь где-нибудь набрать. А второй момент, мне кажется, более интересным. Наверное, это немножко параллельное обсуждение, но тем не менее, что может быть более интересно в контексте как раз анализа вот всех этих скоупов, лайфтаймов и прочего, это как раз понимание, это то, что называется по-английски escape analysis. То есть, если, например, мы понимаем, что какой-то объект не будет выходить, ну вы там, не знаю, в функции локейтите какой-нибудь объект, да, вы понимаете, что он не будет выходить за пределы области видимости этой функции. Ну, не знаю, стринг билдер вы заалокцировали, да, накидали в него строчек и потом создали строку, и все, вам этот стринг билдер больше не нужен. Такой простой пример. Ведь технически, конечно, у нас аллокация в нулевом поколении, она как бы халявная, практически. Пойнтер подвинули и все, да, и чистка, в принципе, халявная. Но, в принципе, если джит, например, довольно быстро сможет понимать, что этот переменный не выходит за пределы функции, он же сможет ее вообще не аллоцировать на хиппи, а разложить просто
2058.36 2067.00 "Анатолий Кулаков" в стэк, и все, и будут эти такие, аллоцироваться классы на стэке. Мне кажется, он и так должен это понимать, потому что не очень сложная эта аналитика должна быть. Нет, там, да, на самом деле,
2067.00 2192.24 "Игорь Лабутин" довольно сложно с точки зрения понимания, что куда уходит. Это ты, когда глазами смотришь, ты понимаешь, а, ну да, тут ссылка не может уйти. Но там же начинаются всякие там замыкания, какие-нибудь венты, еще что-нибудь. Там, на самом деле, довольно много всего. Это довольно сложный анализ, это вроде как, я вот сейчас боюсь наврать, но, по-моему, это там вот из-за разряда этих там NP-полных задач. Вот это все нормальный escape analysis. Вот, то есть, кажется, что это, в общем, не уровень от джита, где нужно думать за миллисекунды или микросекунды, как они там думают. Но, сейчас, опять же, с учетом тирнутости, да, у нас несколько слоев, как-то не слоев, как-то русский называется, тир. Короче, несколько этапов джита, когда у нас есть медленная версия, быстро, и мы можем в параллель компилировать еще одну, хоть там два дня компилируя, потом подмени, то, может быть, рано или поздно, сейчас говорят какой-то, я не читал давно ничего на эту тему, но вроде говорят какой-то простейший escape analysis уже есть, и какие-то простые варианты джит умеет разложить просто по там регистрам или стеку, условно говоря, и не ассоциировать реальные переменные, реальный heap. Но, может быть, это как бы там, я так понимаю, что все это еще в очень зачаточном состоянии, и когда это вырастет, то, опять же, потребление памяти наше и быстродействие должно, ну, существенно вырасти, потому что это, на самом деле, то, на чем, в частности, Java хорошо развита, потому что там же нет примитивов, как у нас там, структурок, да, там же даже эти самые инты, грубо говоря, ну, это как бы класс, по большому счету, то есть, и там из-за этого приходится, на самом деле, довольно много заниматься таким, то есть понимать, что это примитив, это, на самом деле, примитив, и его надо просто заауцировать на стеке, и не надо с ним лезть в кучу. Вот там это все хорошо развита, хорошо работает, так что у нас, может быть, тоже рано или поздно появится, и тогда будет еще быстрее, еще лучше. Вот. Но это уже не про borrow-checking, конечно, это немножко про другое. А давай пойдем все-таки теперь к более, действительно, практическим местам, а то все эти borrow-checkers действительно в бизнес-коде не используются. А вот следующая статья точно про то, что, наверное, каждый плюс-минус разработчик
2192.24 2263.92 "Анатолий Кулаков" API писал. Ну, или должен писать. Ну, или, как минимум, обязан использовать. Потому что сейчас мы поговорим с вами про problem details, и если вдруг кто-то никогда не знал, что это такое, то сегодня вы откроете для себя большой чудный мир. А если кто-то знал, то узнает, а какое состояние в современном датанет фреймворке. Потому что я еще писал свои собственные problem details на большом фреймворке, когда их еще в стандартном комплекте не было. Потом, когда они в стандартном комплекте появились, у них не было хороших middlewari для того, чтобы подключить. Поэтому потом я писал собственные middlewari, и на данный момент я пишу собственные мапперы. И вот тут в .NET 9, а вот что случилось в .NET 9, мы узнаем через несколько минут. Потому что обо всем по порядку. Итак, problem details в ASP.NET Core API. Что же это за штука и с чем ее едят? Ну, во-первых, нужно понимать, где она используется. Когда мы разрабатываем наш HTTP API, то нам очень важно сохранять информативность тех ответов с ошибками, которые мы возвращаем нашим клиентам, нашим пользователям нашего API. То есть как возвращать? Саксессы мы уже все знаем. Здесь ничего интересного вообще нет. А вот когда нам нужно вернуть ошибку, перед нами встает дилемма. А что мы должны вернуть?
2263.92 2334.92 "Анатолий Кулаков" Обычную строчку, которая пользователь расскажет, что случилось. Или наоборот, какой-нибудь машина, читаемый код, который там через enumчик объяснит нашему клиенту, что, собственно, произошло. Или, может быть, что-то еще. И обычно это решали все по-своему. Все пытались то стактрейсы вывалить, то просто одну строчку вернуть, то какой-нибудь JSON-объект структурировать. В общем, был разброд и шатание. И разброд и шатание были до тех самых пор, пока не появился замечательный стандарт. И этот стандарт называется problem details. Problem details прекрасно поддерживается современным S/Panel Core и предоставляет унифицированный и эффективный способ структурирования и представления HTTP-респонсов, описывающих проблемы, которые произошли на сервере. То есть, все, что не саксесс. Почему он, собственно, появился? Я уже описал, что действительно статус кода нам недостаточно. Если там произошел какой-нибудь bad arguments, то хотелось бы все-таки понимать о подробностях, какой аргумент, а почему бы это, почему произошел. Поэтому обычного статус кода нам недостаточно. Нам нужен что-то большее. Нам нужен объект, описывающий ошибку.
2334.92 2401.32 "Анатолий Кулаков" Может быть, это возможно сравнить с тем, что у нас внутри .NET представляют эксепшены. То есть, эксепшен - это какой-то объект, в котором есть чего-то большее, чем просто обычная строка, описывающая, что произошло. Вот такой же объект хочется получить и не только внутри .NET, но и между всеми языками, всеми протоколами и вообще во всем мире стандартный. Вот этим самым объектом и является ProblemDetails. Этим самым форматом. Итак, ProblemDetails - это машина в читабельный формат, потому что по спецификации он описан для поддержки JSON и XML. Наверняка другие форматы тоже несложно подтянуть по аналогии, но спецификация именно на них. Которая описывает о том, а как же нужно возвращать правильные ошибки из вашего HTTP API респонсов. ProblemDetails, как я уже сказал, это какой-то набор полей, какой-то формат и давайте посмотрим, какие же поля он в себя включает. Во-первых, базовых полей не так уж и много. Во-первых, это Type - это URI-референс на адрес, описывающий то, о какой тип, собственно, ошибки нам вернулся.
2401.32 2465.76 "Анатолий Кулаков" Довольно необычное представление, потому что, когда мы подразумеваем Type, ну что мы туда можем засунуть? Ну строчку, ну enumчик какой-то. Но чтобы определять Type с помощью URL-а, это что-то новенькое. Но, в принципе, почему бы и нет. URL тоже довольно уникальная штука и она довольно уникально может определить Type. Именно поэтому его сюда и выбрали. Что он уникален не просто, как один enumчик в каком-то Namespace, а это уникальная штука в пределах всего мира, между всеми языками. Следующее поле - Title. Это уже человекочитаемое описание того, про что, собственно, этот тип. Статус. Поле представляет аналог HTTP статуса. Зачем здесь понадобилось дублировать HTTP статус? Не знаю, нет мне ответа на этот вопрос. Возможно, для извращенцев, которые используют какое-то подобие там GraphQL или еще что-то, которые не полагаются на HTTP протокол, а все свое ношу с собой. Поэтому статус засунули именно в сам объект. Details. Это поле представляет человекочитабельное описание конкретно той ошибки, которая у нас сейчас произошла.
2465.76 2640.18 "Анатолий Кулаков" И instance - это как раз URL на конкретно ту ошибку, которая сейчас произошла. Некоторые поля, может быть, немножко не самые очевидные, но, с другой стороны, это помогает достичь большой, очень универсальности. Давайте рассмотрим небольшой пример. Допустим, вы не смогли найти какой-то объект, не смогли найти какой-то order в вашей системе. Как мог бы выглядеть JSON, который возвращается вам в формате problem.details? Прежде всего, стоит отметить, что у problem.details есть свой собственный content-type. Называется он application/problem+json, так что не хухры-мухры. Довольно стандартизованный метод. В качестве type мы бы ему могли указать, например, ссылку на RFC 911, который описывает все статус-коды, и пункт, соответственно, на этом RFC 15.5.5, который описывает как раз-таки ошибку, HTTP-ошибку 404. В title можно указать тип этой ошибки, то есть not found. Статус-коде у нас будет тот же самый 404. И в details мы уже должны подробнее расписать, а что случилось. Здесь мы можем расписать, что как раз вот этот ордер был не найден. И в инстанси обычно пишут URL в вашем сервисе с идентификатором того инстанса, который был не найден, то есть какой запросили, какой ресурс запросили вот с его идентификатором, вот можно записать инстанси. То есть обрабатывающая сторона автоматически понимает, по какому URL не нашлась сущность. Как я уже сказал, это стандарт под RFC 94.57, который так и называется Problem Details for HTTP API. Этот стандарт замещает старый стандарт ProblemDetails 7807, с которым многие из вас могли сталкиваться в больших фреймворках. В новом стандарте появилось парочку улучшений. Самые заметные из них это теперь более очевидно нас просветили, что надо писать в PolyType, потому что раньше никто не понимал, что там должно быть. И там добавили расширение Problem Details. То есть теперь более официально вы можете засовывать в Problem Details какие-то свои поля. Естественно, те поля, которые я вам рассказал, это всего лишь какая-то база. Хочется всегда засунуть чего-нибудь больше. Например, если у вас провалидетилась какая-нибудь большая форма, в которую пользователь вводил данные и 5 полей были плохими, то вам, естественно, хочется сказать, какое поле и по какой причине вы признали плохим. Это, естественно, все тоже можно отдать внутри Problem Details. У C#, кстати, даже есть стандартный маппер с аргумент эксепшенами на такую структуру. Но об этом чуть попозже. Итак, как же нам заюзать в своем приложении Problem Details? На самом деле, в флеймменном фреймворке все довольно-таки просто. Что мы хотим?
2640.18 2676.24 "Анатолий Кулаков" Мы хотим, чтобы наши все эксепшены, которые случились внутри приложения, отдавались в виде Problem Details снаружи, чтобы никакие некрасивые call-стеки не вываливались, а все было оформлено чистенько по стандарту. Сделать это довольно просто. На старте вашего приложения, когда вы все настраиваете, вам нужно к сервисам добавить Add Problem Details. Эта штука специально добавляет все сервисы, необходимые все форматоры, фабрики, конструкторы, мидлвари, хендлеры и прочие глупости, необходимые для построения всего этого баганства. Дальше в API вы вызываете метод UseExceptionHandler.
2676.24 2753.50 "Анатолий Кулаков" Этот метод добавляет использование специальной мидлвари, которая умеет конвертить исключения в Problem Details. То есть у вас будет мидлваря, которая кетчит ваш реквест. Если вдруг из нее выбывают лица исключения, она знает, как это исключение сконвертировать в Problem Details и отдать уже как раз красивенькое отформатированное то, что мы и хотели. И еще один метод можно использовать UseStatusCodePages. Это та мидлваря, которая конвертит пустое тело ответа с несуэксцессным результатом в страничку с Problem Details. Ну, это совсем необязательная штука. Как бы первых 2х хватит с головой обычно всем. И теперь, как только в вашем приложении возникнет необработанное исключение, то наружу в респонсии оно будет транслироваться как раз в Problem Details, что прекрасно. Итак, теперь давайте же... Да, и на этом все. Если вы ожидали, как добавить поддержку в ваше приложение, то все. Поддержка добавлена, добавляйте вот эти две строчки и вы счастливы. Вы соответствуете стандартам, вас понимают на любом языке программирования и вы полностью, практически, отвечаете на вопрос о том, что с вами все собственно произошло. Но в большинстве случаев вы захотите немножко поднастроиться. То есть передавать какие-то большие полей или расширить какие-нибудь ваши кастомные исключения, чтобы они обрабатывались как-то по-другому. В общем, что-то как-то поднастроить.
2753.50 2764.02 "Анатолий Кулаков" Вот, давайте посмотрим, а что же интересного можно тут здесь поднастроить. Итак, наиболее популярный подход. Что же у нас было, допустим, когда до того момента, как на у нас появились Problem Details.
2764.02 2781.94 "Анатолий Кулаков" Ну, все очень просто. Мы делали middleware, как я уже сказал, сделали try-catch на том реквесте, который собирались выполнить. Если вдруг оттуда вырывалось исключение, мы его форматировали каким-то образом. Опять же, мы можем ручками Problem Details сформатировать и возвращали в ответ.
2781.94 2788.82 "Анатолий Кулаков" В принципе, ничего такого сверхъестественного нет. В DotNet 8 появилась немножко более удобная штука.
2788.82 3092.24 "Анатолий Кулаков" То есть, появился специальный middleware, который обрабатывает все эксепшены. И она вызывает классики, все классики, которые пронаследованы от iExceptionHandler. То есть, такая небольшая абстракция, чтобы вам каждому не городить вот эти свои middleware, которые там ловят исключения, а вы можете просто загородить свой эксепшен-хендлер и сделать цепочку из таких эксепшен-хендлеров, которые каким-то образом обрабатывают ваши исключения. Ну, например, там логируют, пишут в метрики и в том числе форматируют в Problem Details. Почему бы и нет. Вот, и с помощью этого эксепшен-хендлера вы можете построить, опять же, свой перехватчик, в котором вы отформатируете Problem Details. И если у этого эксепшен-хендлера есть хороший метод, который называется TryHandle, который возвращает True или False. Примечательно то, что если вы возвращаете True, ну, то есть, вы правильно отформатировали ваш Problem Details, вам больше ничего не надо делать, то срабатывает Short Circle Pipeline, который мы обсуждали в одном из выпусков, который прерывает выполнение всего пайплайна ISP.NET и мгновенно сразу возвращает респонс, игнорируя все остальные хендлеры, которые у вас там есть. Это очень часто нужная операция, как раз вот для таких случаев, для исключений. Если же вас метод вернул False, то просто-напросто по цепочке вызывается следующий хендлер, как вы могли бы представить. Итак, и дальше мы можем сделать, соответственно, маппинги. То есть, какой эксепшен-тайп, в какой HTTP статус-код превращается. Допустим, у нас есть там какие-то стандартные маппинги, но вот у нас есть свои собственные исключения. И свои собственные исключения, опять же, стандартный маппер про них ничего не знает, они будут конвертироваться в Internal Server Error. Наверное, это не всегда то, что вам нужно. Например, если у вас есть Order Not Found Exception, то вы бы хотели его сформатировать именно в 404 и в Not Found HTTP статус-код. В общем, такое тоже можно делать при условии наличия своего собственного эксепшен-хендлера. Еще нужно ответить на полезный сервис, который называется Problem Details Service. Именно благодаря этому Problem Details Service вы можете в вашем эксепшен-хендлере не стряпать вот эти Problem Details ручками, а попросить его вам создать этот Problem Details и заменить всего-навсего те поля, которые вы хотите поменять. Ну, например, тот же самый HTTP результат вы хотите поменять и, может быть, HTTP статус-код. Вот, это все можно сделать с помощью вот этого сервиса, а все остальные поля он вам предзаполнит такие, какие они должны быть на поумолчании с помощью использования каких-то фабрик, конвеншенов и так далее. Ну, то есть, не смирляя его собирать, а такой своеобразный немножко билдер, который поможет вам записать правильный формат в респонс. Если вдруг вы в контроллерах прямо хотите вернуть Problem Details, то есть, вы не хотите бросать исключения, а хотите по-тихому сформулировать какой-то ответ и вернуть тот же самый Problem Details. Нет ничего проще, потому что существует базовый метод, который называется Problem. И в этом методе Problem вы можете описать Problem Details с любым удобным для вас уровнем детализации. Если вы же используете Minimal API, то есть Result.Problem. Его тоже можно невосбранно вернуть и описать все, что вы хотите. Теперь, как мы можем еще кастомизировать Problem Details? Вы можете передать делегат в метод addProblemDetails, который мы в самом начале в программе регистрировали. И в этом делегате настроить абсолютно любую кастомизацию вашего респонса. То есть, вы можете с респонсом, который отдает Problem Details, сделать абсолютно все, что угодно. Это хорошая точка для того, чтобы засунуть сюда CROSS-CUTTING консерны. Ну, например, если вы хотите в инстансе, как я уже говорил, всегда отдавать тот URL, по которому пришли за этим ресурсом, вы прямо здесь можете написать, что instance равен http-request.query и засунуть сюда этот URL. Или, если, например, вы хотите в Problem Details отдавать еще Request ID, чтобы удобно было смотреть, по какому реквесту у нас случились проблемы. Или даже Trace ID, чтобы удобно подключить сюда OpenTelemetry и уметь трассировать вашу ошибку в ваших Problem Details до самого корневого узла, который вообще вас выбрал, до самого корневого сервиса. Это тоже вот в этом месте удобно и хорошо размещать можно. Итак, теперь хотелось бы вернуться к маппингу ваших кастомных исключений. Ну, как я уже говорил, если у вас вдруг появилось исключение, которое есть только в вашем приложении, то стандартный маппер не знает, в какой Problem Details его переворачивать, и он отдаст Internal Server Error, то есть ошибка, которая случилась внутри приложения, и маппер не знает, что с ней делать. Он не знает, как ее перевернуть во что-то более адекватное для пользователя. Раньше вам необходимо было писать, как я уже говорил, свои специальные Error Handlers. Начиная с 9.0.net появился удобный статус CodeSelector. Это специальный делегатик, который вы тоже можете передать в Application при построении метода UseExceptionHandler.
3092.24 3197.52 "Анатолий Кулаков" Передается этот делегат, и там вам в качестве аргумента отдается Exception, который собирается сейчас отформатироваться, и в качестве результата вы можете вернуть HTTP статус код, в который вы хотите, чтобы это исключение преобразовывалось. Соответственно, если у вас в приложении зарегистрирован OrderNotFoundException, вы его прямо здесь можете сконвертить в 404 BadRequest. И все, не надо писать никаких больших других классиков, или расширений, или middleware, или еще чего-то. Односрочечка и красивенько, и тут точно так же столбиком можно абсолютно все Exception зарегистрировать и сказать, что они там возвращают. Итак, в итоге, что мы имеем? Мы имеем хороший набор сервисов, которые уже встроены в современном ASP.NET Framework, который форматирует ваши ошибки, ваши проблемы в стандартном подходе, который поддерживается всеми языками, всеми стандартами, которые задекларированы в РФЦ, которые ожидают обычно разработчики, дебаживающие HTTP. Это все стандарт, это все best practice, который приводит к хорошему структурированному выводу всяких ошибок, помогает разобраться, дебажить ваши проблемы, выдает детальный анализ. Этот анализ можно настраивать отдельно для релизов и для дебагов, допустим, чтобы он там в дебагах вам еще стэктрейсы добавлял и добавлял какую-то служебную информацию. Для релизов все было более-менее чистенько и непалевно. В общем, вот такой прекрасный формат, который, если почему-то вы до сих пор не использовали, то обязательно попробуйте, обязательно заюзайте. Он прекрасен, он хорош, он поддерживается многими инструментами, не только в дотнете, но и вообще во всем HTTP мире. В общем, а если вы юзали, то вы, наверное, могли какие-то новинки, которые добавляются с каждым новым
3197.52 3228.48 "Игорь Лабутин" фреймворком для себя подчеркнуть. Детально ты разобрал эту штуку. Прямо скажем, действительно полезный интерфейс, ну, подход, да, интерфейс. Действительно полезный подход к тому, как делать едино и понятно, что бы вы ни делали, какой бы API вы ни писали. Кажется, что действительно должен быть просто дефолтным вариантом. Странно даже, что... я не помню, по-моему, в стандартные шаблоны он не включен же, да, когда только-только собираешь проект? По-моему, да. Вот, по крайней мере,
3228.48 3235.88 "Анатолий Кулаков" те последние проекты, которые я начинал, я там всегда подключал его руками. Ну, что довольно странно. Мне кажется, в будущем они должны включить в стандарты. Мне кажется, да. New Builder и
3235.88 3256.72 "Игорь Лабутин" всё. То есть было бы удобнее гораздо. Практически сразу всё работает. Да, нужно, конечно, возвращать в нужном, грубо говоря, формате, да. Всё нормально. Сразу встроенный exception handling, middleware, вот это всё, короче, должно работать без коробки, мне кажется. Чтобы сразу всех
3256.72 3261.52 "Анатолий Кулаков" приучали к хорошей практике. Ну, надо проверить, мне кажется, уже в грядущем релизе дотнета,
3261.52 3285.52 "Игорь Лабутин" скорее всего, должно включиться уже в стандарт. Может быть, может быть. Ну, а мы пойдем дальше. И мы пойдем дальше к более такой лайтовой статейке, мне кажется. А именно, автор попробовал сравнить производительность контроллеров и minimal API. Мы со времен появления minimal API слышим про то, что ну вообще это такой более легковесный механизм. Контроллеры там перегружены, там куча всего.
3285.52 3297.56 "Игорь Лабутин" А вот minimal API, если вам нужно написать какое-то простое и быстрое предложение, ну, то используйте minimal API. Это модно, молодежно, современно и быстро и вообще в тренде современного АСП дотнета.
3297.56 3318.28 "Игорь Лабутин" И не надо, не то чтобы Microsoft говорит, не надо использовать контроллеры, но всё-таки кажется, что почти везде, ну, по крайней мере, для примеров понятно, что minimal API проще писать, да, одной строчкой написать что-нибудь там, usually run, ну, точнее, не usually run, блин, это я в миддлварьке, usually run get, да, пост или ещё что-нибудь в таком духе гораздо проще,
3318.28 3327.72 "Анатолий Кулаков" чем писать полноценный контроллер. Но… Слушай, мне кажется, она не говорит, но она всегда об этом очень громко думает. Те же самые AOP, она поддержала только там для minimal API, но не для
3327.72 3350.68 "Игорь Лабутин" контроллеров. И вряд ли поддержит для контроллеров. Ну, там вот как раз из-за того, что много всякой рефлексии и вот этого всего, я понимаю, почему AOT не всё может быть легко поддержано. Но, то есть, если даже для поддержки AOT в minimal API пришлось интерсепторы заводить, очень нетривиальную фичу языка, надо сказать. Ну, не языка, а там, туллинга вокруг языка, да, рослина. Но всё же.
3350.68 3451.76 "Игорь Лабутин" Вот. И, в общем, автор задался вопросом, насколько же всё-таки оно медленнее или быстрее. Что он сделал? Он сделал тесты, которые запускаются на девятом дотнете, ну, RC2, и на восьмом дотнете релиз, да. Попробовал всё это дело на просто своём ноутбуке. Ну, это, правда, MacBook M2 Pro. То есть, довольно мощная штука. Но, в целом, он, естественно, делает кучу всяких оговорок про то, что смотрите на ваши профильные нагрузки, смотрите на ваше приложение. Потому что, ну, понятно, что это всё тесты синтетические, реально, как бы. Тот факт, что minimal API на полмиллисекунды быстрее, чем контроллеры, при том, что ваш бизнес-код ходит в вазу данных в течение, там, десяти миллисекунд. Ну, как бы, неважно, на чём вы пишете, по большому счёту. Но, тем не менее, было интересно. Что было сделано для тестирования? Значит, создаётся два WebApplication. У нас есть такой класс WebApplication, его можно собрать так и этак. Соответственно, в одном случае туда добавляются middleware и, говорится, MapController, в другом случае просто minimal API-эндпойнты добавляются. Дальше всё это меряется стандартным HTTP-клиентом. С помощью бенчмарка тут на это, понятное дело. В бенчмарк.нете включены memory-диагнозеры для того, чтобы посмотреть ещё, сколько мы памяти потребляем. Выключено всё логирование, полностью, вообще всё. И поставлены Aspernet Core Environment переменные в production, чтобы было побыстрее, потому что там всяких, чтобы не было никаких там developer exception page и вот этого всего. И дальше проведён был ряд тестов. Тест номер один — самый простейший GET-реквест, который просто возвращает практически статическую информацию. Ну, там, на самом деле, предсозданный JSON-объект.
3451.76 3493.32 "Игорь Лабутин" Minimal API чуть-чуть быстрее и тратит чуть-чуть меньше памяти. Когда я говорю "чуть-чуть быстрее", числа в абсолютном выражении выглядят так. На восьмом тутнете это было 60 микросекунд на minimal API и 62 микросекунды на контроллерах, а в девятом тутнете стало 55 и 59 соответственно, то есть чуть-чуть ускорилось и там и сям. Ну и по памяти, соответственно, minimal API скушали 4,7 килобайта в среднем, а контроллеры 7,11 килобайт в памяти. Я не помню, что MatMark выдаёт в табличке. По-моему, он же… А нет, это он garbage collection на тысячу штук, а локейты, по-моему, всё-таки на итерацию. Не помню точно. Ну, там важны относительные чиселки.
3493.32 3498.76 "Игорь Лабутин" То есть примерно в два раза скушает минимал API, но по скорости они практически сравнимы.
3498.76 3509.28 "Игорь Лабутин" При этом надо сказать, что девятый тутнет быстрее, причём девятый тутнет быстрее и в контроллерах, и в minimal API. В смысле, что он ускорился, и то, и то ускорилось по сравнению с восьмым.
3509.28 3824.16 "Игорь Лабутин" Дальше попробовали чуть более интересно. Никто никогда, ну практически никогда не возвращает стандартные предсобранные JSON. Конечно же, там вы инжектируете какие-то сервисы через DI, вы что-то там считаете, поэтому давайте, окей, заинжектируем какие-то сервисы. Попробовали, запустили тест, получили, ну там чиселки чуть-чуть отличаются, но с учётом того, что это ещё и ноутбук, я думаю, что можно считать, что они примерно одинаковые. Там реально доли, десятые доли, какие-то отличия, ни о чём. Окей, GET-реквесты разобрались, давайте POST-реквесты с BODY и с QUERY-параметром. Добавили, попробовали запустить, получилось по времени похоже, но в основном было по памяти. По памяти при этом мы сожрали в два раза больше, ну практически в полтора раза больше, то есть мы стали кушать 7 килобайт в моё minimal API и 12 с лишним килобайт в контроллере, что отмечает автор довольно много вообще говоря, но ладно, допустим. Но опять же, никто не живёт в API-шках в таких без middle-var, ну куда же без них. Давайте добавим middle-var. Автор добавил два middle-var, одна которая добавляет correlation ID header просто сразу к респонсу, а вторая middle-var - это просто аналог некоторого global exception handler, то есть просто внутри try-catch-блока вызывается next, ну и в кетче, ну там скорее всего ставится респонс код 500, грубо говоря, и пишется, что пошло не так. Вот, в minimal API, конечно, всё ещё работают быстрее, здесь уже разница чуть-чуть стала побольше, ну чуть-чуть это, как бы напомню, что простой get был 60 и 62 на восьмом дотнете, а стал 64 и 72 на восьмом и, соответственно, 61 и 66 на девятом, то есть всё ещё микросекунды, это не миллисекунды, это микросекунды. Memory allocation, ну, примерно так же, как в посте, 7 килобайт и 12 килобайт, ничего не сильно изменилось. Вот, дальше попробовали добавить параллельных запросов, то есть к этому же сетапу накинули 100 параллельных запросов, ну, понятно, что это не совсем high-load, ну просто ради интереса, что будет. Но тут уже выкинули middle-var, почему-то, ну, так решил построить. Опять же, minimal API чуть-чуть быстрее, чуть-чуть меньше памяти, ну, короче, в общем, практически ни о чем разница. На последнем тесте добавили вообще всё, то есть там большой респонс, query-параметры, middle-var, сервисы инжекнутые, вот это всё, короче, закинули всё это, значит, в тест и получили следующее. Вот в этом тесте, когда там вообще всё было включено, minimal API отработали за 3 миллисекунды, контроллеры за 3, 17 миллисекунд на восьмом дотнете и, соответственно, 2,9 и 3 миллисекунды на девятом дотнете. По памяти, соответственно, minimal API скушали 1.2 мегабайта, а контроллеры 2.1 мегабайта, ну, то есть почти два раза по памяти разница. То есть, фактически, получается следующее, с моей точки зрения, то есть в среднем, если посмотреть, конечно, minimal API чуть-чуть быстрее. Если речь идёт о скорости, то практически незаметно быстрее, я бы сказал. По памяти minimal API несколько поэффективнее, но, видимо, потому что нет как раз накладных расходов на всю ту машинерию, которую предлагают контроллеры. Там же всякие коллекции фильтров и вот этого всего. Это может быть просто чуть-чуть дороже. Ну и сами контроллеры, да, держать всё это в памяти тоже надо, всё это рефлексией обойти и сохранить в памяти. Поэтому, возможно, разница ровно из-за этого. Ну и плюс контроллеры не так сильно вылизывали по памяти, и там понятно, что остались, наверное, какие-то старые следы некоторых локейтов, которые можно тоже наверняка извести, если этим заняться. Поэтому выбор, на самом деле, между этими штуками точно нужно делать не по перформансу. Ну, то есть, если вы совсем критичны по памяти, можно, конечно, посмотреть в сторону minimal API, но кажется, что overhead от выбора minimal API либо контроллера будет настолько мал на фоне потребления памяти бизнес-логикой вашего приложения и потребления процессора, что, по большому счёту, выбор сводится к стандартным рекомендациям, которые есть, на самом деле, у Microsoft. У них есть некоторая статья, где сказано, когда нужно что выбирать. Ну, то есть, если вам там нужны какие-то суперхитрые дополнительные обработки, которые как раз хорошо и удобно реализовывать в виде фильтров на контроллерах, то, наверное, лучше выбрать контроллер. Если у вас что-то простое, типа CRUD API, который не требует каких-то суперсложной логики от уровня контроллеров, ну да, сделайте minimal API, ну и так далее. То есть, есть статья, почитайте на сайте Microsoft, если вы вдруг каким-то образом выбираете. По-моему, мы даже её, может быть, когда-то обозревали, но по-моему, нет. Не уверен, кстати. Вот. Но итогом всей этой статьи становится то, что, по большому счёту, с точки зрения перформанса, когда, значит, Microsoft говорит, что minimal API быстрее, Microsoft, как бы, не врёт, они действительно быстрее, но разница настолько мала в абсолютных числах, что кажется, что в практическом смысле, ну, в общем, не должна влиять на какой-то выбор того, что вы будете использовать одно или другое в ваших реальных приложениях. Такие выводы.
3824.16 3834.92 "Анатолий Кулаков" Вот. И уже несколько лет прошло, как minimal API появился, и ты можешь для себя ответить, а на хрен он появился-то? А зачем он нужен? Ну, что-нибудь суперпростое, простенькое написать.
3834.92 3841.24 "Игорь Лабутин" У меня было пара примеров, когда мне нужно было написать сервис, там типа трёх endpointов, которые действительно возвращали что-то предельно простое. Ну, типа.
3841.24 3844.68 "Анатолий Кулаков" Ну, опять же, я бы не обломился это всё написать на…
3844.68 3852.68 "Игорь Лабутин" Я согласен. Ну, там получилось типа на один файлик условно меньше. Грубо говоря. Наверное.
3852.68 3859.08 "Анатолий Кулаков" Не та штука, знаешь, за которую надо дотаскивать фреймворк, писать кучу статей, как бы заставлять людей выбирать и всё такое.
3859.08 3874.48 "Игорь Лабутин" Ну, да. Возможно-возможно, что… Ну, я не знаю, действительно, видишь, получить nativeout ispnetcore на контроллер было бы в разы сложнее, чем сделать его для более простых minimal API.
3874.48 3884.52 "Анатолий Кулаков" Ну, не потеряв как-то. Да, я для себя тоже это объясняю только out, больше вообще никакого смысла нет. Поэтому, если вдруг вам нужен out, то вам выбора нет, вы смотрите на minimal API. Если вам out не нужен,
3884.52 3889.84 "Игорь Лабутин" то, кажется, и смотреть тогда не стоит. Ну, кому как. Может быть, кому-то удобен такой стиль.
3889.84 3898.72 "Игорь Лабутин" У нас же было некоторое количество разных библиотек, помнишь, раньше? Сейчас они как-то все подпомерли, в каком-то смысле, мне кажется.
3898.72 3901.28 "Анатолий Кулаков" Да-да, типа Nancy, FastAPI. Nancy, да, вот этих всех,
3901.28 3923.72 "Игорь Лабутин" которые не контроллерами, а просто такой вот типа convention-based, то, что называется, да, во многом. Много где он был такой, convention. Назови метод get и он будет работать. Вот здесь, мне кажется, то же самое тут. Не совсем такое, но тоже некоторый чуть более простой подход, если вам не нужна мощь контроллеров. Мы-то просто с тобой привыкли писать эти контроллеры, сколько мы уже их пишем. Вот. А кому-то, может быть, привычнее такое.
3923.72 3926.64 "Анатолий Кулаков" Если это такое нравится, то почему бы и нет? Давайте.
3926.64 3931.56 "Анатолий Кулаков" Ну, пойдем еще по одному статью по best practices, диагностике и дебагам.
3931.56 3944.84 "Анатолий Кулаков" Да. У нас каких-то два интересных автора подобралось. Это Мила Йовович, который предыдущий был, и CodeOpinion.com, про который мы сейчас поговорим. Это, в общем, два таких самых главных популиста, по-моему, про C#, по крайней мере, мнение все время на YouTube.
3944.84 3950.20 "Игорь Лабутин" Я только тебя поправлю, предыдущий автор все-таки не Мила Йовович, а Милан Йованович.
3950.20 3954.48 "Игорь Лабутин" Мила Йовович немножко из другой оперы. Ну, допустим.
3954.48 3956.60 "Анатолий Кулаков" Мы пока не подкаст по кино. Удобнее читать именно так.
3956.60 3957.60 "Анатолий Кулаков" Ну, да, но он Йованович.
3957.60 3963.60 "Анатолий Кулаков" Посмотри, ты эти рожи угадываешь, они у тебя тоже в рекомендациях вскакивают или нет?
3963.60 3972.80 "Игорь Лабутин" Ну, Йованович нет. Ну, CodeOpinion, да. CodeOpinion, у него же видосиков, по-моему, много бывает, мне кажется. Да, да, ну и у Йовановича тоже.
3972.80 3974.96 "Анатолий Кулаков" Ну, то есть они примерно на одном уровне рассказывают.
3974.96 3978.60 "Игорь Лабутин" Вот того, мне даже интересно стало посмотреть. Вот этого CodeOpinion я знаю.
3978.60 3994.20 "Анатолий Кулаков" Ну, давай, я пока буду рассказывать, а ты глянь. В общем, у меня они как-то на одном уровне подскакивают, и они вот такие. Пару авторов, у которых дофигича видосиков, все эти видосики рекламируют их собственные курсы, и у всех этих видосиков очень такие призывные заголовки, жёлтые заголовки, я бы даже сказал.
3994.20 3997.28 "Анатолий Кулаков" Не, погоди, ты с Чапсосом, мне кажется, путаешь.
3997.28 4008.60 "Анатолий Кулаков" Нет, ну, Чапсос нет, нет, нет. С Чапсосом я бы поспорил, потому что Чапсос всё-таки даёт минимум за минимум времени, максимум информации. Он довольно глубоко технически копает, и красиво копает. А это чистые популисты.
4008.60 4012.40 "Игорь Лабутин" Не, короче, Явановича я раньше не видел, давай так скажем. А вот этого самого, да,
4012.40 4019.84 "Анатолий Кулаков" CodeOpinion точно видел. Ну, ладно, давай. И, соответственно, что? Про популизм, да?
4019.84 4025.00 "Анатолий Кулаков" Всё время я натыкаюсь на их видосики, и ловлю себя на мысли, что очень хочется их посмотреть.
4025.00 4030.20 "Анатолий Кулаков" И когда смотрю, понимаю, что, как бы, ну, полный туфта, ну, ничего нового, ну, всё отстой.
4030.20 4076.84 "Анатолий Кулаков" И всё равно иногда ловлюсь. В общем, это я про что? Про то, что будьте осторожны, мы для вас выбираем самые лучшие, самые интересные статьи, но если вы вдруг пойдёте гулять по блогам этих авторов, то сильно не надейтесь. Несмотря на их прекрасные заголовки, внутри обычно находится полная чушь. Но, опять же, они собирают довольно популярные темы, и там, не знаю, какую-то пользу всё равно приносят. То есть, если вы находитесь на уровне джуна или медла, то, безусловно, эти авторы вам помогут. Да, если вы уже находитесь на уровне синьора, то, скорее всего, уже ничего не сообщат. Ну, и мы разберём одну из статейчик, определённые от opinion.com, она же видосик, наверное, который как раз будет полезный джунам и, может быть, чуть-чуть повыше, товарищам, которые уже знают всё-таки, что такое дебаг.
4076.84 4102.64 "Анатолий Кулаков" И статика называется API Error Messaging for Good Developer Experience. То есть, что же мы можем сделать такого полезного для того, чтобы разработка и, самое главное, дебаг были нам в радость и в пользу. Не сказать, что это список, опять же, самый большой, самый интересный, самый правильный, но что есть, если вы вдруг являетесь обладателем более полного интересного списка, присылайте.
4102.64 4246.36 "Анатолий Кулаков" Итак, пойдём за мануха. Когда мы разрабатываем и, главное, что ищем какие-то проблемы, то очень большой частью в разработческом мире является как раз-таки дебаггинг. И дебаггинг, и анализ тех сообщений, тех исключений, тех трейдсов, логов, которые случились у нас. То есть, не какой-то не success cases исследуем, а какие-то проблемы. И очень важно, когда мы это делаем, то, чтобы все вот эти сообщения, все эти отладки, все эти названия нам помогали. То есть, сообщения должны очень быстро и чётко давать понимать, что же, собственно, происходит. И поэтому вот автор решил собрать такие рекомендации, которые позволят вам сделать сообщения такими, чтобы они помогали отладке, чтобы удобнее было с вашим приложением общаться, когда вдруг что-то пошло не так. Первый пункт, на который он хочет нам указать, это то, что сообщения должны быть полезными, они должны иметь какое-то значение, они должны быть максимально описательными и в данный момент времени полезными. То есть, когда вы разрабатываете свой API, постарайтесь думать о тех разработчиков, которые увидят ваши сообщения. То есть, допустим, если у вас произошла какая-то ошибка, подумайте, а что тот разработчик, который эту ошибку увидит, должен с этой ошибкой сделать. Каким-то образом попробуйте помочь ему пойти в правильном направлении. Ну, например, прежде всего, это сообщение должно быть хорошо структурированным, хорошо должно описывать, что, собственно, произошло. Но самое главное, что оно должно описывать не только хорошо, что, собственно, произошло, но и что дальше делать с тем, что произошло. И, в пример, автор приводит N-Service Bus. И там, если вы вдруг неправильно отконфигурируете N-Service Bus, то есть, в частности, его storage, вам, например, вывалится ошибка, которая сообщает нам не только о том, что, собственно, случилось, но и явно нам говорит, что нам нужно сделать. Для примера, если мы вдруг отконфигурировали неправильный storage, то вываливается ошибка, которая говорит, что выбранное хранилище не поддерживает Outbox. Вы можете или выбрать другое хранилище, которое поддерживает Outbox, или выключить требование Outbox для хранилища, и тогда Outbox'а у вас не будет, но хранилище это вы сможете использовать. Опять же, прекрасное сообщение.
4246.36 4401.84 "Анатолий Кулаков" Во-первых, оно нам рассказывает, что случилось, в чем проблема, почему мы не можем запуститься и взлететь, а во-вторых, оно нам дает рекомендации, как мы можем это сообщение побороть. То есть, мы можем выбрать или пойти налево, или пойти направо, но в любом случае у нас уже есть какие-то планы по дальнейшим действиям, и это прекрасно. К сожалению, автор сетует на то, что современные разработчики на практике возвращают все время какие-то уродские ошибки, по которым вообще непонятно, что случилось. Никакого полезного сообщения в большинстве случаев не бывает, и это большая проблема всей индустрии, поэтому мы должны собраться, поднатужиться, послушать автора и исправить индустрию, предоставляя хорошие красивые описательные ошибки. Следующая рекомендация, которая есть у автора - это будьте более явными. Что имеется в виду? Здесь даже не более явными, наверное, а более конкретными или правильными. Короче, давайте разберем на примере. Он приводит, опять же, один-единственный пример, по которому сложно понять, что он еще имеет в виду, но этот пример довольно пописательный. Очень часто к нам приходится обращаться к коллекциям, и когда мы обращаемся к коллекциям, перед нами часто стоит ситуация, когда мы хотим выбрать из нее один-единственный элемент. И для этого мы можем использовать, в большинстве случаев используем, методы single или метод first. И большинство разработчиков не знает, какая между ними такая особая уж разница бывает, поэтому они не придают особого значения, что они вызовут. В нашем же случае, если вы хотите убедиться, что в коллекции существует только один-единственный элемент, удовлетворяющий вашим критериям, то по-любому вам нужно использовать single. И это в том числе потому, что он предоставляет более полезное исключение, которое позволяет вам не только отдебажить проблему, то есть не только понять в дебаге, а что собственно случилось, почему возникла проблема, но в то же самое время он показывает, что разработчик, который использует single, он заботится о потенциальном нарушении целостности данных. Для сравнения, если мы будем использовать first вместо single, то вот этот first, он может вам скрыть те проблемы, которые у вас есть с данными, в отличие от single. Ну, например, если вы рассчитываете, что пользователь с таким email у вас всегда один, и никаких ситуаций, что у вас их два, быть не может. Вы думаете, ну я как разработчик могу вызвать хоть first, хоть single, ведь у меня никогда двух таких пользователей быть не может. Но на самом деле это семантическая ошибка. На самом деле вы должны вызвать именно single, потому что именно single показывает то, на что вы рассчитываете, что у вас два таких пользователя быть не может.
4401.84 4421.88 "Анатолий Кулаков" И именно single выдаст вам правильное исключение, когда у вас в системе почему-то появится два таких пользователя. Ну не появится прекрасно, исключение он вам не выдаст, но если вдруг появится, вот тогда вы своим использованием single подскажете тому человеку, который увидит это исключение, где проблема. А проблема как раз в том, что система не ожидала появления двух пользователей.
4421.88 4438.12 "Анатолий Кулаков" Если же вы будете юзать first, то никакой проблемы не будет. Система вам скроет эту ошибку. Она просто возьмет первого попавшегося пользователя и продолжит дальше с ними работать, что в большинстве случаев является именно бизнес-ошибкой, что гораздо страшнее, чем просто какая-нибудь runtime-ошибка.
4438.12 4447.20 "Анатолий Кулаков" Потому что бизнес-ошибка может привести к такой ситуации, когда вы еще денег этому кастомеру останетесь должны. Поэтому в этом случае гораздо лучше упасть. Чем раньше упасть, тем лучше.
4447.20 4477.16 "Анатолий Кулаков" Следующая рекомендация - это постарайтесь сопровождать разработчика по успешному пути и уменьшать неправильный пути. То есть предоставить механизм, который позволит ему пройти легкий успешный путь легко и не двинуться в неправильную, неуспешную сторону сложно. Опять же, заголовок мало соответствует контенту, но давайте на практике рассмотрим, потому что практические примеры нормальные.
4477.16 4525.08 "Анатолий Кулаков" Когда вы дизайните свой API, то у вас очень часто может быть всякие ложные срабатывания и отвлекающие какие-то моменты. Ну, например, вы можете бросать исключения в тот момент, когда вам их бросать не нужно. Если вы дебажите и пытаетесь дожиться до какой-то проблемы, до какого-то там своего исключения, часто бывает такое, что роясь к тому исключению, которое вы хотите достать, вам в лицо постоянно выскакивают какие-то другие эксепшены, какие-то другие исключения. Допустим, вы вроетесь к системной ошибке, там у вас почему-то null reference exception где-то стрельнул, а вам тут выскакивает там то bad аргумент, то какой-нибудь возраст больше нуля, то возраст отрицательный, вот такие какие-то бизнесовые ошибки, которые вы хотели бы, наверное, заигнорить. В общем, они вас сейчас не очень интересуют, вы пытаетесь отладить более важную там какую-то проблему, прям исключительную ситуацию.
4525.08 4640.36 "Анатолий Кулаков" И в этом случае автор говорит, что исключение – это как минное поле. Вы постоянно не знаете, из какого метода какое исключение на вас стрельнет, и вам невозможно это предсказать. И в большинстве случаев это мешает отладке. Он намекает на концепцию, что исключительные ситуации должны представляться в виде исключений, а неисключительные ситуации, то есть то, что у вас считается нормальным в приложении, например, валидация пользовательского ввода. Они не должны считаться исключениями, они должны оборачиваться в какой-нибудь validation тип. Ну, для примера, например, тип result. Мы уже миллионы раз обсуждали в нашем подкасте тип result. Это как раз классик, который предоставляет вам два варианта. Или у вас что-то хорошо, и тогда он вам отдает результат этого хорошо, или что-то плохо, и тогда он может отдать вам описание этого плохо. Преимущество этого файлика, этого классика в том, что он хорошо заменяет exceptions. Вам не нужно бросать exceptions, вы можете просто вернуть этот результат, и вызывающий код уже сам сможет проанализировать и понять, что же, собственно, произошло. Таким образом, вы можете нормально дебажиться без каких-то левых исключений, и при этом ваше приложение по-прежнему продолжит обрабатывать и возвращать какие-то ошибки, при этом не пользуясь исключением. Такой код получается более явным, то есть вы явно сообщаете по сигнатуре метода, что никакого минополя там нет. Если какая-то проблема будет, то вам вернется результат, и в большинстве случаев это действительно удобнее смотреть, удобнее дебажить. Единственная проблема с этим, что это ужасно выглядит. Если вы начинаете этим пользоваться, нормальные люди с человеческой психикой долго этого не выдерживают. Но я думаю, о результатах мы с вами поговорим в будущем, потому что Andrew Locke начал замечательную статью про результаты, и мы обязательно эту статью обсудим. И там уже подробнее со всеми доскональными выхлопами, его мнениями, библиотеками, там уже всё это обсудим. Не то, что там статья,
4640.36 4652.04 "Игорь Лабутин" там на самом деле прям серия статей. Это не вместилось в одну, там три. Он сначала обещал три статьи, но, по-моему, не влез в три, и, по-моему, вышла четвёртая уже. Так что там есть что
4652.04 4723.52 "Анатолий Кулаков" пообсуждать. Тема богатая, как бы не первый уже год существует, как бы везде мусолят, но надо досконально разобраться. Но в данном нашем конкретном случае, опять же, мы говорим с вами про то, как не мешать разработчику дебажить. И в данном случае, если мы не будем выбрасывать исключения, мы, грубо говоря, будем не мешать ему дебажить. Но если вы вдруг продвинутый разработчик, и вы понимаете, что в Visual Studio и в Rider есть настройки, то какие исключения ловить, а какие исключения не надо ловить, то вы для себя откроете окно эксепшенов, и там галочками можете выбрать, какие эксепшены вам нужны, какие интересные, а какие неинтересные. И обычно так и решается такая проблема. Итого, вот автор вам насоветовал тут всего интересного. Да, ещё одну штуку, которую он явно не прописывает в статье, но упоминает её в видосике, это использование проблем детейлсов, опять же, которые сегодня уже были упомянуты. Это так случайно совпало, что мы сошлись, и автор говорит, что да, это стандарт. И если вы поможете диагностировать проблемы в вашем приложении с помощью стандартов, которые все разработчики привыкли, все инструменты привыкли, все ожидают, то это тоже прекрасно. Придерживайтесь этого, используйте это.
4723.52 4751.84 "Анатолий Кулаков" В общем, вот такие рекомендации, опять же, какие-то вырванные из контекста. Наверняка можно собрать более человеческий, более интересный, более правильный список. Но если у вас вдруг такой список есть, присылайте, мы обязательно такие статьи обсудим. И вообще, присылайте нам больше статей, которые бы вы хотели, чтобы попали в наши выпуски. Но в целом, если вы никогда вдруг не задумывались о том, как возвращать эксепшены, как работать с понятными месседжами, что было бы неплохо туда заносить, что не надо было заносить. В общем, в принципе, статья,
4751.84 4813.88 "Игорь Лабутин" с которой можно оттолкнуться. Ну и отлично. Так, на сегодня у нас есть ещё одна статейка, к которой мы имеем некоторые прямое, косвенное, ну в общем, какое-то отношение мы имеем. И Эндрю Лог, кстати. Да прямое отношение. И Эндрю Лог тоже имеет упомянутое. Это книжка Эндрю Лога «Эсперант-корр в действии», которую мы перевели, ну точнее, вычитали, перевели и выпустили. И это не повтор старой книжки, это новое третье издание. Эндрю Лог, соответственно, выпустил новое третье издание «Эсперант-корр в действии», которое было переведено, вычитано сообществом DotNet.ru. И теперь его можно купить. Так что, если вам интересно почитать про «Эсперант-корр», там обозревается DotNet 7. И это довольно существенное обновление по сравнению с прошлым вторым изданием, потому что как раз именно в нём добавили всякие minimal API и вот это вот всё, что появилось нового. Мне кажется, что даже в восьмом ДотНете она всё ещё, и даже в девятом она всё ещё будет актуальна. Поэтому не надо бояться того, что она про седьмой ДотНет. Принципиально как-то там
4813.88 4826.00 "Анатолий Кулаков" ничего, мне кажется, не поменялось. Нет, вообще не поменялось, мне тоже кажется, что актуально. И опять же, отвечая на вопрос, стоит ли брать, если вдруг у вас есть предыдущая версия, мне кажется, стоит. Ты вот как оцениваешь количество изменений,
4826.00 4895.32 "Игорь Лабутин" которые появились в предыдущей редакции? Когда нам прислали эту книжку на оценку того, чего будет перевод, мы так посмотрели, ну, посмотрели, но оглавление как бы существенно перекроили, по-моему, я сейчас боюсь наврать, но по-моему в старой книжке во втором издании было типа 19 глав, в этой 36. Но видно было, что они не то что повторяются, ну, в смысле, что какие-то главы разбились на более мелкие, но просто чуть более структурно вели, вроде, казалось бы, и всё. Но когда мы, так сказать, приступили к переводу и разбили книжку на главы, как мы это обычно делаем, на файлики и так далее, в общем, оказалось, что книжка эта, в общем-то, почти сравнима с Кокосой. А это, пожалуй, была самая большая, которую мы когда-либо переводили, то есть там почти. Я не помню, что получилось в русском переводе, но в английском там почти тысяча страниц в итоге в английской книжке. Она огромная, то есть вторая была на треть, наверное, меньше, на четверть меньше. Там довольно много всего добавилось. И это не только minimal API. Так что кажется, что, наверное, если вы читаете книжки, если вы по ним изучаете, то иметь третью версию третьей издания будет полезно.
4895.32 4905.40 "Анатолий Кулаков" Вы наверняка там что-нибудь почерпнете. Ну и интересно отметить, что мы с метапами ходим как раз в различные компании Санкт-Петербурга. Я всё чаще и чаще в компаниях наблюдаю на полках.
4905.40 4910.40 "Анатолий Кулаков" Вот эти наши книги, особенно Эндрю Лока там весьма любят. Поэтому в библиотеку для компании
4910.40 4928.44 "Игорь Лабутин" просто брать по две. Ну, кстати, да, можно действительно так и делать. В общем, мы продолжаем, мы работаем. Возможно, будут ещё какие-то книжки. Поглядим. Пока обещать ничего не можем. Но те, которые уже вышли, ищите, берите, покупайте. Нам будет приятно.
4928.44 4965.40 "Анатолий Кулаков" Также присылайте ваши комменты, вдруг если у вас к переводу что-то, будет какие-то замечания. Если у вас есть, например, книги, которые вы бы хотели, чтобы были переведены на русский. Важно, чтобы они ещё до этого, естественно, не были переведены. То тоже приходите, присылайте. У нас есть специальный чатик для переводчиков. Туда можно добавляться не только переводчикам, но и если вы просто сочувствующий, хотите наблюдать за новостями, хотите просто поучаствовать в дискуссии, тоже добавляйтесь. И если вы особенно хотите попереводить с нами новые книги, хотите вычитывать, хотите участвовать в этом процессе, то обязательно тоже добавляйтесь, пишите. Мы скоро будем выбирать новую книгу, и наверняка вы можете попасть в ту тему, с которой вам было бы интересно поработать.
4965.40 4974.24 "Игорь Лабутин" Ну да, ну что, кратко о разном и заканчиваем. Да, давай, тем более там всего-навсего парочку
4974.24 5076.56 "Анатолий Кулаков" всяких кратких ссылочек, которые хотелось бы вам рассказать. Прежде всего, это вышла библиотека от Microsoft, в превью вышла, в превью, Microsoft Extension VectorData. А Microsoft начал свои экстеншены гнать во все поры. И точно так же, как и другой экстеншен, который мы обсуждали, допустим, в предыдущем выпуске, это своеобразная абстракция. Давайте понемножку расскажу, что такое VectorData. VectorData - это специальная библиотека абстракций для C#, которая позволяет работать с векторными хранилищами. А вот что такое векторные хранилища? Это довольно важная часть для работы с искусственными хранилищами для искусственного интеллекта. Векторные хранилища, они как раз построены специально для хранения векторов, не поверите. То есть, точно так же, как у нас есть реляционные базы данных, есть документно-ориентированные базы данных, которые используются для таких человеческих данных, для документных данных. В общем, для хранения тех коэффициентов, которые рассчитали наши искусственные интеллекты, им тоже нужны специальные базы данных, которые позволят их сохранить, а также индексировать, очень компактно хранить, компактно для их размеров хранить, а также обрабатывать эти данные. И для всего этого нужны специальные хранилища. Вот Microsoft выпустил абстракцию над подобными хранилищами, и эта абстракция умеет базовые операции, допустим, создание, чтение, обновление и удаление векторов из этого хранилища. А также, немаловажно, она умеет делать поиск, поиск вектора, а также текстовый поиск по этим хранилищам. То есть, она предоставляет абстракции для того, чтобы это делать. А конкретные реализации уже каждый конкретный движок заимплементировал у себя.
5076.56 5156.44 "Анатолий Кулаков" В общем, такая хорошая абстракция, которая позволит авторам библиотеки не загоняться над конкретной версией, а писать, использовать у себя в коде именно абстракции, а конкретным реализаторам уже предоставлять провайдеры на основе какого-то стандартного протокола, что тоже не может не радовать. Другая новость, которая у нас есть, опять же, продолжаем цепочку с прошлого выпуска. Мы в прошлом выпуске обсуждали enum-чики и как из этих enum-чиков сделать более такие мощные enum-чики. И упомянули там библиотеку, который один из наших слушателей использовался. И у нас нашелся еще один слушатель, который не просто пользовался, а написал одну из библиотек, которая называется DoSharp, то есть Discrimination Union Sharp. И эта библиотечка, как несложно догадаться по названиям, как раз-таки создана для того, чтобы с помощью Source-генераторов генерить вам Discrimination Union в C#. Все хотят Discrimination Union, а авторы Микрософта утверждают, что никому не нужны, противоречат концепции. Да вот, все делают просто на коленках у себя. Библиотечка хорошая, мощная, то есть она тоже позволяет вам в удобном, простом стиле объявить Discrimination Union. Можно использовать там атрибуты, можно использовать partial методы, поддерживается pattern matching, эквалентика, сравнение сгенеренных классов, есть дженерики. Ну, в общем, все, что вы ожидаете увидеть, в принципе, от подобной штуки, все есть.
5156.44 5233.68 "Анатолий Кулаков" Поэтому посмотрите, возможно, в вашем проекте, где вам нужны более мощные enum-чики или Discrimination Union, эта библиотечка тоже вам поможет. Кстати, да, не enum-чики, наверное, все-таки. Ну, можно Discrimination Union, да, натянуть на enum-чики, но все-таки это больше про Discrimination Union, чем про пауэрные enum-чики. И вот, библиотечка хорошая, я посмотрел, потыкал, выглядит прекрасно. И описание тоже естественно. Посмотрите, завязайте. Что я хотел добавить? У нас что-то появляется среди наших слушателей очень много интересных авторов библиотек, поэтому можно такой еще призывчик сделать. Друзья, если у вас есть какая-то open-source библиотека, и вы считаете, что ей можно поделиться сообществом, то есть не стыдно показать, то пишите нам, мы обязательно ее порекламируем. Естественно, если она будет прилично выглядеть, у нее будет там ритмичка, тесты, понятное целеполагание, для чего она нужна, то есть будем развивать, смотреть, какие у нас библиотеки есть среди наших слушателей. Я думаю, при прочих равных, почему бы не выбрать библиотеку, автор которой, вы знаете, слушает хорошие подкасты и наверняка использует различные best practices, которые мы здесь советуем. Поэтому если у вас есть какие-то open-source библиотеки, open-source проекты, присылайте нам подкасты. Будем смотреть, будем слушать,
5233.68 5239.20 "Игорь Лабутин" а некоторые из них будем рекламировать. Все так, очень ждем. На сегодня будем заканчивать.
5239.20 5288.48 "Игорь Лабутин" Новостей сегодня не было. Пообсуждали статьи, вспомнили про experimental attribute из C# 12, попытались разобраться немножко в баручекере Rust, надеюсь, что получилось хоть что-то понятное. Подробнейшим образом обсудили, как и зачем использовать problem details в ASP.NET для возвращения разных проблем и ошибок. Посмотрели на сравнение производительности minimal API и обычных контроллеров, что там почти нет разницы. Немножко порассуждали на тему того, как должны выглядеть хорошие ошибки в API. Ну и не только в API, на самом деле, просто хорошие ошибки для пользователей. Ну не напомнили, а рассказали, что вышла книжка ASP.NET Core в действии третьего издания в правильном переводе. Ну и кратенько пробежались по паре коротеньких новостей про библиотечки.
5288.48 5294.88 "Игорь Лабутин" На этом на сегодня все для 103-го выпуска. Да, хороший такой объемистый насыщенный
5294.88 5299.68 "Анатолий Кулаков" выпуск был. Надеюсь, вам тоже понравилось. И всем до новых встреч, пока! Всем пока!
