0.00 8.50 "Анатолий Кулаков" Здравствуйте, дорогие друзья! В эфире Радио Дотнет и 15 выпуск уже с вами.
8.50 76.96 "Анатолий Кулаков" Прежде всего, хотелось бы поблагодарить всех тех, кто откликнулся поучаствовать в нашем конкурсе. Мы разыграли много лицензий JetBrains, у нас очень много новых слушателей. В общем, за это вам большое спасибо и не забывайте нас также шарить, комментировать и рассказывать друзьям. Нам это очень приятно и сейчас мы уже видим, что подкаст интересен, подкаст слушают и нас все время слушают все больше и больше. И это сильно мотивирует нас на продолжение нашего дела. Но оказалось, что лицензии JetBrains нужны не всем, так как парочку победителей из Твиттера до сих пор еще не откликнулись. Поэтому, друзья, если вы нас слушали и участвовали в розыгрыше в Твиттере, пожалуйста, обратите внимание на мои сообщения вам и ответьте, пожалуйста, мне на них и заберите, пожалуйста, вашу лицензию. К сожалению, лицензии испарятся, поэтому долго мы вас ждать не будем, но, наверное, еще пару неделек подождем. Иначе придется их отдать кому-нибудь другому. Ну что ж, инфраструктурная часть закончилась, давай перейдем к новостям. Да, поехали. Первое, что мы хотим
76.96 83.96 "Игорь Лабутин" рассказать, это конференции. У нас начинается осенний сезон. Да, все вернулись с отпусков,
83.96 100.48 "Анатолий Кулаков" лето закончилось, пора просвещаться. И конференций вокруг очень много. И, наверное, одна из ближайших - это TechTrain. TechTrain 2020 осень. Если вы не знаете, то TechTrain - это такой огромный питерский фестиваль. Мне кажется, это самый большой питерский IT-фестиваль, который у нас есть.
100.48 131.64 "Анатолий Кулаков" Он до этого проходил два раза в оффлайне и один раз уже в онлайне. На нем обычно собираются просто айтишники всех мастей, кто только возможен там. И, естественно, все языки программирования представлены, плюс какие-то геймдевы, анализаторы, подкасты. В общем, все, что только связано с айти, все там. И это довольно интересно, потому что интересно было общаться с разношерстным народом, узнавать, как у них дела, устраивать какие-то совместные дискуссии между разными языками.
131.64 201.84 "Анатолий Кулаков" То есть мероприятие просто обалденное было. В онлайне, к сожалению, всего этого веселья не получится, но остался прежний формат. То есть такой IT-фестиваль, который будет интересен широкому кругу зрителей для повышения кругозора. И самое прекрасное, что в онлайне он бесплатный. Всего будет 8 докладов. Это фестиваль на один день. Как я уже сказал, отличный способ улучшить свой кругозор и посмотреть, что происходит в других платформах, на других технологиях. Можно будет пообщаться с сетиномышленниками и можно будет бесплатно оценить платформу, которую пилит Jougroup, потому что техтрейдинг делает именно он. Это вам будет очень полезно, потому что сейчас начинается осенний сезон конференции от Joug. И там будет много полезных, качественных конференций, в том числе .NET. Если вы все еще сомневаетесь, зайдет ли вам онлайн формат или нет, то техтрейдинг - это, в общем, самый лучший способ проверить. Потому что вы посмотрите, как это происходит, куда тыкаются кнопочки, как идут докладчики, как общаются эксперты. Сможете сами поговорить, попробовать свой connection. В общем, ощутить все это на себе, но бесплатно. А вот мы же все-таки .NET подкаст.
201.84 222.92 "Анатолий Кулаков" Там .NET-то будет или все будут другие платформы? Нет, вписались наши .NET-чики. Из известных можно вспомнить Андрея Киншина, Дмитрий Иванов, Кирилл Скрыган. Вот эта троица будет представлять секцию .NET. С ними тоже можно будет пообщаться на фестивале. Прикольно. Это хорошо. Заходите,
222.92 228.40 "Игорь Лабутин" пробуйте, проверяйте и начнем конференциальный сезон. И если мы говорим про конференции,
228.40 239.52 "Анатолий Кулаков" нельзя не упомянуть про .NET. Да, Microsoft тоже в онлайне очень сильно разгоняется. Она все лето проводила какие-то конференции, всю весну проводила. В общем, Microsoft любит онлайн-конференции.
239.52 347.40 "Анатолий Кулаков" И следующая онлайн-конференция, которая называется .NET Conf 2020, она будет проходить в ноябре 10-12. И, может быть, вы ее даже никогда и не заметили, если бы не одна очень важная вещь. Именно на ней, на этой конференции будет представлен и запущен .NET 5. Все то, о чем мы с вами говорили последние полгода-год, наконец-то зарелизится. Я напомню, что это будет в ноябре 10-12. Конференция будет идти три дня. И на конференции будут представлены спикеры со всего мира, в том числе от сообщества. Но, конечно же, прежде всего интересна информация и новости от Microsoft. И от Microsoft выступят Скотт Хансельман, Мэтт Торгессон, Скотт Хантер и Карл Фрэнклин и многие-многие-многие другие. Это только часть фамилий, которые должны все знать. Конференция будет идти три дня. В первый день будет посвящен полностью новостям. Будут разобраны .NET 5 по косточкам и мы ждем много-много интересных анонсов. Второй и третий день будут идти стримингом 24 часа, чтобы все зрители во всех тайм-зонах могли насладиться какими-то свежими анонсами, докладиками и посмотреть, на что же там такого интересного мы наделали в этом .NET 5. Но это еще не все. После трехдневной конференции у Microsoft еще есть юзер-группы-венты. Они будут проходить с 13 ноября и вплоть до 31 января 2021 года. На этих локальных юзер-групп-эвентах будут опять же спикеры, докладчики, круглые столы обсуждать те же самые темы, перетирать, как мы будем жить теперь в новой реальности с .NET 5. И наверняка можно тоже в онлайне найти какие-нибудь интересные каналы, которым можно подключиться
347.40 480.48 "Игорь Лабутин" и посмотреть, и пообщаться. Ну, хорошо, значит, про конференции мы поговорили, теперь пришла пора поговорить про .NET 5. Потому что ровно недавно вышел .NET 5.0 Release Candidate 2. И надо сказать, что это хорошая новость по двум причинам. Первая причина - это последний из двух релиз-кандидатов перед официальным релизом в ноябре. А вторая - что уже сейчас вы можете использовать его в продакшене. Microsoft обещает вполне себе поддерживать релиз-кандидат в продакшене и утверждает, что уже несколько внутренних продуктов Microsoft внутри крутятся на .NET 5. РС2. Естественно, в РС2 не может быть никаких сильно больших нововведений, потому что это уже стабилизация, выпиливание последних багов и так далее. Поэтому в статье-анонсе про релиз-кандидат опять вспомнили некоторые большие фичи, которые были введены в .NET 5. И в данном случае повезло паттерн-матчингу. Вообще, паттерн-матчинг в C# завезли достаточно давно, но в девятом C# его сильно улучшили. Во-первых, добавили Relation of Patterns. То есть теперь можно паттерн-матчинги сравнивать чиселки через меньше-больше. То есть вы можете теперь писать паттерн-матчинг, что если вы матчитесь по, например, переменной типа int, то вы теперь можете писать в качестве паттерна там меньше 20, и он будет срабатывать, если значение меньше 20. Для того, чтобы их было удобнее использовать, добавили логические паттерны. А чтобы компилятору было проще разбираться и не пытаться понять, что вы там имели ввиду в условиях, вместо and и or операций, как мы знаем, по конструкции if в виде двух амперсандов или двух вертикальных черт, будут использовать обычные слова and, or и not. "Здравствуй, Паскаль". Мне это почему-то напоминает Паскаль. Я вот на нем начинал писать, и там такое было. Ну, в SQL далеко не ушли. Да, в SQL оно как-то воспринималось органично, а вот в Pascal мне оно было даже тогда немножко странно, что ли. А в C# тем более. Ну, посмотрим. Хотя некоторые примеры, которые я видел в статьях в Twitter, они прям немножко
480.48 484.48 "Анатолий Кулаков" выносят мозг пока еще. Посмотрим, что ты скажешь через годик, когда уже привыкнешь к этим
484.48 530.88 "Игорь Лабутин" операторам и будешь читать их нативно. Ну, для этого надо начать писать на C# в девятом. Я пока не уверен, что мы готовы на 2.5 переходить, но посмотрим. И последнее, что хочется хайлайтить, это простые паттерны типов. То есть раньше, когда вы в паттерн-матчинге хотели указать, что вот этот паттерн должен сработать, когда переменная того или иного типа, вы должны были всегда написать там имя типа и переменную обязательно. Теперь можно имя переменной не писать, можно не писать там знак подчеркивания, а просто написать имя типа. И этот случай будет срабатывать, если аргумент того, что вы проверяете, соответствует тому типу, который вы написали в паттерне. Это удобно, как мне кажется, и чуть меньше строк. Лов. Мне очень нравится, как они
530.88 577.24 "Анатолий Кулаков" размазали паттерн-матчинг, ну то есть нужно понимать, что это безумно сложная штука, которая требует под собой кучу нововведений языка, кроме непосредственно самого паттерн-матчинга. Ну такие как рекорды, not nullable types и много-много-много всего другого. Вот, и они размазали это между несколькими версиями C#. То есть они внедрили там какие-то базовые концепции еще там в 7, потом уже хороший такой паттерн-матчинг сделали в 8, и в 9 уже начинают добивать вообще мега такими крутыми фичками, которые уже можно сравнивать наверное с функциональным языками. То есть, наверное, в нашей среде первый раз настолько большая массовая штука была внедрена и не за один раз, не за один год, а прямо в течение нескольких релизов. Очень интересно продобледать. Интересно
577.24 583.32 "Игорь Лабутин" узнать, это был стратегический план или это так хорошо и удачно получилось. Надо будет спросить
583.32 588.76 "Анатолий Кулаков" Торгерсона. Да, у нас будет такая возможность. Я думаю, скоро мы узнаем эти фишки. Окей, погнали
588.76 669.16 "Игорь Лабутин" дальше. ClickOnce. Мы упоминали в одном из прошлых выпусков, что Microsoft решился оживить ClickOnce и действительно он ожил. И теперь у нас есть подробности, в каком виде он ожил. Его, во-первых, переписали на .NET, то есть тот самый тул, которым вы пользовались для создания ClickOnce, это Mage. Это теперь .NET тул, его можно поставить из Nuget, как GlobalTool, Microsoft.dotnet.mage и использовать его для генерации ваших ClickOnce. Я не удивлюсь, если он написан тоже на .NET теперь, хотя не факт. Его немножко подрезали, в нем теперь не поддерживается SHA-1 подписи и не поддерживается то, что называлось Partial Trust, но вероятно, это и правильно с точки зрения security и всего остального. Во всем остальном, ClickOnce похож на все то, что вы знаете про ClickOnce. Пока и поддержан только Framework Dependent Apps, то есть он требует обязательно наличия фреймворка, поставленного на целевую машину, и он будет его ставить в качестве пререквизита, если у вас его вдруг нет. То есть запустив сетап XE, вам на runtime будет поставлен, но в планах есть добавить self-contained приложение или даже single-file приложение, которое тоже добавили в .NET 5. Это будет выпущено чуть-чуть позднее после .NET 5 основного релиза в виде то, что они называют Servicing Release. А сам ClickOnce стал кроссплатформным?
669.16 683.92 "Игорь Лабутин" Я могу им на Linux пользоваться? Нет, ClickOnce пока только Windows, и я не уверен, что он собирается быть каким-то кроме Windows. Я так понимаю, что это скорее больше для того, что раз притащили VPF и Forms, то давайте теперь притащим и то, как их распространять.
683.92 688.44 "Анатолий Кулаков" Ну то есть ты думаешь, что это только для UI-ных приложений, только для формочек?
688.44 690.76 "Анатолий Кулаков" В консоли тут никакого смысла его использовать нет?
690.76 699.92 "Игорь Лабутин" Я думаю, что да, это исключительно для UI и для формочек, тем более, что ClickOnce при запуске всегда UI показывает, старается, по крайней мере, автоапдейтер он будет показывать.
699.92 726.88 "Игорь Лабутин" И надо сказать, что в ClickOnce были всякие фичи типа апдейтов автоматических или не автоматических, и мы упоминали в прошлый раз, что возможно что-то уберут и оставят, например, только возможность автоапдейтов, но если верить статье, то в Microsoft оставили все существующие фичи про апдейты и все должно работать. То есть проверяйте, смотрите, что получилось, генерите новые ClickOnce и распространяйте ваши приложения. Должно работать.
726.88 731.52 "Игорь Лабутин" Третий хайлайт в этой статье, он про Windows ARM64.
731.52 738.84 "Игорь Лабутин" DotNet 5 SDK теперь поддерживает Windows ARM64, но, к сожалению, пока нет WinForms и WPF приложений.
738.84 749.08 "Игорь Лабутин" То есть все, что вы можете собирать с помощью DotNet 5 SDK на ARM64, это консольки, это ASP.NET Core и, пожалуй, все. Ну, Delic, понятное дело.
749.08 754.92 "Игорь Лабутин" Больше ничего, и, опять же, Windows Forms и WPF должны завести попозже, когда, видимо, допили до конца.
754.92 760.52 "Игорь Лабутин" Продолжим про DotNet 5 и, как обычно, перейдем к ASP.NET Core 5.
760.52 774.48 "Игорь Лабутин" Тут чуть-чуть есть улучшение изменений. Во-первых, в Blazor добавили изоляцию CSS-файликов, то есть теперь для разных компонент генерятся индивидуальные CSS-файлы, и они не смеживаются в один большой, насколько я понимаю.
774.48 787.00 "Анатолий Кулаков" Они тебе делают изолированный компонент, то есть те CSS-стили, которые ты объявил возле своего компонента, возле своего Razor файла, они теперь не будут влиять на все другие компоненты.
787.00 790.24 "Анатолий Кулаков" Ну, у нас CSS, он такой, довольно заразный.
790.24 797.16 "Анатолий Кулаков" Если вы сказали, что заголовки h1 теперь должны быть зелеными, то значит у вас во всем приложении теперь заголовки будут зелеными.
797.16 802.08 "Анатолий Кулаков" Вот этот как раз fix исправляет такую штуку, то есть он позволяет сделать настоящие компоненты.
802.08 815.64 "Анатолий Кулаков" Если мы написали разметку в Razor, и к этой разметке только написали CSS, и сказали, что у него будут все заголовки зелеными, то компилятор сделает так, чтобы эти стили были уникальными только для этого компонента.
815.64 819.32 "Анатолий Кулаков" И у вас только внутри этого компонента все заголовки будут зелеными.
819.32 821.52 "Анатолий Кулаков" Никак это не повлияет на другие компоненты.
821.52 823.52 "Анатолий Кулаков" То есть это делает такую более мощную изоляцию.
823.52 828.80 "Игорь Лабутин" Если вы, я так понимаю, явно не включите эти style-файлы в другие места.
828.80 830.80 "Игорь Лабутин" Если вы явно этого не захотите, конечно.
830.80 836.64 "Игорь Лабутин" Второе улучшение тоже вокруг Blazor - это добавили улучшения в дебаггинге.
836.64 851.60 "Игорь Лабутин" Складывается ощущение, что они практически написали дебаггинг, и раньше им пользоваться, получается, было не очень возможно, потому что появились такие фичи как inspect_locals, stepover для sync-методов, и всякие такие мелкие вроде как штуки, но которые довольно часто в дебаггинге используются.
851.60 853.60 "Игорь Лабутин" В общем, Blazor должно стать отлаживать удобнее.
853.60 862.08 "Игорь Лабутин" И самая большая штука - это то, что теперь весь .NET 5 API размечены на тему compatibility для браузеров.
862.08 865.92 "Игорь Лабутин" То есть теперь для каждой API известно, поддерживается она на браузере или нет.
865.92 882.92 "Игорь Лабутин" И, соответственно, розлайн-анализаторы, которые проверяют, насколько та или иная API поддержана в той или иной target среде, теперь знают, что если вы компилируетесь для Blazor, то есть для браузера, то вот те или иные API, например, какой-нибудь, не знаю, регистр, недоступны.
882.92 884.36 "Игорь Лабутин" Так что пользуйтесь.
884.36 888.28 "Игорь Лабутин" EFCore - тут ничего нового, просто несколько bugfixes и всё.
888.28 891.72 "Игорь Лабутин" EFCore практически стабилен и там только допиливают баги.
891.72 892.68 "Игорь Лабутин" Такие новости.
892.68 893.68 "Игорь Лабутин" RC2.
893.68 902.92 "Анатолий Кулаков" Ну отлично, у нас как-то уже слишком много UI, и у меня тоже такая темка про UI, называется Windows UI Library Roadmap.
902.92 908.28 "Анатолий Кулаков" Я не очень много сталкивался с UI, почти совсем не сталкивался.
908.28 912.08 "Анатолий Кулаков" Поэтому мне было бы интересно просто посчитать, посмотреть, что у них там происходит.
912.08 915.72 "Анатолий Кулаков" Предлагаю вам все вместе разобраться, что же у них там сейчас такое есть.
915.72 916.92 "Анатолий Кулаков" Итак, WinUI.
916.92 923.00 "Анатолий Кулаков" Оказывается, что WinUI - это нативный интерфейс для Windows 10.
923.00 927.44 "Анатолий Кулаков" Сейчас актуален WinUI 2, то есть 2-го поколения.
927.44 931.88 "Анатолий Кулаков" Это специальный визуальный слой, который построен поверх операционной системы Windows 10.
931.88 934.76 "Анатолий Кулаков" Никак от неё не отрывается и работает только там.
934.76 940.48 "Анатолий Кулаков" В планах есть в Roadmap сделать WinUI 3, то есть 3-го поколения.
940.48 948.76 "Анатолий Кулаков" Это новый подход, который позволяет разделить операционную систему и как раз слой рендеринга.
948.76 952.08 "Анатолий Кулаков" То есть как раз-таки тот слой, который отвечает за визуальную составляющую.
952.08 961.84 "Анатолий Кулаков" И благодаря этому под WinUI 3 смогут запускаться не только UIP-приложения, как было во 2-м поколении, но и также Win32-приложения.
961.84 965.40 "Анатолий Кулаков" Итак, какие бенефиты есть у WinUI?
965.40 971.72 "Анатолий Кулаков" Прежде всего, это нативный, настоящий официальный UI для Windows.
971.72 974.52 "Анатолий Кулаков" То есть он очень сильно оптимизирован.
974.52 977.40 "Анатолий Кулаков" На нём проведены сотни тысяч и миллионов тестов.
977.40 980.88 "Анатолий Кулаков" Он работает на более миллиарда устройств с Windows 10.
980.88 989.92 "Анатолий Кулаков" И это не только PC, но это также Xbox, HoloLens, Surface Hub и прочие-прочие девайсы от Microsoft.
989.92 994.12 "Анатолий Кулаков" Далее, WinUI использует самые последние новения в Fluent Design.
994.12 998.24 "Анатолий Кулаков" Это который раньше был Metro Design, потом ещё OctaVapier именовали.
998.24 1001.76 "Анатолий Кулаков" В общем, вот это микрософтовских красивых плавающих окон.
1001.76 1007.28 "Анатолий Кулаков" То есть у него там есть векторная анимация, эффекты, шейдеры, тени, подсветочки.
1007.28 1010.48 "Анатолий Кулаков" И всё как положено для настоящих красивых UI-чиков.
1010.48 1014.80 "Анатолий Кулаков" Ещё одна интересная фича в том, что у него есть Backward Compatibility.
1014.80 1023.84 "Анатолий Кулаков" То есть даже после того, как зарелизится WinUI 3-го поколения, вам не нужно ждать, чтобы пользователи поставили самые последние обновления Windows 10.
1023.84 1025.84 "Анатолий Кулаков" У них всё автоматически заработает.
1025.84 1028.48 "Анатолий Кулаков" То есть Backward Compatibility там довольно-таки хорошенький.
1028.48 1030.48 "Анатолий Кулаков" Поддерживается также нативная разработка.
1030.48 1038.24 "Анатолий Кулаков" То есть сам WinUI на 100% написан на C++ и может использоваться как из .NET, так и из кода на C++.
1038.24 1041.60 "Анатолий Кулаков" И у WinUI более частые апдейты.
1041.60 1045.36 "Анатолий Кулаков" То есть планируется, что апдейты будут поставляться каждые 4 месяца.
1045.36 1048.92 "Анатолий Кулаков" Что для такой громадной интербрайзной системы как Windows.
1048.92 1054.28 "Анатолий Кулаков" И для такого критически важного компонента как UI довольно хорошее решение.
1054.28 1060.32 "Анатолий Кулаков" И будем надеяться, что компоненты будут быстрее и больше и намного чаще.
1060.32 1065.28 "Анатолий Кулаков" Весь этот WinUI полностью open-source.
1065.28 1068.28 "Анатолий Кулаков" WinUI 2-й разрабатывается на GitHub уже давно.
1068.28 1072.76 "Анатолий Кулаков" WinUI 3-й планируют выложить буквально в течение месяца.
1072.76 1074.76 "Анатолий Кулаков" И тоже продолжить там разработку.
1074.76 1080.36 "Анатолий Кулаков" Итак, основное отличие WinUI 3-го, как я уже сказал, это оторванность от Windows 10.
1080.36 1082.36 "Анатолий Кулаков" И есть три вектора развития.
1082.36 1085.68 "Анатолий Кулаков" Во-первых, это модернизация существующих приложений.
1085.68 1091.24 "Анатолий Кулаков" То есть теперь WinUI компоненты можно встраивать внутрь существующих Win32 приложений.
1091.24 1096.80 "Анатолий Кулаков" То есть в своих .dpf, WinForms, MVC приложениях вы вполне можете использовать WinUI.
1096.80 1098.44 "Анатолий Кулаков" И обратно это уже верно.
1098.44 1101.68 "Анатолий Кулаков" Следующий путь это создание новых Windows приложений.
1101.68 1108.96 "Анатолий Кулаков" В этих приложениях вы можете выбрать платформу UVP или Win32.
1108.96 1113.52 "Анатолий Кулаков" И выбрать язык .NET или C++, которым хотите пользоваться.
1113.52 1118.04 "Анатолий Кулаков" Еще одной интересной фишкой это направление развития третьесторонних фреймворков.
1118.04 1122.76 "Анатолий Кулаков" То есть вы теперь можете подставить любую имплементацию.
1122.76 1129.80 "Анатолий Кулаков" Даже свою. Например, Microsoft в качестве proof of concept forkнул и пропатчил React Native.
1129.80 1133.64 "Анатолий Кулаков" То есть вы теперь можете на React Native писать нативные приложения под Windows.
1133.64 1136.44 "Анатолий Кулаков" Что, наверное, тоже для многих будет интересно.
1136.44 1141.76 "Анатолий Кулаков" Если говорить про статус, то сейчас WinUI 3 находится в стадии разработки.
1141.76 1145.04 "Анатолий Кулаков" Его текущая версия это Preview 2.
1145.04 1147.04 "Анатолий Кулаков" И релиз планируется в следующем году.
1147.04 1152.24 "Игорь Лабутин" Слушай, мы какое-то время назад обсуждали такую штуку как MyUI.
1152.24 1155.36 "Игорь Лабутин" Это кроссплатформенный новый UI от Microsoft.
1155.36 1158.80 "Игорь Лабутин" Меня интересует вопрос, а как это связано с WinUI?
1158.80 1168.16 "Анатолий Кулаков" Выглядит это примерно так, что MyUI - это непосредственно сам движок, на котором будет писаться логика и который будет кроссплатформенным.
1168.16 1172.96 "Анатолий Кулаков" А WinUI будет выступать в качестве бэкэнда.
1172.96 1181.16 "Анатолий Кулаков" То есть MAUI сможет использовать WinUI для того, чтобы отрендерить свои кнопочки, отрендерить свои менюшечки, красивую анимацию и так далее.
1181.16 1183.16 "Анатолий Кулаков" То есть это такой бэкэнд.
1183.16 1185.16 "Анатолий Кулаков" Бэкэнд для всяких графических движков.
1185.16 1193.52 "Анатолий Кулаков" В частности, уже сейчас он выступает бэкэндом для Unoplatform, который тоже такой кроссплатформенный UI-фреймворк.
1193.52 1199.04 "Анатолий Кулаков" И WinUI 3 используется им для отображения нативных виндовых компонентов.
1199.04 1202.92 "Игорь Лабутин" Ну, я думаю, что все-таки пока WinUI 2, мне кажется, наверное.
1202.92 1204.92 "Игорь Лабутин" 3-й, если еще при релизе.
1204.92 1206.92 "Игорь Лабутин" Да, наверное, ты прав, наверное, 2-й все-таки.
1206.92 1208.92 "Игорь Лабутин" Хорошо, ладно.
1208.92 1210.92 "Игорь Лабутин" Про UI мы поговорили.
1210.92 1212.92 "Игорь Лабутин" Давно мы, кстати, не говорили про UI.
1212.92 1215.92 "Анатолий Кулаков" Мне кажется, уже очень долго теперь не будем говорить про UI.
1215.92 1218.92 "Анатолий Кулаков" По-моему, UI-ные темы у нас кончились, и можно переходить к HardCode.
1218.92 1221.92 "Игорь Лабутин" Да, ну мы будем ждать релизов каких-нибудь UI-ов.
1221.92 1225.92 "Игорь Лабутин" Либо MAUI, либо WinUI, либо еще какой-нибудь BlaBlaUI.
1225.92 1227.92 "Игорь Лабутин" И тогда про них поговорим.
1227.92 1233.92 "Игорь Лабутин" Да, HardCode, HardCode, ну не такой уж HardCode, но важная тема, которую, мне кажется, стоит осветить.
1233.92 1241.92 "Игорь Лабутин" Вот мы много говорили про то, что у нас там DotNet релизится, DotNet 3, DotNet 2, DotNet Core имеется в виду, конечно, 2 и 3.
1241.92 1246.92 "Игорь Лабутин" Какие-то релизы бывают LTS, какие-то релизы бывают не LTS.
1246.92 1249.92 "Игорь Лабутин" И я подумал, что было бы полезно освежить немножко это все в памяти.
1249.92 1256.92 "Игорь Лабутин" Тем более, что близится релиз DotNet 5, и все будут снова спрашивать, какой же DotNet использовать, для чего и как долго он будет жить.
1256.92 1271.92 "Игорь Лабутин" Итак, вышла статья в блоге Microsoft, где они достаточно подробно описывают, как правильно расценивать все релизы, и как понимать, что же нужно использовать для ваших целей, для того, что вы пишете.
1271.92 1279.92 "Игорь Лабутин" Во-первых, DotNet Core и DotNet 5, соответственно, в будущем любой DotNet, всегда поставляется в нескольких видах.
1279.92 1288.92 "Игорь Лабутин" У него бывают мажорные релизы, такой, как у нас сейчас будет, или как был DotNet 3, DotNet Core 3, или DotNet Core 3.1.
1288.92 1293.92 "Игорь Лабутин" 3.1 - это как раз-таки был minor релиз, и еще бывают service updates, это патчи различные.
1293.92 1299.92 "Игорь Лабутин" В целом, существует всего 2, так называемых, трека для DotNet Core и DotNet.
1299.92 1310.92 "Игорь Лабутин" Один из них - это то, что называется current release, и с current releases ситуация такая - они поддержаны в течение всего периода до выхода следующего, мажорного или минорного релиза, плюс 3 месяца.
1310.92 1315.92 "Игорь Лабутин" То есть у вас есть, грубо говоря, 3 месяца, и переберегнут на следующий, мажорный или минорный релиз.
1315.92 1333.92 "Игорь Лабутин" Либо, если вы не готовы так быстро и срочно прыгать, то есть то, что мы часто называем аббревиатурой LTS, то есть long-term support release, которые поддержаны минимум 3 года или 1 год после следующего LTS релиза, смотря что там наступит позднее из этого.
1333.92 1349.92 "Игорь Лабутин" Ну и кроме того, есть servicing updates, те самые патчи, которые могут поставляться чуть ли не ежемесячно, и они могут касаться security или какими-то другими фичами, типа там нашли какие-то проблемы надежности, совместимости, либо еще чего-то.
1349.92 1352.92 "Игорь Лабутин" Это то, что касается непосредственно самих релизов DotNet.
1352.92 1355.92 "Игорь Лабутин" К DotNet всегда идет парой DotNet SDK.
1355.92 1357.92 "Игорь Лабутин" И с ними интереснее.
1357.92 1360.92 "Игорь Лабутин" Здесь есть у Microsoft такое понятие, как feature bands.
1360.92 1377.92 "Игорь Лабутин" И оно необходимо из-за того, что, несмотря на то, что мы зарелизили, например, DotNet Core 3.1, нам может потребоваться зарелизить несколько версий SDK для одного и того же релиза DotNet Core 3.1, потому что SDK необходимо обновлять, например, когда обновилась версия Visual Studio.
1377.92 1381.92 "Игорь Лабутин" Если, например, там добавились какие-то фичи, которые требуются изменения в SDK.
1381.92 1385.92 "Игорь Лабутин" Либо обновились какие-то build tools, например, в MS Build или в Nuget.
1385.92 1388.92 "Игорь Лабутин" Поэтому версии SDK может быть несколько.
1388.92 1396.92 "Игорь Лабутин" И именно поэтому, когда вы пытаетесь задоунлодить версию SDK, либо ставить ее у себя, у них такие странные номера с трехзначными числами в виде патча.
1396.92 1399.92 "Игорь Лабутин" Там 3.1.100 или еще что-нибудь такое.
1399.92 1406.92 "Игорь Лабутин" У Microsoft есть правило, что если у нас есть DotNet Core 3.1, то первая SDK будет 3.1.100.
1406.92 1415.92 "Игорь Лабутин" И все такие минорные, совсем минорные апдейты к этому SDK без необходимости обновления основного DotNet Core 3.1 будут.
1415.92 1419.92 "Игорь Лабутин" 3.1.100, 3.1.101, 3.1.102, 3.1.120 и так далее.
1419.92 1424.92 "Игорь Лабутин" Короче, у них есть 99, так сказать, возможностей выпустить какой-нибудь апдейт.
1424.92 1431.92 "Игорь Лабутин" Если же выпустили сервис-инрелиз, например, 3.1.2, то SDK начинается 3.1.200 и так далее.
1431.92 1432.92 "Игорь Лабутин" Почему это важно?
1432.92 1441.92 "Игорь Лабутин" Потому что, если, например, у вас стоит DotNet Core 3.1.100 и вы ставите DotNet Core SDK 3.1.101, то инсталлер удалит 3.1.100.
1441.92 1442.92 "Игорь Лабутин" Это надо понимать.
1442.92 1446.92 "Игорь Лабутин" То есть, вот эти вот, внутри фичи бендов всегда берется самая последняя версия.
1446.92 1454.92 "Игорь Лабутин" Если же у вас есть 3.1.200, точнее, если у вас есть 3.1.100 и вы ставите 3.1.200, то 3.1.100 у вас тоже останется.
1454.92 1455.92 "Игорь Лабутин" В общем, такая магия.
1455.92 1462.92 "Игорь Лабутин" Тут надо быть очень внимательным, смотря на какую версию SDK вы таргетитесь и что вы даунлоудите у себя.
1462.92 1467.92 "Игорь Лабутин" Особенно, если у вас эти версии прописаны в Global JSON файлике.
1467.92 1468.92 "Игорь Лабутин" Дальше.
1468.92 1474.92 "Игорь Лабутин" Есть еще тема с таргетингом ваших приложений и то, что называется Runtime Roll Forward.
1474.92 1497.92 "Игорь Лабутин" Поскольку Microsoft очень хочет, чтобы все было секьюрно и безопасно, то, если у вас есть, например, приложение, которое таргетит 3.1.0 Runtime, то, если Microsoft выпускает новый DotNet Core под названием 3.1.1, это Servicing Update, где, например, что-то пофиксили в Security, то ваше приложение автоматически начнет использовать 3.1.1, потому что так безопаснее.
1497.92 1502.92 "Игорь Лабутин" От этого можно отказаться, но это нужно явно прописать в конфиге.
1502.92 1505.92 "Игорь Лабутин" Из текущих релизов у нас LTS является два.
1505.92 1509.92 "Игорь Лабутин" Это DotNet Core 2.1, он будет поддержан до 21 августа 2021 года.
1509.92 1514.92 "Игорь Лабутин" И DotNet Core 3.1, он будет поддержан до 3 декабря 2022 года.
1514.92 1526.92 "Игорь Лабутин" DotNet 5, который выйдет в ноябре, это не LTS-релиз, это то, что называется Current Release, то есть он будет поддержан до выхода DotNet 6, плюс еще чуть-чуть, чтобы у вас была возможность перейти.
1526.92 1541.92 "Игорь Лабутин" И в целом Microsoft говорит, что если у вас есть продукт, который вы постоянно развиваете, у вас есть постоянная команда разработки, которая может его изменять, улучшать и так далее, то в принципе можно жить и на Current Releases, потому что это вам позволит использовать новые фичи.
1541.92 1562.92 "Игорь Лабутин" Если же у вас продукт не такой активно развивающийся, или если вы не хотите тратить ресурсы и ежегодно обновлять его на новый DotNet, то тогда используйте LTS-релиз, то есть в данном случае в настоящее время это DotNet Core 3.1, но тогда у вас, к сожалению, не будет всех тех клевых фич, которые в DotNet 5 рантайме завезли.
1562.92 1564.92 "Игорь Лабутин" Какая-то такая история.
1564.92 1569.92 "Анатолий Кулаков" Да, а фичи-то в DotNet 5 очень хорошие, интересные, и наверняка многим их захочется.
1569.92 1580.92 "Анатолий Кулаков" Но когда вы будете мигрировать свои проекты на DotNet 5, будьте осторожны, потому что при миграции даже с 3.1 на 5, у нас существует много-много breaking changes.
1580.92 1583.92 "Игорь Лабутин" Да, тут есть две истории.
1583.92 1593.92 "Игорь Лабутин" С одной стороны, история про то, что очень много кто говорит, что перевести ваше приложение с 3.1 на 5.0 было делом очень простым, и проблем никаких нет, и все просто работает.
1593.92 1596.92 "Игорь Лабутин" И для большинства приложений, наверное, это будет действительно так.
1596.92 1604.92 "Игорь Лабутин" Но действительно есть ряд изменений, которые breaking change, и которые нужно внимательно посмотреть, не сломают ли они ваше приложение.
1604.92 1620.92 "Игорь Лабутин" Митрософт выпустила большой список таких изменений, и для каждого из них действительно очень подробно описала, почему это breaking change, какое было старое поведение, какое будет новое поведение, причину, почему решили поменять это поведение, в большинстве случаев с ссылкой на GitHub обсуждение этого изменения.
1620.92 1623.92 "Игорь Лабутин" Вы можете прям проследить, как это все менялось.
1623.92 1631.92 "Игорь Лабутин" И самое главное - рекомендации, как поменять ваш код, либо конфигурацию, либо еще что-то, чтобы приложение стало работать хорошо.
1631.92 1643.92 "Игорь Лабутин" В тех случаях, когда можно, например, откатить это поведение, то есть некоторые такие изменения были сделаны специально откатываемыми через конфигурационные файлы, либо еще как-то, то есть рекомендации, как это сделать.
1643.92 1654.92 "Игорь Лабутин" Так что, если вы собираетесь переводить приложение на DotNet 5, посмотрите статью, она будет в ссылках, и внимательно изучите ту область, которая может относиться к вашему приложению.
1654.92 1667.92 "Игорь Лабутин" Митрософт аккуратно все breaking change разделил на категории, их примерно что-то около десятка штук, в каждой категории, разное количество от 10 до 30 разных breaking changes, и, возможно, этот список еще будет пополняться.
1667.92 1683.92 "Анатолий Кулаков" Также интересно, что здесь есть не только breaking changes для перехода на пятую, но и из самых мелких версий, например, хороший документ есть по миграции DotNet Framework на Core со второго на 2.1, с 2.2 на 3.0, и так по шагам, по шагам, по шагам.
1683.92 1694.92 "Анатолий Кулаков" То есть очень, очень хорошая, качественная документация, про которую вы можете пройтись просто от DotNet Framework большого, и из самых минорных, корных версий до самой последней, пятой.
1694.92 1698.92 "Игорь Лабутин" Да, и один из примеров такой миграции - это Stack Overflow.
1698.92 1700.92 "Игорь Лабутин" Stack Overflow завершил миграцию
1700.92 1704.92 "Анатолий Кулаков" своего продукта, своих сайтов, своих сервисов на DotNet Core.
1704.92 1708.92 "Анатолий Кулаков" К сожалению, еще не на пятый, но пока только на DotNet Core.
1708.92 1717.92 "Анатолий Кулаков" И на InfoQ вышла статья, интервью с Ником Крауэллом, архитект-лидом, который отвечал как раз-таки за миграцию.
1717.92 1724.92 "Анатолий Кулаков" Прежде всего, в Stack Overflow нужно понимать, что это не просто один сайтик, который, скорее всего, вам больше всего известен под этим названием.
1724.92 1744.92 "Анатолий Кулаков" Это порядка 170 различных комьюнити, комьюнити вопросов и ответов, которые включают в себя не только даже IT-тематику, но у них там есть и про еду, и про рестораны, и про вино, и про оружие, по-моему, про что-то такое у них там нету, этих всяких QA-портальчиков.
1744.92 1749.92 "Анатолий Кулаков" Также у них огромное число всяких приватных QA-сайтов для компаний, для бизнеса.
1749.92 1754.92 "Анатолий Кулаков" Они это все продают, и эти продукты тоже мигрировали на Netcore.
1754.92 1762.92 "Анатолий Кулаков" В общем, в цифрах примерно 51 миллион уникальных посетителей в месяц на Stack Overflow.
1762.92 1771.92 "Анатолий Кулаков" Каждые 14 секунд в среднем появляется новый вопрос на Stack Overflow, и вот такие нагрузки держатся на крайне небольшом количестве железных машин.
1771.92 1778.92 "Анатолий Кулаков" Из компонентов они также мигрировали ISP.Net MVC на ISP.Net Core, проапгрейдили и свой сторидж.
1778.92 1781.92 "Анатолий Кулаков" Они используют SQL SQL, сейчас 19-й версии.
1781.92 1790.92 "Анатолий Кулаков" Кстати, SQL крутится под Windows, а основные сервисы, которые написаны на ISP.Net Core, тоже крутятся под IS и под Windows.
1790.92 1794.92 "Анатолий Кулаков" То есть никакого Linux пока там нет для основной части.
1794.92 1799.92 "Анатолий Кулаков" Но для под CentOS крутятся вспомогательные сервисы, такие как Redis и Elastic.
1799.92 1806.92 "Анатолий Кулаков" Миграция заняла примерно 2 человека года, и Ник Кравер отметил, что в принципе никаких проблем не было.
1806.92 1811.92 "Анатолий Кулаков" Они там как-то дергались на предыдущих, на ранних версиях .NET Core.
1811.92 1823.92 "Анатолий Кулаков" Очень много собрали заплаток, очень много переписали там кода, но потом, когда вышла версия более-менее стабильная, такая как третья, у которой охват API был огромный, они практически все свои костыли выкинули и тупо перешли.
1823.92 1843.92 "Анатолий Кулаков" Поэтому никаких проблем не было, все прошло хорошо, и в будущем они надеются побольше использовать Linux машины, побольше использовать контейнеры для их инфраструктурной команды, то есть чтобы было удобнее тестировать, разворачивать какой-то deployment, environment возле тестировщика, возле разработчиков, и все это проходило бесшовно и красиво на контейнерах.
1843.92 1845.92 "Анатолий Кулаков" Также они ждут трейлинг хедеров.
1845.92 1847.92 "Анатолий Кулаков" Мы когда-то обсуждали эту тему.
1847.92 1850.92 "Анатолий Кулаков" Не очень понятно, зачем им это.
1850.92 1855.92 "Анатолий Кулаков" Скорее всего, хотят замерять таким образом удобно тайминги, но он тему не раскрыл.
1855.92 1863.92 "Анатолий Кулаков" Будем ждать более подробный отчет непосредственно уже на самом блоге stackoverflow, а пока это вся информация, которая от них есть.
1863.92 1866.92 "Игорь Лабутин" На самом деле, если вам интересно, почитайте твиттер Нико Крайвера.
1866.92 1870.92 "Игорь Лабутин" Он довольно красочно описывал, как они переходили и перевозили все это дело.
1870.92 1875.92 "Игорь Лабутин" И в частности с дотнетом все было довольно гладко, но не очень гладко было с SQL-сервером.
1875.92 1888.92 "Игорь Лабутин" В 2019-м оказалось некоторое количество интересных особенностей, проблем и сочетания их в вариантов нагрузки с тем, как ведется SQL-сервер, что привело к некоторым странным поведениям.
1888.92 1890.92 "Игорь Лабутин" И они с Microsoft выясняли, что же там не так.
1890.92 1892.92 "Игорь Лабутин" Поищите в твиттере, это было.
1892.92 1894.92 "Игорь Лабутин" Интересное истило.
1894.92 1895.92 None Поехали дальше.
1895.92 1899.92 "Игорь Лабутин" И дальше мы хотели бы обсудить интересную статью.
1899.92 1903.92 "Игорь Лабутин" Мы всегда любим поговорить про performance, мы всегда любим поговорить про память.
1903.92 1912.92 "Игорь Лабутин" И вот нам попалась статья "6 практик, как поддерживать память вашего приложения в, так скажем, хорошем состоянии, в здоровом состоянии".
1912.92 1918.92 "Игорь Лабутин" И эти 6 рекомендаций с одной стороны выглядят логично, с другой стороны иногда выглядят немножко странно.
1918.92 1920.92 "Игорь Лабутин" Вот мы сейчас по ним пробежимся.
1920.92 1921.92 "Игорь Лабутин" Рекомендации первые.
1921.92 1924.92 "Игорь Лабутин" Объекты должны быть собраны как можно быстрее.
1924.92 1925.92 "Игорь Лабутин" Хорошая рекомендация, потому что
1925.92 1933.92 "Анатолий Кулаков" promote объектов в следующее поколение, и это довольно дорого, и обычно связано с ошибками.
1933.92 1943.92 "Игорь Лабутин" Да, но проблема в том, что рекомендация - это хорошая, но она сродни тому, что разработчики очень часто любят в эксепшенах писать там.
1943.92 1947.92 "Игорь Лабутин" Кинуть новый эксепшен со словами "что-то пошло не так".
1947.92 1951.92 "Игорь Лабутин" Ну, что-то пошло не так - это здорово, это констатация факта, а что делать-то?
1951.92 1953.92 "Игорь Лабутин" Вот тут тоже такая же ситуация.
1953.92 1956.92 "Игорь Лабутин" Ну, объекты должны собираться как можно быстрее.
1956.92 1958.92 "Игорь Лабутин" Ну, да, спасибо, а как?
1958.92 1960.92 "Игорь Лабутин" То есть рекомендация...
1960.92 1965.92 "Игорь Лабутин" Я не очень люблю такие рекомендации, потому что они редко говорят "как".
1965.92 1986.92 "Игорь Лабутин" Здесь написано, что, ну, действительно, аллокация объектов в дутнете, она очень дешевая, это в большинстве случаев просто сдвиг указателя, и всё хорошо, и действительно, вам важно заботиться о том, насколько часто у вас проходят сборки мусора, и для того, чтобы убеждаться, что объекты собираются как можно быстрее, есть один простой способ.
1986.92 1990.92 "Игорь Лабутин" Добейтесь того, чтобы ссылки на них пропадали как можно быстрее.
1990.92 2003.92 "Игорь Лабутин" Ну, в принципе, рекомендация в таком виде уже выполнима, то есть это значит, что не сохраняйте ссылки на объекты на всякий случай, а вдруг понадобится, и если вы с объектом закончили работать, забудьте на него ссылку побыстрее.
2003.92 2007.92 "Анатолий Кулаков" Ну, похоже на best practice, не сохраняйте те ссылки, которые вам не нужны.
2007.92 2009.92 "Анатолий Кулаков" Если вы можете отпустить её как можно раньше, отпускай.
2009.92 2025.92 "Игорь Лабутин" Да, но при этом не надо всё-таки засорять код, который я иногда видел, куча строк, типа там, поработали с объектом, потом что-то там, ссылка присвоит null, потому что компилятор достаточно умён, чтобы самому понять, что объект дальше не используется, и можно ссылку не использовать.
2025.92 2026.92 "Игорь Лабутин" Рекомендация номер два.
2026.92 2029.92 "Игорь Лабутин" Используйте кэширование, но осторожно.
2029.92 2041.92 "Игорь Лабутин" И честно говоря, вот я бы эту рекомендацию, наверное, сохранил бы в этом списке, но поставил бы, наверное, чуть ли не в самый конец, потому что рекомендовать разработчикам кэшировать - это палка о двух концах.
2041.92 2074.92 "Игорь Лабутин" Кэширование может стать большой проблемой, если вы неаккуратно используете кэш и не продумали о том, как вы из этого кэша объекты будете удалять, потому что если у вас объект попал в кэш, с хорошей вероятностью это означает, что он попадёт во второе поколение, и это значит, что любая сборка мусора во втором поколении будет иметь дело с уже большим количеством объектов, и поэтому будьте внимательны, не помещайте в кэш слишком много, и всегда продумывайте стратегию того, как у вас из кэша объекты будут пропадать - по времени или по неиспользованию, ещё почему-то.
2074.92 2078.92 "Анатолий Кулаков" Как известно, инвалидация кэша - это один из самых сложных вопросов во вселенной.
2078.92 2084.92 "Игорь Лабутин" Да. И вторая часть этой рекомендации, она тоже так, на первый взгляд, звучит очень странно.
2084.92 2095.92 "Игорь Лабутин" Это про то, что одним из способов сделать так, чтобы мы поменьше использовали память, даже при использовании кэша, это использовать изменяемые кэш-объекты.
2095.92 2115.92 "Игорь Лабутин" То есть я бы сказал, что это на самом деле тогда не кэш, а это pool, но автор статьи приводит такой пример, что если у вас, например, кэшируются данные от какого-то внешнего сервиса в памяти, и вам нужно раз в несколько минут обновлять эти данные, то при обновлении данных, вместо того, чтобы создавать новые копии объектов и их снова кэшировать, вы обновите те объекты, которые уже есть в кэше.
2115.92 2146.92 "Игорь Лабутин" Я бы сказал, что это немножко странная рекомендация, и я бы не рекомендовал так делать, а действительно создавать новые объекты, потому что мутабельность, она все-таки может быть достаточно опасной, особенно если в этот момент этот объект будет кем-то использован, и вы, например, его обновили уже наполовинку, поэтому лучше перестраховаться, и пока у вас нет явных проблем с памятью, сейчас мы к этому вернемся чуть дальше, создавайте новый объект в таком случае, не надо модифицировать те объекты, которые в кэше, с моей точки зрения.
2146.92 2148.92 "Игорь Лабутин" Третья рекомендация.
2148.92 2153.92 "Игорь Лабутин" Смотрите за тем, сколько процентов времени у вас вообще проводится в Garbage Collector.
2153.92 2157.92 "Игорь Лабутин" Это, в принципе, тема интересная, действительно полезная.
2157.92 2164.92 "Игорь Лабутин" Если у вас есть какие-то метрики вокруг приложения, я всегда рекомендую добавлять метрику про процент тайм на GC.
2164.92 2171.92 "Игорь Лабутин" Это либо performance counter такой, либо есть .NET counter новый, который работает не через ETV, а кроссплатформенный.
2171.92 2174.92 "Игорь Лабутин" Он позволит вам понять вообще, насколько Garbage Collector важен в вашем приложении.
2174.92 2186.92 "Игорь Лабутин" Автор дает такие рекомендации, что все, что меньше 10%, это, в принципе, более-менее норм, 20% - это еще куда не шло, все, что больше - это прямо, у вас уже точно есть проблемы.
2186.92 2207.92 "Игорь Лабутин" Я бы сказал, что это на самом деле зависит от того, что требуется от вашего приложения, потому что большой Garbage Collect Time может быть это нормально, особенно если у вас приложение как-то работает условно батчами, но в целом смотреть, конечно, надо, если больше 10%, с моей точки зрения, надо в любом случае поизучать и понять, нормально ли это, или надо что-то с этим делать.
2207.92 2208.92 "Игорь Лабутин" Рекомендация номер 4.
2208.92 2216.92 "Игорь Лабутин" Примерно в том же направлении, смотрите на performance counter, но теперь надо посмотреть на количество сборок в поколении 2, и цель - иметь их как можно меньше.
2216.92 2219.92 "Игорь Лабутин" Цель хорошая, как это добиться - не очень понятно.
2219.92 2231.92 "Игорь Лабутин" Возможно, вы слышали рекомендацию о соотношении количества сборок, то есть количество сборок в нулевом поколении должно быть какое-то, в первом поколении в 10 раз меньше, чем в нулевом, во втором еще в 10 раз меньше, чем в первом.
2231.92 2242.92 "Игорь Лабутин" В принципе и Маони, и Стефенс, и Конрад в своей книжке, по-моему, говорили, что это, вообще говоря, такая очень эмпирическая рекомендация, и не факт, что она правильная.
2242.92 2249.92 "Игорь Лабутин" Но в целом, да, если у вас количество сборок во втором поколении стабильно большое или сильно растет, это, наверное, не очень здорово.
2249.92 2250.92 "Игорь Лабутин" Их должно быть не очень много.
2250.92 2255.92 "Игорь Лабутин" Так что смотрите, и вам главное, чтобы оно не росло со временем.
2255.92 2260.92 "Игорь Лабутин" И вот если мы говорим про "расти со временем", то про это пятая рекомендация.
2260.92 2263.92 "Игорь Лабутин" Проверяйте, что ваше потребление памяти более-менее стабильно.
2263.92 2265.92 "Игорь Лабутин" Ну, тут как бы все нормально, да.
2265.92 2269.92 "Игорь Лабутин" При любом мониторинге смотрите, как ваше приложение потребляет память.
2269.92 2271.92 "Игорь Лабутин" Если оно в среднем растет, ну, наверное, у вас memory leak.
2271.92 2273.92 "Игорь Лабутин" Как бы с этим надо что-то делать.
2273.92 2275.92 "Игорь Лабутин" И шестая рекомендация.
2275.92 2281.92 "Игорь Лабутин" Сначала я ее не понял, потому что она звучит как "периодически смотрите на memory leak".
2281.92 2287.92 "Игорь Лабутин" И я как бы так, ну пятая же про то же самое, но автор статьи говорит, что нет, это то же самое.
2287.92 2299.92 "Игорь Лабутин" Он говорит так, что если у вас memory leak очень маленький, то есть если он у вас большой, то вы это увидите по, согласно пятой рекомендации, просто смотря на то количество памяти, которое потребляет ваше приложение.
2299.92 2301.92 "Игорь Лабутин" Если же он маленький, возможно, вы его не увидите.
2301.92 2306.92 "Игорь Лабутин" И увидите вы его только, если возьмете профайлер и специально посмотрите на ваше приложение.
2306.92 2311.92 "Игорь Лабутин" Делать это надо иногда, раз там в месяц, раз там в квартал, или еще когда-то.
2311.92 2317.92 "Игорь Лабутин" Перед релизом, например, желательно затянется два до релиза, не раньше, а то не интересно.
2317.92 2321.92 "Игорь Лабутин" Надо же фиксить баги все в последний момент, как известно.
2321.92 2331.92 "Игорь Лабутин" Но, тем не менее, рекомендация, на самом деле, немножко странная, потому что если у вас очень маленький memory leak, то даже посмотрев на него memory профайлером, вы, в принципе, можете его не заметить.
2331.92 2336.92 "Игорь Лабутин" Потому что, ну, приложение натурально, какие-то объекты пропадают, какие-то остаются.
2336.92 2344.92 "Игорь Лабутин" Вам нужно очень хорошо знать ваше приложение, чтобы тщательно классифицировать все остающиеся объекты и понять, это нормально, что они остаются или нет.
2344.92 2353.92 "Игорь Лабутин" Я пробовал применять такую технику, периодически смотреть на приложение и понимать memory leak, и как-то я не могу сказать, что она принесла сильно много бенефитов.
2353.92 2357.92 "Игорь Лабутин" Время не тратится много, а проблем находится очень мало.
2357.92 2360.92 "Игорь Лабутин" Ну, или у нас приложение такое хорошее было, я уже не знаю.
2360.92 2364.92 "Анатолий Кулаков" Я использую немножко другой подход, в ту же тему.
2364.92 2367.92 "Анатолий Кулаков" Я использую библиотеку dot memory unit test.
2367.92 2372.92 "Анатолий Кулаков" То есть это штучка, которая позволяет мне в unit test проверять memory leak.
2372.92 2383.92 "Анатолий Кулаков" Если у меня зацепятся какие-то объекты, которые должны помирать, допустим, после пользовательской сессии, то я точно знаю, что в приложении без сессии эти объекты существовать не могут.
2383.92 2391.92 "Анатолий Кулаков" Но из-за каких-то кэшей или неправильно проставленных зависимостей, или еще чего-то они зацепляются, это прекрасно вылавливается unit test.
2391.92 2396.92 "Анатолий Кулаков" Чтобы вы понимали, это штука, которая похожа на memory profile.
2396.92 2400.92 "Анатолий Кулаков" То есть вы можете снять snapshot вашего приложения и происследовать все, что находится внутри snapshot.
2400.92 2414.92 "Анатолий Кулаков" Например, узнать, а есть ли зависшие экземпляры моей сессии в этом snapshot, или сколько было создано количество коннекций к базе данных, или вот такие вот вещи.
2414.92 2418.92 "Анатолий Кулаков" То есть для определенных узких сценариев эта штука просто незаменима.
2418.92 2422.92 "Анатолий Кулаков" Я не скажу, что у меня таких тестов много, но те, которые есть, меня не раз выручили.
2422.92 2424.92 "Анатолий Кулаков" Поэтому смотрите на dot memory unit test.
2424.92 2426.92 "Анатолий Кулаков" Библиотечка довольно мощная.
2426.92 2432.92 "Игорь Лабутин" Да, это как раз-таки отличный подход, потому что он не требует сильных затрат, постоянных.
2432.92 2436.92 "Игорь Лабутин" То есть такой тест действительно нужно написать, его нужно написать аккуратно.
2436.92 2438.92 "Игорь Лабутин" Нужно действительно правильно расставить все нужные ассерты.
2438.92 2440.92 "Игорь Лабутин" Но дальше он работает автоматически.
2440.92 2448.92 "Игорь Лабутин" А вот такой периодический запуск приложения в славу минут, давайте посмотрим, нет ли у нас memory leak, он, как правило, заканчивается тем, что вроде нет.
2448.92 2453.92 "Игорь Лабутин" А если он большой, то вы на самом деле это увидите на мониторинге и так, по количеству памяти, которую оно кушает.
2453.92 2471.92 "Игорь Лабутин" Так что в общем и целом рекомендации такие, с одной стороны довольно очевидные, с другой стороны немножко спорные, с третьей всегда полезно помнить, что надо смотреть за количеством времени, которое тратится на ваш garbage коллектор, надо смотреть на то, сколько у вас собирается второе поколение, сколько раз оно собирается, и надо следить за памятью в вашем приложении.
2471.92 2475.92 "Игорь Лабутин" Так что хорошие такие рекомендации, помните, исследуйте.
2475.92 2476.92 "Игорь Лабутин" Давай дальше.
2476.92 2479.92 "Анатолий Кулаков" Рекомендации - это хорошо, но это уже вылавливание проблем в ран тайме.
2479.92 2484.92 "Анатолий Кулаков" Но у нас же есть обалденное мощное средство, которое работает еще в дизайн тайме.
2484.92 2486.92 "Анатолий Кулаков" Я говорю про рослин анализаторы.
2486.92 2492.92 "Анатолий Кулаков" И они все время открывают больше и больше грани, и появляются новые и новые анализаторы.
2492.92 2498.92 "Анатолий Кулаков" Я надеюсь, что когда-нибудь мы сможем ловить memory leak и прочие вот такие вещи, которые мы обсудили с помощью анализаторов.
2498.92 2506.92 "Анатолий Кулаков" И если мы посмотрим на рынок, то довольно-таки много уже анализаторов, которые анализируют всякие ран тайм проблемы.
2506.92 2513.92 "Анатолий Кулаков" Ну, там что, будет использование неинциализированной переменной, или неоткрытый connection, или неоткрытый файл, вот что-нибудь такое.
2513.92 2515.92 "Анатолий Кулаков" Уже мы двигаемся в этом направлении.
2515.92 2531.92 "Анатолий Кулаков" Но меня огорчает, что у нас очень мало анализаторов, которые идут дальше, которые анализируют все-таки архитектурные какие-то best практики, которые позволяют улучшить код quality, которые больше про performance, про правильное использование структур данных и так далее.
2531.92 2534.92 "Анатолий Кулаков" То есть уже более высокоуровневые какие-то вещи.
2534.92 2549.92 "Анатолий Кулаков" И как раз-таки в статье Кевин Эвиньон рассказал, каким образом он примерно год назад на Hackatony сделал такой анализатор, и сейчас его доработал, и выпустил в паблик, для того, чтобы люди заценили его идею, и, может быть, продолжили вместе с ними развивать.
2549.92 2554.92 "Анатолий Кулаков" Вкратце, анализатор называется .NET System Collection Analyzers.
2554.92 2563.92 "Анатолий Кулаков" Он берет на себя как раз-таки заботу о структурах данных, о том, как их правильно использовать, и самые типичные ошибки с performance, которые встречаются.
2563.92 2569.92 "Анатолий Кулаков" Ну, например, не надо использовать филды, свойства в виде массивов.
2569.92 2571.92 "Анатолий Кулаков" Также не нужно массивы возвращать из метода.
2571.92 2575.92 "Анатолий Кулаков" При этом лучше использовать .IRID_only_list.
2575.92 2583.92 "Анатолий Кулаков" С тематической точки зрения это такой довольно правильный совет, потому что если вы вернете массив, массивы все равно можете поменять.
2583.92 2599.92 "Анатолий Кулаков" И у пользователя с точки зрения API сложится такое ощущение, что если вернулся массив с пользователями, и он в этом массиве изменил какого-то пользователя, то этот пользователь должен, по идее, сохраниться и в настоящей коллекции, в настоящем репозитории с пользователями.
2599.92 2605.92 "Анатолий Кулаков" Чтобы не давать ему такую возможность, чтобы не давать ему такую миниму-иллюзию, нужно возвращать .IRID_only_list.
2605.92 2609.92 "Анатолий Кулаков" Тогда у пользователя будет сразу очевидно, что это .IRID_only_list, его менять никак нельзя.
2609.92 2613.92 "Анатолий Кулаков" И для того, чтобы изменить пользователя, ему нужно воспользоваться какими-то более специализированными методами.
2613.92 2627.92 "Анатолий Кулаков" Еще один анализатор, который проверяет, что если у вас какой-то enumerable коллекция используется только для того, чтобы определить, существуют ли элементы, или не существуют, то есть вызывается метод contains.
2627.92 2635.92 "Анатолий Кулаков" Советуют вам заменить это на более подходящую структуру, на какой-нибудь хэш-сетик или сет, для того, чтобы более эффективно выполнять contains.
2635.92 2639.92 "Анатолий Кулаков" Тоже вполне разумная вещь, у новичка очень часто встречается.
2639.92 2645.92 "Анатолий Кулаков" Есть более примитивные, такие как использование count метода вместо count свойства.
2645.92 2653.92 "Анатолий Кулаков" Нужно тоже быть внимательным, потому что count метод enumerated всю коллекцию, и count свойства быстро возвращает размер коллекции без всяких проблем.
2653.92 2657.92 "Анатолий Кулаков" Очень часто такая ситуация встречается, когда у вас подменяется тип коллекции.
2657.92 2665.92 "Анатолий Кулаков" Допустим, раньше там возвращался из метода enumerable, вы у него очень честно вызывали count, и в принципе ни о чем не сожалели.
2665.92 2681.92 "Анатолий Кулаков" После этого сигнатор и метод поменялся, он стал более строгим, начал возвращать какой-нибудь iCollection, iList, и все потребители по-прежнему продолжают у него дергать метод count, вместо того, чтобы сделать это более эффективным и запросить размер через свойства count.
2681.92 2683.92 "Анатолий Кулаков" Вот еще интересная штука.
2683.92 2689.92 "Анатолий Кулаков" Игорь проверяет использование метода any, и говорит, что если вы используете метод any, отдайте предпочтение свойству count.
2689.92 2697.92 "Анатолий Кулаков" Мы с тобой, помнишь, Игорь, обсуждали недавно эту оптимизацию, которую сделали в .NET 5, когда any стал умным и сам использует count.
2697.92 2699.92 "Игорь Лабутин" Да.
2699.92 2707.92 "Игорь Лабутин" Я в целом хотел сказать, что на самом деле даже count метод и count property, я так понимаю, что count метод тоже должен иметь оптимизацию по iCollection.
2707.92 2717.92 "Игорь Лабутин" Скорее всего, конечно, она оптимизирована, но понятно, что вызов метода проверка property, проверка типа, точнее, коллекции, это чуть дольше, чем просто вызвать property.
2717.92 2721.92 "Игорь Лабутин" Если у вас совсем high-performance код, то, конечно, не нужно count метода использовать.
2721.92 2723.92 "Анатолий Кулаков" Да, именно так.
2723.92 2731.92 "Анатолий Кулаков" Здесь тоже все нужно мерить от вашего уровня паранойи, то есть от вашего перформанса и от того, насколько код от этого станет читабельным или нет.
2731.92 2735.92 "Анатолий Кулаков" Поэтому здесь неоднозначный ответ, что использовать any или count.
2735.92 2741.92 "Анатолий Кулаков" Смотрите, наверное, под каждый свой конкретный случай, что для вас семантически более читаемое, наверное, может быть более performance-критиков.
2741.92 2743.92 "Анатолий Кулаков" Вот еще один интересный пункт.
2743.92 2761.92 "Анатолий Кулаков" Не используйте метод elementAt, метод расширения, если у вас есть list, потому что elementAt возвращает вам элемент по индексу, но при этом его сложность это o от m. Если же у вас есть list, вы просто можете обратиться по любому индексу, который вам нужен, и сложность будет o от единицы. Тот же самый эффект касается first и last.
2761.92 2767.92 "Анатолий Кулаков" То есть тоже никакого смысла вызывать их методами. Нет, вы вполне можете обратиться к индексу.
2767.92 2771.92 "Игорь Лабутин" Вот именно такие разумные, в принципе, анализаторы.
2771.92 2781.92 "Игорь Лабутин" Я когда-то даже делал доклад про всякие коллекции и в частности упоминал штуки про array-only list и все такое прочее, которые нужно правильно использовать для возврата значений.
2781.92 2803.92 "Игорь Лабутин" Есть также некоторые рекомендации на тему того, что принимать в методы. Интересно посмотреть, есть ли там какие-то аналайзеры, потому что есть тенденция принимать везде enumerable со словами "ну, это универсально" и забывать, что при этом мы теряем на самом деле кусочек производительности и удобства, потому что рантайм не будет знать, что же там на самом деле есть внутри
2803.92 2807.92 "Анатолий Кулаков" этого enumerable. Да, мне тоже этот анализатор напомнил твой доклад.
2807.92 2829.92 "Анатолий Кулаков" И я, в принципе, надеюсь, что все-таки люди дойдут для того, чтобы перенести вот эти рекомендации, которые ты упоминал, для того, чтобы их перенести в анализаторы. И мы бы все ежедневно пользовались бы best-practices, cartores выработались годами и не загонялись бы вот этими случайными рефакторингами, которые бы наше приложение подвергали какой-нибудь ужасной ГЦ.
2829.92 2835.92 "Игорь Лабутин" Ну, посмотрим, что из этого получится. Давай пойдем дальше и поговорим уже про именно прям тулы-тулы.
2835.92 2855.92 "Игорь Лабутин" Мы сегодня не будем говорить ничего про райдер и решарпер, но зато есть некоторые другие тулы, которые хотелось бы упомянуть. Во-первых, есть Эрик Синг, это небезызвестный человек в мире и дот-нета, и вообще в принципе он не занимается программированием, который поставил себе интересную задачку.
2855.92 2879.92 "Игорь Лабутин" Он сказал, а почему бы не написать компилятор, который будет брать LLVM-код, псевдокод, и компилировать его в дот-нет-сборку. По большому счету LLVM - это, насколько я понимаю и знаю, я не сильно близко работал с компиляторами, но это все-таки некоторый байт-код, можно сказать, для виртуальной машины. Дот-нет - тоже
2879.92 2883.92 "Анатолий Кулаков" почему бы не совместить? Я бы назвал это промежуточным языком компилятора.
2883.92 2897.92 "Анатолий Кулаков" Я могу тут немножко добавить. То есть у LLVM все языки компилируются сначала в некий промежуточный код, так называемый, и для того, чтобы этот промежуточный код можно было прооптимизировать.
2897.92 2949.92 "Анатолий Кулаков" Потому что существует огромное число всяких оптимизаций, каким образом помочь процессору выполнить этот код быстрее. И удобно, когда все эти оптимизации пишутся не под каждый конкретный язык, там, под PHP, под C#, под Java, а удобно, чтобы их один раз написали, потому что алгоритмы везде одинаковые. Ну, для примера раскрытие цикла, допустим. Намного эффективнее выполнить операцию три раза, например, чем писать цикл от нуля до трех и в цикле крутить какую-то операцию. Вот. И эти рекомендации, эти оптимизации, они на уровне процессора работают, то есть они никак не зависят от языка. Вот почему их удобно делать на неком абстрактном промежуточном языке. Вот этот промежуточный язык и есть в LLVM, и, соответственно, по определению в него компилируются практически все языки, которые поддерживаются LLVM, а поддерживаются, наверное, сейчас практически все. Потому что для новых языков, для тех, которые изобретаются, намного легче написать свой компилятор на базе LLVM.
2949.92 2961.92 "Анатолий Кулаков" И как раз таки из-за вот этих всяких оптимизаций, из-за развитого тулинга, из-за моря документации и так далее. То есть это такая автоматически самоподдерживаемая платформа, которая вбирает и впитывает в себя все больше и больше
2961.92 2967.92 "Игорь Лабутин" языков. Ну и вот как раз таки этот самый промежуточный язык Eric Singh попробовал скомпилировать в .NET.
2967.92 2975.92 "Игорь Лабутин" Пока это, конечно же, не получилось с готовым всеобъемлющим компилятором, который умеет все что угодно. Но, тем не менее, какие-то первые результаты есть.
2975.92 2998.92 "Игорь Лабутин" Основная функциональность реализована в виде .NET 2.1, который лежит на NougatOrg, и вы можете его поставить, используя source.gear.llama.bc2cl c-i-l. Не очень такое удобное название, но тем не менее, мы привыкнем. Проект этот является пока еще, конечно, нисколько ни разу не продакшеном. Это экспериментальный проект, чисто как proof of concept.
2998.92 3004.92 "Игорь Лабутин" К сожалению, пока еще исходники не открыты, но, наверное, это изменится со временем.
3004.92 3010.92 "Игорь Лабутин" И, поскольку это эксперимент, то неясно, чем он закончится, будет ли куда-то развиваться.
3010.92 3014.92 "Игорь Лабутин" Но задумка интересная, и, может быть, что-то из этого выйдет.
3014.92 3026.92 "Игорь Лабутин" И в качестве примера Eric попробовал сделать две вещи. Во-первых, он написал Hello World на C, просто обычный, простой main, где вызывается put_as функция, которая выводит строку на экран.
3026.92 3034.92 "Игорь Лабутин" Естественно, мы можем использовать C-шник, компилятор, в данном случае это был Clang, чтобы сгенерировать LLVM представление.
3034.92 3040.92 "Игорь Лабутин" После этого мы можем использовать этот новый тул, чтобы сгенерировать уже .NET сборку. Тут возникают две проблемы.
3040.92 3044.92 "Игорь Лабутин" Проблема первая. Нам откуда-то нужно взять реализацию функции put_as.
3044.92 3052.92 "Игорь Лабутин" C - это, естественно, стандартная библиотека, липси, но она огромная. И всю ее перегоняя в .NET было как-то не с руки, по крайней мере, на данном этапе.
3052.92 3062.92 "Игорь Лабутин" Поэтому put_as просто Eric написал на C# и указал своему тулу, что вот в качестве референсов использовал он ту сборочку.
3062.92 3074.92 "Игорь Лабутин" И второе. Нужно как-то дать понять .NET, что вообще-то это executable штука, и где-то там есть main, а C-шный main, понятное дело, это не то же самое, что .NET-ский main.
3074.92 3098.92 "Игорь Лабутин" И это тоже отдельно обходится элементами к его тулу, который автоматически будет искать main функцию по каким-то своим эвристикам, скажем так. Получилась вполне работоспособная штука, она действительно выводит hello world на экран, то есть, по сути, C-шное приложение скомпилировано в .NET и работающее, но понятно, что там до какого-то production или даже хотя бы около production кода очень-очень далеко.
3098.92 3108.92 "Игорь Лабутин" Второй пример был на Swift, там было попроще с одной стороны, а с другой стороны посложнее, потому что была написательная в Swift-е какую-нибудь библиотеку, которую можно использовать из .NET.
3108.92 3128.92 "Игорь Лабутин" В качестве функции была использована минимальная возможная функция без внешних зависимостей, она просто умножает два числа, и в целом проблем особых не было, кроме того, что нужно было позаботиться о конвенциях вызова, тот самый cdecl, те, кто программировал на C/C++, должны помнить, всякие cdecl, stdcal и прочие странные call.
3128.92 3150.92 "Игорь Лабутин" И после использования cdecla получился llvm, правильный который, Tulum автоматически перегнался в .NET сборочку, которая из другого .NET проекта прекрасно вызвала. В общем, если этот проект полетит, то конечно будет интересно, мы сможем для .NET рантайма писать на практически чем угодно, что умеет компилироваться в .LVM, то есть наверное на всем.
3150.92 3158.92 "Анатолий Кулаков" Да, ну и существующие библиотечки перегнать, допустим, очень много библиотек по Data Science на Python есть, мы их легко можем перекомпилировать в .NET.
3158.92 3162.92 "Анатолий Кулаков" Пока непонятно зачем, но возможности такие будут. Да, ну ладно,
3162.92 3166.92 "Игорь Лабутин" закончим с этим и пойдем все-таки в JetBrains.
3166.92 3168.92 "Игорь Лабутин" JetBrains и на этот раз нас смогло
3168.92 3176.92 "Анатолий Кулаков" удивить. Несмотря на то, что мы тщательно пытались избежать снова темы Raider и ReSharper, JetBrains выпустил мегатолзу, которая называется CodeViewMe.
3176.92 3180.92 "Анатолий Кулаков" И мы не могли пройти стороной для того, чтобы не рассказать о ней.
3180.92 3188.92 "Анатолий Кулаков" Что же это такое? Это специальный тул для удаленного взаимодействия разработчиков и для парного программирования.
3188.92 3192.92 "Анатолий Кулаков" Сразу надо сказать, что этот тул находится в Early Access Program.
3192.92 3199.92 "Анатолий Кулаков" Он доступен всем JetBrains IntelliJ Base IDE с версией 2020.2.
3199.92 3213.92 "Анатолий Кулаков" Интересный факт, что ишью, которая была заведена и в котором разработчики требовали этот инструмент, исполнилось 16 лет. То есть, наверное, это одна из самых больших, если не самая большая таска в JetBrains.
3213.92 3221.92 "Анатолий Кулаков" Также у нее большое число голосов, которые призывали JetBrains обратить внимание на эту идею.
3221.92 3233.92 "Анатолий Кулаков" И, наверное, по количеству годов и по количеству голосов она вполне может состязаться как самая крутецкая, самая старая и самая заголосованная таска, которая была в компании.
3233.92 3263.92 None Итак, что же позволяет вам сделать этот новый инструмент? Как я уже сказал, он является частью IntelliJ Base IDE, то есть практически всех IDE, которые выпускает JetBrains. И он позволяет вам расшарить ваш текущий проект, который у вас загружен в IDE, с распределенной командой, то есть с любым человеком, который находится где-то там и может к вам приконектиться. Это очень сильно похоже на тему от Microsoft, которую мы недавно обсуждали, которая называется, по-моему, Microsoft Live.
3263.92 3319.92 "Анатолий Кулаков" Это тоже такой же инструмент для коллаборации между несколькими разработчиками. Все участники этой коллаборации получают доступ к какой-то одной IDE, и могут, например, вместе исследовать какую-то проблему, дебажить, ревьюить код, или просто работать над какой-то задачей все вместе в реальном времени. При этом у вас точно так же остается автокомплешин, навигация, рефакторинг, дебаггинг, ну то есть это не какая-то просто картинка рисуется на Remote Desktop. Это ваша полноценная IDE, которая стоит у вас под рукой, и все ваши любимые хоткей, все ваши любимые настройки стилей, темы и прочее, они у вас под рукой. Несмотря на то, что код чужой, инструмент в ваших руках свой, знакомый, и это очень большой плюс. Итак, что же вам нужно? Прежде всего, вам нужно скачать версию или установить версию IDE 2020.2.
3319.92 3333.92 "Анатолий Кулаков" Далее нужно поставить плагин из Marketplace. У вас появится возможность создать веб-линк на вашу расшаренную сессию. Отправить линк вашей команде или какому-то члену.
3333.92 3343.92 "Анатолий Кулаков" После этого они смогут подключиться из своей IDE к вашей сессии. Для этого у них, естественно, должен быть установлен JetBrains IDE.
3343.92 3349.92 "Анатолий Кулаков" И если она не установлена, специальный инсталлятор по линку предложит ее скачать и поставить.
3349.92 3359.92 "Анатолий Кулаков" И IDE-шка вас спросит, хотите ли вы заакцептить этот реквест, то есть хотите ли вы принять того человека, который к вам стучится и хочет вам сейчас навязать свою сессию, вы можете его заакцепить.
3359.92 3365.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3365.92 3371.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3371.92 3377.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3377.92 3383.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3383.92 3389.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3389.92 3395.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3395.92 3401.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3401.92 3407.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3407.92 3413.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3413.92 3419.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3419.92 3425.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3425.92 3431.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3431.92 3437.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3437.92 3443.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3443.92 3449.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3449.92 3455.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3455.92 3461.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3461.92 3467.92 "Анатолий Кулаков" Идеально, если вы хотите заакцепить его, то вы можете заакцепить его.
3467.92 3473.92 "Анатолий Кулаков" Идеально, если вы хотите пригласить к себе каких-то своих учеников и показать им, как делается код.
3473.92 3475.92 "Анатолий Кулаков" Или наоборот, подключиться к ним и посмотреть, как делается код.
3475.92 3491.92 "Анатолий Кулаков" И вообще, в принципе, не обязательно запускать IDE где-то, наверное, уже на своем компьютере. Еще этого нет, но, наверное, интересно будет такой use case, когда IDE просто запускается где-то там на большом, мощном сервере.
3491.92 3505.92 "Анатолий Кулаков" Этот сервер у вас уже прикэшировал все необходимые символы, он уже прогрел все, что можно прогреть, и вы просто по протоколу код в UMI коннектитесь к этому headless серверу и начинаете там разрабатывать.
3505.92 3509.92 "Анатолий Кулаков" И можно это, скорее всего, делать даже с очень маломощных каких-нибудь laptop'чиков.
3509.92 3519.92 "Игорь Лабутин" Короче, прям клевая фишка, если вам действительно нужно делать парное программирование, обучение или что-то подобное, когда требуется доступ нескольких человек к одному и тому же коду.
3519.92 3523.92 "Анатолий Кулаков" Да, будем следить за проектом, посмотрим, куда и в какую сторону это будет развиваться.
3523.92 3525.92 "Игорь Лабутин" Окей, пошли тогда к другим тулам.
3525.92 3531.92 "Игорь Лабутин" И это даже не тул, это библиотека, которую наверняка многие из вас знают, и это Identity Server.
3531.92 3545.92 "Игорь Лабутин" В начале октября на сайте Доминика Байера, одного из авторов Identity Server, вышла статья под названием "The Future of Identity Server", где он рассказал про то, что нам ждать от будущего, собственно, Identity Server.
3545.92 3569.92 "Игорь Лабутин" И идея там такая, что проект уже больше 10 лет, они его начали в 2009 году примерно, и собственно, все это время он был open-source, он стал гигапопулярным, это практически де-факто стандарт реализации OAuth или OpenID Connect для .NET, но денег он не приносит особых, а жить, так сказать, как-то надо.
3569.92 3575.92 "Игорь Лабутин" Поэтому они решили основать компанию, которая будет заниматься дальше развитием и разработкой Identity Server.
3575.92 3595.92 "Игорь Лабутин" Текущая версия Identity Server, которая четвертая, она будет последней, которая является свободной, опен-сурсной, и, как мы ее знаем, с лицензией, которая позволяет ее использовать в коммерческих приложениях, и она будет поддерживаться до тех пор, пока у нас поддерживается .NET Core 3.1 в LTS, как мы говорили раньше, это будет до ноября 2022 года.
3595.92 3625.92 "Игорь Лабутин" Следующая версия Identity Server будет уже развиваться под номером 5 и будет развиваться под крылом новой компании, которая называется Duende Software, и туда будут, собственно, добавлять, допиливаться все новые фичи и писаться поддержка .NET 5, ну и всех будущих версий. Identity Server получит новую схему лицензирования, у него будет две лицензии. Одна лицензия будет коммерческая, за нее нужно будет платить деньги, а вторая лицензия будет RPL, это Reciprocal Public License.
3625.92 3647.92 "Игорь Лабутин" Смысл такой. Если вы используете Identity Server в каком-то коммерческом продукте, то вы должны теперь будет платить за него деньги, начиная со следующей версии. И если же вы используете его в опен-сурсном продукте или на ваших там тестовых внутренних каких-то серверах, не относящихся к продакшену, то можно свободно продолжать использовать опен-сурсную версию.
3647.92 3657.92 "Игорь Лабутин" Важный момент, что разработка продолжится на GitHub, разработка будет все такая же опен-сурсная, но за использование в коммерческом продукте нужно будет заплатить денег.
3657.92 3669.92 "Игорь Лабутин" И деньги эти будут по подписке, то есть цены начинаются от 1500 долларов в год и доходят до 12 тысяч долларов в год за Enterprise версию.
3669.92 3681.92 "Игорь Лабутин" Разница между Starter Business и Enterprise версиями в количестве поддерживаемых клиентов, тех самых клиентов, которые вы определяете в конфигурации Identity Server и в некоторых других особенностях работы.
3681.92 3711.92 "Игорь Лабутин" Так что смотрите, выбирайте, как что. Авторы сказали, что никаких бессрочных лицензий точно не будет, поскольку любой софт сейчас требует как минимум поддержки и обновления под новые версии выходящих, там, рантаймов, смотри, на DotNet 5, 6 и так далее, и новых фич, поэтому только подписка, только вот по этим, пока по крайней мере объявленным ценам. Превью версии новой пятой версии начнут появляться в конце октября, а The Religion, она должна быть в январе 2021 года.
3711.92 3713.92 "Игорь Лабутин" Посмотрим, подождем.
3713.92 3731.92 "Игорь Лабутин" Ну, а теперь действительно интересная ситуация, что Identity Server наверняка используется огромным количеством компаний внутри своих продуктов, и с этим нужно будет что-то делать, либо переходить на альтернативные решения, которых не так много, и обычно это SaaS решение, и либо соответственно планировать бюджеты на покупку новой версии
3731.92 3735.92 "Анатолий Кулаков" Identity. Ну или оставаться на четвертой, ничего ж тебе не мешает использовать прежнюю
3735.92 3747.92 "Игорь Лабутин" версию. Да, если не будет никаких решений к протоколу, то по большому счету наверное четвертая версия вполне будет работать и никуда, конечно же, не денется. Ну либо ее можно дописывать и обновлять самому.
3747.92 3761.92 "Анатолий Кулаков" Да, она довольно-таки кастомизированная, расширябельная, ну и вообще нужно признать, что Identity Server очень хороший продукт, и за ним стоят отличные специалисты, отличные авторы, и надеюсь, что у них получится монетизировать свое детище, и Identity Server будет продолжать цести и пахнуть.
3761.92 3773.92 "Игорь Лабутин" Identity Server хорошо, популярный продукт, есть еще другой популярный продукт, точнее сервис, это GitHub, который тоже заанонсировал новую штуку, и это GitHub Code Scanning.
3773.92 3793.92 "Анатолий Кулаков" Да, Code Scanning, за этим названием прячется подход к более легкому пути для того, чтобы искать security уязвимости в вашем коде, еще до того, как они попадут на продакшн. То есть это тоже такой инструмент для статического анализа кода, который помогает вам найти какие-то проблемы в вашем коде.
3793.92 3797.92 "Анатолий Кулаков" И вот этот инструмент, он был как раз-таки за Releasion.
3797.92 3809.92 "Анатолий Кулаков" Давайте немножко пройдемся по его особенностям. Прежде всего, он бесплатен для публичных репозиториев, для приватных есть денежные планы, можете с ними ознакомиться на официальном сайте.
3809.92 3817.92 "Анатолий Кулаков" И уже сейчас для всех публичных репозиториев вы можете зайти в настройки вашего GitHub аккаунта и разрешить его, и посмотреть, что от этого будет.
3817.92 3851.92 "Анатолий Кулаков" А будет много интересных и магических вещей. В частности, если вы добавите GitHub Action, соответствующий Pro Code Scanning, в ваш CI/CD pipeline, или даже если вы используете какой-то внешний CI/CD, не GitHub Actions, это тоже поддерживается, вам будут приходить нотификации о том, что у вас найдены какие-то security-вызвы в вашем коде, вам автоматически будут создаваться pull-requests, которые будут объяснять, в чем именно проблема в вашем коде, и может быть даже каким образом ее исправить, и практически за вас будут выпускаться сразу security-патчи.
3851.92 3861.92 "Анатолий Кулаков" Но, наверное, все-таки pull-requests вам придется применить ручками. Интересная тема состоит в том, что данные анализы построены на специальном языке, который называется CodeQL.
3861.92 3865.92 "Анатолий Кулаков" Это специальный семантический движок для анализа кода.
3865.92 3883.92 "Анатолий Кулаков" И очень много уже, более 2000 query-ей написано с сотрудниками GitHub, community-ами, с всякими research-инженерами, security-инженерами, более 2000 всяких query-ей, которые позволяют вам найти в вашем коде какие-то типичные security-уязвимости.
3883.92 3915.92 "Анатолий Кулаков" Более того, GitHub активно сейчас партнерится и сотрудничает со всякими третье-сторонними компаниями, которые поставляют сканеры кода, всякие security-инструменты, или сканеры контейнеров, или всякие сканеры инфраструктуры, как кода. Сейчас очень много таких инструментов, таких компаний, и GitHub их всех хочет интегрировать в эту свою единую платформу под единый интерфейс с едиными, понятными манипуляторами взаимодействия, то есть с нотификациями, с pull-requests, с autofixes, с какими-то общими коллаборациями.
3915.92 3919.92 "Анатолий Кулаков" В общем, все то, что есть в GitHub, мне кажется, эта тема туда отлично вписывается.
3919.92 3923.92 "Анатолий Кулаков" И давайте посмотрим, для каких языков поддерживается код QL.
3923.92 3925.92 "Анатолий Кулаков" Прежде всего, это, конечно, C#.
3925.92 3933.92 "Анатолий Кулаков" Поддержка есть. Дальше есть C, C++, Go, Java, JavaScript, TypeScript и Python.
3933.92 3949.92 "Анатолий Кулаков" То есть, если у вас репозиторий на этих языках, вы уже сейчас можете пойти, включить код scans и попробовать, как это будет работать у вас в действии. За время бета-тестирования было просканировано более 12 тысяч репозиториев, то есть добровольцев нашлось достаточно.
3949.92 3967.92 "Анатолий Кулаков" Это около полтора миллиона сканов. Было найдено 20 тысяч security-уязвимостей. Среди них есть такие страшные, как remote code execution, SQL injection, cross-site scripting и вот такие, казалось бы, довольно-таки умные вещи, которых могут разобраться только security-специалисты.
3967.92 3971.92 "Анатолий Кулаков" Фиксились в домашних, базовых репозиториях.
3971.92 3975.92 "Анатолий Кулаков" И на это не уходило много сил даже тем людям, которые в этом ничего не соображают.
3975.92 3977.92 "Анатолий Кулаков" А уязвимости довольно серьезные.
3977.92 3987.92 "Анатолий Кулаков" И наш мир, по идее, должен стать очень-очень безопасным, если каждый из вас пойдет и в своих репозиториях включит такие штуки, как код сканинг.
3987.92 4001.92 "Игорь Лабутин" Да. Хотя, конечно, надо смотреть, где используется этот код из этих репозиториев. Возможно, он деплоится у вас во внутренней вашей среде, куда никому другому доступа нет. И тогда, наверное, это не так уж важно. Хотя, почему он тогда лежит на GitHub, интересно.
4001.92 4011.92 "Анатолий Кулаков" Интересно тренироваться, не допустить security уязвимости даже в своем PET-проекте для того, чтобы пойти на следующий день в рабочий enterprise и не сделать там
4011.92 4019.92 "Игорь Лабутин" таких же точных глупостей. Это да. А вот куда можно пойти, это на GitHub в октябре и что-нибудь сделать и что-нибудь за это получить.
4019.92 4021.92 "Игорь Лабутин" Расскажи нам про Hacktoberfest.
4021.92 4023.92 "Анатолий Кулаков" И с глупостями это тоже, в принципе, совпадает.
4023.92 4025.92 "Анатолий Кулаков" Но давайте начнем по порядку.
4025.92 4027.92 "Анатолий Кулаков" Действительно начался Hacktoberfest.
4027.92 4033.92 "Анатолий Кулаков" Если кто не знает, это специальная инициатива от DigitalOcean.
4033.92 4035.92 "Анатолий Кулаков" Направлена она на поддержку open-source.
4035.92 4041.92 "Анатолий Кулаков" И она раздает маечки. Раздает маечки к контрибьютерам в open-source.
4041.92 4047.92 "Анатолий Кулаков" Вы получаете маечку из лимитированной коллекции, довольно-таки красивенькую такую, каждую год разную.
4047.92 4061.92 "Анатолий Кулаков" Инициатива открыта для всех и каждого, кто хочет научиться контрабидить в open-source или уже контрабидит, или хоть как-то хочет быть связан с DigitalOcean, или просто кто хочет себе чистую майку.
4061.92 4077.92 "Анатолий Кулаков" Для того, чтобы поучаствовать в этом фестивале, вам нужно залогиниться, прежде всего зарегистрироваться на специальном сайте. Дальше с 1 по 31 октября сделать как минимум 4 валидных pull-requests.
4077.92 4079.92 "Анатолий Кулаков" Это те pull-requests, которые будут приняты автором.
4079.92 4085.92 "Анатолий Кулаков" И за это вы получите маечку. В принципе, и все. Условия довольно простые.
4085.92 4087.92 "Анатолий Кулаков" Возможности понятны.
4087.92 4089.92 "Анатолий Кулаков" Все, в принципе, ясно и очевидно.
4089.92 4101.92 "Анатолий Кулаков" И вот почему этот фестиваль получил такую большую популярность и очень много людей каждый год в нем участвуют. Кто-то ради фана, кто-то ради майки, кто-то просто для того, чтобы поддержать open-source движение.
4101.92 4133.92 "Анатолий Кулаков" Но в этом году неожиданно получилась интересная особенность у фестиваля. Дело в том, что один из пропагандистов, ну то есть людей, которые как мы призывали контрибьютить, призывали участвовать в open-source, призывали открывать свои pull-requests, он опрометчиво сделал странный пример. Он предложил своим зрителям просто добавить, например, в readme-файл строчку SM-project, типа "Какой прекрасный проект!" и предложить такой вот pull-request в репозитории, в любой репозитории на GitHub.
4133.92 4141.92 "Анатолий Кулаков" И, естественно, некоторые личности подумали, что именно так и надо делать. Довольно-таки легко. Всего 3 секунды и майка твоя.
4141.92 4159.92 "Анатолий Кулаков" А GitHub накрыло просто море спам-pull-requests, которые добавляли какие-то непонятные строчки, типа SM-project, it's a good и прочие какие-то странные глупости. Ну то есть абсолютный спам, который не вел ни к чему продуктивному и только лишь отвлекал авторов.
4159.92 4209.92 "Анатолий Кулаков" Разразилась буря, разразился скандал, авторы репозиториев начали кричать, что вы нам мешаете работать, засоряете тут все, уберите своих новичков, желторотиков. И получился такой немножко негативная волна, которая как раз-таки противоречит духу Hacktoberfest, противоречит тому, что мы должны больше заниматься open-source и больше привносить сюда новичков. Поэтому ребята из DigitalOcean сильно не растерялись. Они сколлаборировались с GitHub и придумали другую стратегию контрибьюта. То есть раньше все репозитории, которые не хотели получать к себе pull-requests из этого фестиваля, они должны были отписаться фестивалю и сказать, пожалуйста, не учитывайте pull-requests в моем репозитории, не пускайте сюда никого, я не хочу в этом участвовать. Сейчас же пришлось сделать наоборот.
4209.92 4231.92 "Анатолий Кулаков" То есть, если ваш репозиторий хочет участвовать в Hacktoberfest, вы должны в своем репозитории специально сделать топик. Топики - это такие небольшие кей-ворды возле названия вашей репозитории. То есть, сделать специальный топик Hacktoberfest, и тогда участники будут направлять вам свои pull-requests и будут получать за это майки.
4231.92 4245.92 "Анатолий Кулаков" Так что будьте внимательны, если вы автор какого-то репозитория, вам нужно специально пометить свой топик, для того, чтобы к вам пришли добровольцы. А если же вы сами хотите заработать маечку, то внимательно следите за теми репозиториями, которые предоставляют такую возможность.
4245.92 4271.92 "Анатолий Кулаков" Еще одна интересная статейка в эту же тему. JetBrains подсуетился, он является спонсором Hacktoberfest'а, и сделал интересную подборочку проектов, которым мог бы законтрибьютить .NET разработчик. Кстати, JetBrains на время Hacktoberfest'а, то есть на время всего этого месяца, всего октября, предоставляет бесплатную лицензию All-Product Pack для любого своего продукта.
4271.92 4283.92 "Анатолий Кулаков" Поэтому это еще отличная возможность целый месяц посидеть на любой DA, попробовать ее потыкать на свеженькой и красивой. Но вернемся все-таки к проектам. Некоторые из них мы вам рекомендовали попробовать, некоторые - нет.
4283.92 4289.92 "Анатолий Кулаков" Давайте я быстренько пробегусь, вдруг у кого-то в памяти всплывет, и вы все-таки захотите посмотреть, чем вы можете помочь этому проекту.
4289.92 4295.92 "Анатолий Кулаков" Прежде всего это Fluent Validation. Это, наверное, один из самых старых .NET проектов.
4295.92 4297.92 "Анатолий Кулаков" Ему сейчас уже 11 лет.
4297.92 4303.92 "Анатолий Кулаков" Он по-прежнему используется очень широко, очень массово, и ему нужны какие-то помощи, контрибьюты.
4303.92 4307.92 "Анатолий Кулаков" Можно зайти посмотреть. Другой интересный проект - это Spectre Console.
4307.92 4313.92 "Анатолий Кулаков" Специальная библиотечка, которая позволяет выжать из вашего терминала 24 бита цвета.
4313.92 4319.92 "Анатолий Кулаков" То есть вы вполне-то можете рисовать обычные картинки, смайлы, вставлять какие-то градиенты и так далее.
4319.92 4327.92 "Анатолий Кулаков" Если вы вдруг захотите сделать цветную консоль, или написать там свой редактор, или свой файловый менеджер в консоли, то посмотрите. Может быть, это будет интересно.
4327.92 4329.92 "Анатолий Кулаков" Следующая библиотечка - Carter.
4329.92 4331.92 "Анатолий Кулаков" Мы ее тоже обсуждали.
4331.92 4335.92 "Анатолий Кулаков" Это наследник Nancy FFX, который был вынужден нас покинуть.
4335.92 4365.92 "Анатолий Кулаков" Довольно быстренький, довольно удобный API и довольно читабельный и красивый, который интегрируется в существующий WinPipeline и работает вместе с ISP.NET Core, как более эффективный и более читабельный роут. Дальше - Fable и SafeStack. Это возможность на F# написать JavaScript-код и, соответственно, сделать полностью full-stack приложение полностью на F#. Начиная от backend'а, заканчивая frontend'ом и при этом ни разу не касаясь багомерзкого JavaScript.
4365.92 4369.92 "Анатолий Кулаков" Интересный проект. Я про него как раз-таки первый раз услышал.
4369.92 4373.92 "Анатолий Кулаков" Это называется MediaDump Management Solution.
4373.92 4379.92 "Анатолий Кулаков" Это такой инструмент, который может считывать информацию из всяких образов диска.
4379.92 4389.92 "Анатолий Кулаков" Не только считывать, но и записывать, редактировать метаданные, объединять, мержить, сделать compile, делать diff между разными имиджами и так далее.
4389.92 4395.92 "Анатолий Кулаков" Поддерживается огромная куча форматов. Я просто только никогда не видел. Не знаю, где на практике это сейчас можно применить.
4395.92 4403.92 "Анатолий Кулаков" Я как-то далек от этой области. Раньше, когда мы хакали болванки и записывали много пиратского софта, там эта тема была актуальной.
4403.92 4411.92 "Анатолий Кулаков" Static. Это статический сайт-генератор на C#. Наверное, сейчас самый популярный и самый перспективный.
4411.92 4423.92 "Анатолий Кулаков" Nuke. Билд-система, которая позволяет вам красиво писать ваши билд-скрипты на C# вместе с нормальным интеллисенсом, дебагом и все как положено. Прекрасный проект.
4423.92 4425.92 "Анатолий Кулаков" Тоже посмотрите на него обязательно.
4425.92 4427.92 "Анатолий Кулаков" Reactive UI.
4427.92 4437.92 "Анатолий Кулаков" То есть, как написать UI с использованием реактивных подходов, с обзерваблами и прочими реактивными штучками.
4437.92 4441.92 "Анатолий Кулаков" Большой проект. Очень много всего умеет. Очень мощный.
4441.92 4445.92 "Анатолий Кулаков" Отличная документация. Тоже прекрасная точка для инвестиций.
4445.92 4451.92 "Анатолий Кулаков" Martin. Martin - это использование подростков SQL, документно-ориентированная база данных.
4451.92 4467.92 "Анатолий Кулаков" Идея интересна тем, что вы бесплатно получаете AC транзакции, плюс ко всему, и при этом документно-ориентированная база данных. Люди, которые занимаются persistence, базами данных, оптимизацией хранения и так далее. Этот проект тоже может быть интересен. И еще куча-куча много всяких интересных проектов.
4467.92 4479.92 "Анатолий Кулаков" Можете зайти на страничку JetBrains или еще на другие страницы, которые появляются в честь Oktoberfest. И там найдете много-много потрясающих примеров, потрясающих проектов.
4479.92 4503.92 "Анатолий Кулаков" Я рекомендую мой любимый сайт, который называется app4grabs.net. Это сайт, который автоматически по специальным тегам, который называется app4grabs.goodfirst.ishu и так далее, с GitHub'а собирает проекты, которым нужна помощь, и помогает вам в одном окошке поискать то, что вам интересно. В общем, друзья, для контрибьюта в open-source сейчас практически нет никаких проблем. Нужно только ваше желание.
4503.92 4513.92 "Анатолий Кулаков" Инструменты бесплатные, проектов миллион, комьюнити довольно-таки вежливое и доброе. Оно вас с радостью ждет, а тут плюс еще чистую майку дадут. Ну вообще праздник жизни какой-то.
4513.92 4523.92 "Игорь Лабутин" Ну и на этой оптимистической ноте я думаю, что можно заканчивать наши сегодняшние беседы. Мы очень много успели обсудить. И давайте кратенько, как обычно, пробежимся.
4523.92 4531.92 "Игорь Лабутин" Что же это было? Для начала мы вспомнили, что у нас открывается осенний конференциальный сезон. Будет TechTrain, будет .NET Conf.
4531.92 4547.92 "Игорь Лабутин" Заходите, изучайте, смотрите, что будет новенького. Дальше мы пробежались по .NET 5.0 Release Candidate 2, что в нем появилось из новинок. Хинт - особо ничего, но это стабилизация. И вы уже можете начинать использовать версию версии 2 в продакшене.
4547.92 4559.92 "Игорь Лабутин" Microsoft гарантирует поддержку. Посмотрели на новый WinUI, на планы по тому, как будет готовиться третья версия, точнее третье поколение, можно сказать, и отвязываться от Windows 10.
4559.92 4569.92 "Игорь Лабутин" Посмотрели на то, как Microsoft рекомендует рассматривать .NET Core релизы и какие версии будут поддерживаться долго, какие - не очень долго, и как это понимать самим.
4569.92 4583.92 "Игорь Лабутин" Напомнили, что переход с 3.1 на 5.0 в .NET будет сопровождаться некоторым количеством breaking changes. И у Microsoft есть отличная статья с их подробным списком и методами, как с ними бороться или как их отключать.
4583.92 4585.92 "Игорь Лабутин" Эти самые ченьжи.
4585.92 4593.92 "Игорь Лабутин" И посмотрели на пример того, как Stack Overflow уже смедлили. После этого мы пошли в сторону Tools и вообще всяческих рекомендаций.
4593.92 4603.92 "Игорь Лабутин" И посмотрели на то, как память вашего приложения держать в чистоте и целости и сохранности, чтобы вы много памяти не кушали, точнее, ваше приложение, и как за этим всем следить.
4603.92 4611.92 "Игорь Лабутин" Посмотрели, как правильно работать с коллекциями, и что у нас появилось в новой Nougat пакет с разлинным аналайзерами на тему коллекции.
4611.92 4615.92 "Игорь Лабутин" Возможно, его надо расширить, и всем остальным без счастья.
4615.92 4623.92 "Игорь Лабутин" Посмотрели на эксперименты Erika Sienko с Alviyam и DotNet, на эксперименты JetBrains с одновременной работой над одним и тем же кодом.
4623.92 4631.92 "Игорь Лабутин" Ну, уже такой E-up-эксперимент. Узнали про то, что произойдет с Intensity Server версии 5. Теперь за него надо платить денег.
4631.92 4633.92 "Игорь Лабутин" Или использовать его в open-source проектах.
4633.92 4641.92 "Игорь Лабутин" Посмотрели, как GitHub будет заботиться о секьюрости вашего кода путем специального кода сканинга автоматического для нескольких языков.
4641.92 4647.92 "Игорь Лабутин" И узнали, что в октябре можно клево законтрибьюти open-source еще и с практической пользой в виде красивой маячки-футболочки.
4647.92 4653.92 "Игорь Лабутин" Ну, и на самом деле, это, конечно же, не главная цель. Главная цель - это поддержка DotNet и не только DotNet в open-source комьюнити.
4653.92 4655.92 "Игорь Лабутин" На этом, я думаю, что мы заканчиваем.
4655.92 4657.92 "Анатолий Кулаков" Да, да, мы заканчиваем.
4657.92 4669.92 "Анатолий Кулаков" Я хочу напомнить, что вы можете нас послушать в десятки различных сервисов, включая Spotify, Google Podcast, Apple Podcast, Яндекс Подкасты, YouTube и много-много где еще.
4669.92 4675.92 "Анатолий Кулаков" Поэтому не стесняйтесь, слушайте нас, рекомендуйте нас своим друзьям, рассказывайте о нас, лайкайте.
4675.92 4679.92 "Анатолий Кулаков" Комментарии мы в основном поднимаем на YouTube.
4679.92 4681.92 "Анатолий Кулаков" И поддерживайте нас, нам это очень-очень приятно.
4681.92 4683.92 "Анатолий Кулаков" И на сегодня все.
4683.92 4685.92 "Игорь Лабутин" С вами был Игорь Лабутин и Анатолий Кулаков.
4685.92 4687.92 "Анатолий Кулаков" Всем пока. Пока.
4687.92 4695.84 None [музыка] [музыка]
