0.00 7.88 "Анатолий Кулаков" Здравствуйте, дорогие друзья!
7.88 11.44 "Анатолий Кулаков" В эфире Радио.нет выпуск номер 67.
11.44 15.60 "Анатолий Кулаков" С вами его бессменные ведущие Анатолий Кулаков и Игорь Лабутин.
15.60 16.60 "Анатолий Кулаков" Всем привет!
16.60 26.32 "Анатолий Кулаков" Прежде всего большое спасибо нашим помогаторам, в частности Александр, Сергей, Владислав, Алексей, Шевченко, Антон, Илья, Гурий Самарин и Виктор.
26.32 37.24 "Анатолий Кулаков" Спасибо, друзья, а также всем, кто нас шарит, репостит, поделится с нашими друзьями и всячески помогает продвинуть подкаст и полезные знания про Дотнет среди разработчиков.
37.24 39.60 "Анатолий Кулаков" Спасибо всем, друзья, за поддержку.
39.60 49.08 "Анатолий Кулаков" Ну что ж, у нас сегодня наконец-то вышли первые анонсы, первые релизы, накопились интересные статейки, и выпуск должен быть довольно богатым и интересным.
49.08 50.08 "Анатолий Кулаков" С чего начнем?
50.08 51.88 "Игорь Лабутин" Начнем с Дотнет 8.
51.88 59.80 "Игорь Лабутин" Действительно, вышел наконец-то первый превью, и в нем уже некоторое количество довольно интересных вещей, сейчас мы по ним бегло пробежимся.
59.80 72.52 "Игорь Лабутин" Начнем с того, что все это работает с Visual Studio 17.6 Preview 1, поэтому если вы хотите использовать Visual Studio, вам нужно поставить превью-версию, ну, SDK, с Command Line, понятно, просто ставите превью и все работает.
72.52 85.52 "Игорь Лабутин" В Дотнет 8 появилось некоторое количество общих штук, мы, как обычно, пройдемся сначала по самому Дотнет 8, а потом по разным прикладным библиотекам типа SPNeta и Entity Framework.
85.52 101.60 "Игорь Лабутин" В Дотнет 8 продолжают работу над Native Out, Ahead of Time Compilation, это штука, которая позволяет вам собрать ваше Дотнет приложение сразу в нативный бинарник, в котором не будет никакого джета, а сразу будет нативный код.
101.60 121.56 "Игорь Лабутин" Так вот, в Preview 1 появилась возможность собирать приложение для macOS, кроме того, ведется активная работа над уменьшением размера, того, что получается в результате Native Out, и уже сейчас добились результатов по практически 50% уменьшению размера для Hello World.
121.56 130.08 "Игорь Лабутин" На Linux раньше было 3.7 Мб, а стало 1.8, а на Windows было 2.8, поменьше, чем на Linux, стало 1.7, еще меньше, чем на Linux.
130.08 137.88 "Игорь Лабутин" В общем, Hello World становится еще меньше, посмотрим, насколько будут становиться маленькими приложения, которые содержат что-то более существенное.
137.88 151.84 "Игорь Лабутин" Хотя это на самом деле показывает, что в 1.7 Мб влезает практически весь, ну, скажем так, базовый рантайм, да, то есть Garbage Collector и все, что нужно для запуска вашего приложения, то есть уже неплохо.
151.84 170.16 "Игорь Лабутин" Напомню, что преимуществами Native Out, по мнению Microsoft, ну и вообще является уменьшенный расход памяти, как это ни странно, потому что не нужно хранить в памяти менеджмент код, не нужно его джетить, генерировать память на лету, а сразу код берется из вашего бинарника.
170.16 174.96 "Игорь Лабутин" Улучшенное время запуска, понятное дело, не нужно джетить никакой код, он сразу готов к исполнению.
174.96 182.40 "Игорь Лабутин" И это важно особенно для мобильных устройств, улучшать время жизни от батарейки, потому что не тратится CPU на то, чтобы этот самый код джетить.
182.40 189.12 "Игорь Лабутин" В общем, без джета жизнь хорошая, и Microsoft очень многое активно вкладывается в Native Out.
189.12 197.56 "Игорь Лабутин" Если же мы уйдем от Native Out в сторону классических серверных сценариев, это контейнеры, и там тоже произошли изменения.
197.56 213.00 "Игорь Лабутин" Во-первых, теперь дефолтный дистрибутив для Linux - это Debian 12, он еще официально не полностью зарелизен, ну в смысле, официального релиза не было, но к моменту выпуска DotNet 8 в ноябре, Debian где-то по плану у них в июле или в август релиз, поэтому будет уже готовый релизный.
213.00 228.40 "Игорь Лабутин" Все новые имиджи контейнеров, которые генерятся Microsoft, они теперь поддерживают исполнение без рута, то есть rootless или non-root, и из-за этого пришлось поменять дефолтный порт, он теперь не 80, а 8080, потому что 80-й порт доступен только руту.
228.40 236.24 "Игорь Лабутин" Соответственно, ну вот такие изменения, если вы используете DotNet образы контейнеров, то помните, что дефолтный порт поменялся.
236.24 241.56 "Игорь Лабутин" Но с другой стороны, вы теперь можете их использовать по дефолту в безрутовом варианте.
241.56 253.36 "Игорь Лабутин" В runtime библиотеках тоже произошли изменения, там в основном пока такие мелкие улучшения вокруг полезных классов или может быть не очень полезных классов.
253.36 270.08 "Игорь Лабутин" Во-первых, добавили специальные utility методы для всяких штук вокруг случайностей, то есть теперь есть метод shuffle и есть метод getItems, который возвращает случайную коллекцию из заданной коллекции, а shuffle перемешивает случайно образом коллекцию.
270.08 287.72 "Игорь Лабутин" Тип Vector256 заимплементировали как пару типов Vector128, это помогает хорошей скорости и параллелизации, точнее работе всех симдов и прочего на архитектурах, которые не поддерживают Vector256, например армы.
287.72 290.44 "Игорь Лабутин" Таким образом будет работать все равно все побыстрее.
290.44 309.36 "Игорь Лабутин" В JSON в System Text.JSON завезли improvement, во-первых, теперь можно с помощью атрибутика JSONUnmappedMemberHandling задать стратегию обработки отсутствующих мемберов, то есть если у вас в JSON что-то есть, а в классе этого нет, то можно задать стратегию, что с этим делать.
309.36 327.48 "Игорь Лабутин" Сурсгенераторы для System Text.JSON обновили для поддержки required и need-пропертей, добавили поддержку иерархии интерфейсов, можно теперь использовать snake case, это который через подчеркивание, или kebab case, это который через минус-именование этих самых ключиков в JSON.
327.48 343.08 "Игорь Лабутин" Ну и у JSON Serializer завезли метод makeReadOnly, он позволяет настроить JSON Serializer, сказать ему makeReadOnly, это значит, что после этого JSON Serializer нельзя перенастраивать, и еще у него можно спросить, является ли он read-only, из-за read-only.
343.08 349.68 "Игорь Лабутин" Ну вот, видимо из-за этого можно там внутри какие-то performance-оптимизации сделать сразу уже.
349.68 370.16 "Игорь Лабутин" И DotNet 8, как обычно, заботится о performance, потому что завезли некоторое количество типов, которые прямо ориентированы на performance, то есть во-первых, это frozen dictionary, frozen set, мне кажется мы их уже как-то обсуждали в каком-то из типо ранних выпусков, ну недавних выпусков.
370.16 372.80 "Игорь Лабутин" Да, было дело.
372.80 378.44 "Игорь Лабутин" Дальше, я не знаю, ты пользуешься классом под названием immutable array?
378.44 387.60 "Анатолий Кулаков" Нет, не приходилось, ну то есть я знаю, и код даже видел, смотрел, но как-то на практике мне read-only листа вполне хватает.
387.60 409.56 "Игорь Лабутин" Ну вот, мне обычно тоже, но видимо кто-то этим пользуется, потому что теперь для того, чтобы строить эти immutable array использовался вложенный класс под названием builder, который там внутри immutable array лежал, вот его оптимизировали, чтобы он максимально эффективно конвертил результат того, что он там строит, в финальный immutable array, то есть видимо какие-то заказчики этим пользуются и просили такую оптимизацию.
409.56 415.76 "Анатолий Кулаков" Слушай, ну прежде всего весь рослинг на этих immutable коллекциях построен, как бы сами для себя как минимум пользу этому принесли.
415.76 420.48 "Игорь Лабутин" Ну, видимо, да, возможно действительно сами для себя именно как раз-таки это все и делают.
420.48 426.16 "Игорь Лабутин" Дальше интересный тип, добавили тип под названием index of any values от T.
426.16 427.88 "Игорь Лабутин" Че, так и называется прям, да?
427.88 429.48 "Игорь Лабутин" Да, это название типа.
429.48 432.92 "Игорь Лабутин" Index of any values, нужен он для вот для чего.
432.92 447.04 "Игорь Лабутин" Если вы часто используете string.indexOfAny и туда передаете строчку символов, которые вы хотите поискать, то есть найди мне, пожалуйста, первый индекс, где встречается какой-либо из заданных символов, да, там точка запятая или еще что-нибудь.
447.04 450.08 "Игорь Лабутин" Ну, наверное, вот это довольно популярный кейс и часто
450.08 452.08 "Анатолий Кулаков" используют. Ну, да, это частый случай, согласен.
452.08 463.32 "Игорь Лабутин" Вот, теперь можно создать instance типа indexOfAnyValues, передать туда вот ту строчку, по которой вы ищете, а instance этого типа передавать в этот indexOfAny.
463.32 486.64 "Игорь Лабутин" И поскольку тип внутри себя знает эту строчку на момент своего создания, создается он один раз, ну, допустим, в принципе, эта строчка если не меняется, обычно они константы, да, это какие-нибудь разделители еще что-нибудь, вы ее объявляете там статической, readonly, вот это все, она внутри себя производит оптимизацию, как можно быстрее проверить вхождение вот этих вот символов, не знаю, там, битовые операции какие-нибудь, еще что-нибудь.
486.64 491.84 "Игорь Лабутин" И в итоге indexOfAny, когда на стринге вызовется, она прям будет работать ух, и быстро.
491.84 498.56 "Анатолий Кулаков" Интересно, да, хорошая оптимизация, но просто как-то подошли к ней слишком чепорно уж.
498.56 516.20 "Игорь Лабутин" И такой же тип по смыслу называется теперь compositeFormat, туда нужно, соответственно, передавать строчку, форматную строчку, вот это все с фигурной скобочкой 0, с фигурной скобочкой 1 или с именами, соответственно, и дальше instance этого типа передавать в stringFormat.
516.20 528.80 "Игорь Лабутин" Здесь бонус в том, что не будет каждый раз парситься эта форматная строка, она парсится один раз, результат парсинга запоминается вот в этом типе compositeFormat, и дальше stringFormat уже использует готовую, так сказать, закешированную информацию о распарсенной строке.
528.80 535.28 "Анатолий Кулаков" Ну, решение понятно, оптимизация понятная, но выглядит как-то некрасиво.
535.28 545.60 "Игорь Лабутин" Ну, если мы нашли в каком-нибудь там, опять же, в каких-нибудь бенчмарках у себя вот такую штуку, улучшили, там, Roslyn стал чуть быстрее работать, уже хорошо.
545.60 546.60 "Игорь Лабутин" Дальше, .NET SDK.
546.60 553.84 "Игорь Лабутин" В .NET SDK есть, ну это не то чтобы breaking change, это поведение, которое поменяется, которое вы возможно заметите.
553.84 564.20 "Игорь Лабутин" Если вы сделаете .NET Publish или .NET Pack без дополнительных аргументов, то по дефолту теперь будет генериться релиз версии, а не дебаг.
564.20 573.44 "Игорь Лабутин" Потому что Microsoft посчитала, что собственно, что .NET Pack, что .NET Publish, ну вообще говоря, в среднем используется для того, чтобы релизные версии либо паковать в NuGet, либо, соответственно, паблишить куда-то.
573.44 578.00 "Игорь Лабутин" Редко нужно паблишить дебажную версию, а тем более паковать её в NuGet.
578.00 579.00 "Анатолий Кулаков" Ну ладно, а build?
579.00 580.00 "Анатолий Кулаков" Билд?
580.00 583.00 "Игорь Лабутин" Нет, build, билдит как пораньше, как раньше.
583.00 586.76 "Игорь Лабутин" То есть это касается только .NET Publish и .NET Pack.
586.76 592.48 "Анатолий Кулаков" Но просто теперь тогда они будут расходиться, и это намного хуже, чем pack по дефолту в дебажной версии.
592.48 596.60 "Анатолий Кулаков" Собственно, это какая-то чушь была, но мне кажется, это была единообразно.
596.60 600.52 "Анатолий Кулаков" А теперь это будет по-разному, и это будет ещё больше путаниц и багов.
600.52 601.52 "Игорь Лабутин" Всё так.
601.52 607.48 "Игорь Лабутин" Более того, на самом деле, это поведение существует в версии семёрки .NET, начиная с 7.0.200 SDK.
607.48 609.56 "Игорь Лабутин" Там его нужно было включать.
609.56 617.08 "Игорь Лабутин" Эту штуку можно выключить, задав project properties publish release xrs-na-pack-release-properties в false.
617.08 619.68 "Игорь Лабутин" Тогда будет по-старинке, но вот, понимаете, вот такое
619.68 622.28 None сделали. Говорят, в общем, просили.
622.28 628.56 "Анатолий Кулаков" Лучше всего явно всегда указывайте, не опираясь ни на дефолт, ни на версию, ни на флажочки.
628.56 632.24 "Игорь Лабутин" Просто всегда указывайте, что вы хотите.
632.24 633.24 "Игорь Лабутин" Да.
633.24 634.24 "Игорь Лабутин" Дальше.
634.24 635.24 "Игорь Лабутин" С поддержкой Linux.
635.24 644.00 "Игорь Лабутин" Помнишь, мы обсуждали в какой-то момент, это было где-то в ноябре или в декабре, большую новую монорепу, мега-монорепу для сборки всего .NET из исходников?
644.00 645.72 "Игорь Лабутин" Да, да, да, было дело.
645.72 647.60 "Анатолий Кулаков" Ещё, по-моему, название какое-то хорошее было.
647.60 648.60 "Игорь Лабутин" Ну .NET/.NET.
648.60 649.60 "Игорь Лабутин" Да.
649.60 650.60 "Игорь Лабутин" Монорепа называется так.
650.60 660.04 "Игорь Лабутин" Там у неё есть какое-то правильное название, типа virtual что-то там, virtual VMR, по-моему, они называют, virtual monorepository, вот.
660.04 665.68 "Игорь Лабутин" Потому что она virtual, она потому что она собирается скриптами из других репозиторий.
665.68 668.52 "Игорь Лабутин" То есть туда никто ничего не коммитит, туда всё скрипты автоматически собирают.
668.52 684.48 "Игорь Лабутин" Так вот, теперь оттуда можно всё собрать для Linux пока только, то есть вы можете склонировать этот репозиторий, сказать там то ли build, то ли, ну я не помню, что там вредный написано, и всё у вас соберётся полностью готовое SDK для Linux.
684.48 690.80 "Игорь Лабутин" Это, собственно, тот же самый build, который используют Red Hat и Canonical для своих, соответственно, операционок.
690.80 693.68 "Игорь Лабутин" Будет такое же для Windows и Mac OS, но попозже.
693.68 696.40 "Игорь Лабутин" Не факт, что успеют в .NET 8.
696.40 701.80 "Игорь Лабутин" И сейчас они ещё сказали, что теперь .NET будет таргетить Ubuntu 16.04 новее.
701.80 705.00 "Игорь Лабутин" Ну 16 уже, сама по себе, по-моему, старая довольно-таки.
705.00 707.60 "Игорь Лабутин" Я не помню, но какая-то очень старая.
707.60 711.32 "Игорь Лабутин" А, соответственно, Red Hat, они будут таргетить 8 или позднее.
711.32 713.56 "Игорь Лабутин" Именно-то нужно, чтобы там Jelibs был нормальный.
713.56 717.24 "Игорь Лабутин" Но я не думаю, что это кого-то заденет, потому что кажется, что это довольно старая версия.
717.24 723.76 "Игорь Лабутин" И отдельная часть анонса, конечно же, посвящена всяким импрументам в CodeGene, я не буду по ним проходиться.
723.76 729.60 "Игорь Лабутин" Там всякие очень нишевые штуки, которые просто на слух вас принимать будет очень тяжело, если интересно, почитайте там.
729.60 732.04 "Игорь Лабутин" Просто ссылки на pull requests или на ishes.
732.04 735.72 "Игорь Лабутин" Типа, а вот мы улучшили такое хитрое поведение в таком хитром случае.
735.72 740.04 "Игорь Лабутин" Примерно так в основной части дотнета.
740.04 741.04 "Игорь Лабутин" Отлично.
741.04 754.68 "Игорь Лабутин" Остальные кусочки дотнета, назовем это так, да, библиотеки, не знаю, фреймворки поверх дотнета, у них статьи про превью в основном были про… Ну даже не то, что в основном.
754.68 760.80 "Игорь Лабутин" Они начинались с того, что они рассказывали про цели, того вообще про планы на дотнет 8.
760.80 766.40 "Игорь Лабутин" И, точнёмся, спонета, у которого есть по большому счёту три больших цели.
766.40 772.80 "Игорь Лабутин" Это глобальные цели, которые будут определять общую работу, так сказать, направление работы всей команды, но это не значит, что ничего другого делать не будет.
772.80 779.16 "Игорь Лабутин" Как вы увидите, это чуть дальше по списку тех нововведений, которые попали в превью 1.
779.16 780.16 "Игорь Лабутин" Так вот, цели три.
780.16 782.64 "Игорь Лабутин" Цель первая называется Blazer United.
782.64 788.40 "Игорь Лабутин" У нас сейчас есть несколько способов собирать какой-никакой UI на дотнете.
788.40 800.60 "Игорь Лабутин" Вы можете использовать MVC, Razor Pages, можно использовать Blazer, соответственно, у нас есть Server-side Rendering, есть Client-side Rendering, если мы делаем Blazer в Wasm, соответственно.
800.60 806.52 "Игорь Лабутин" Но при этом современные приложения, как говорит Microsoft, требуют на самом деле и того, и другого.
806.52 810.00 "Игорь Лабутин" То есть иногда полезен Server-side Rendering, иногда полезен Client-side Rendering.
810.00 815.64 "Игорь Лабутин" В дотнет 8 ставится, так сказать, Uber-цель.
815.64 831.32 "Игорь Лабутин" Создать, так сказать, единый не то что фреймворк, но это больше может быть даже не про технологии, а про описание и документацию, но скорее всего в технологическом плане там что-то тоже будет меняться в виде штуки под названием Blazer United.
831.32 856.36 "Игорь Лабутин" То есть это некоторый, так сказать, подход, не знаю, я не готов называть это фреймворком, пока я из описания не очень понял, что это будет финально, который позволит как раз-таки унифицировать, грубо говоря, разработку UI на дотнете именно для веб-приложений с тем, чтобы у вас был одинаковый, видимо, экспириенс при разработке что Server-side, что Client-side приложений.
856.36 858.88 "Игорь Лабутин" Server-side Rendering и Client-side Rendering.
858.88 859.88 "Игорь Лабутин" В общем, посмотрим.
859.88 865.40 "Игорь Лабутин" Это пока цель, там есть детали, но посмотрим, во что это будет вливаться технологически.
865.40 869.72 "Игорь Лабутин" Вторая большая цель — это улучшение в аутентификации и авторизации.
869.72 877.92 "Игорь Лабутин" И здесь тоже кажется, что в основном это все будет вокруг документации, потому что там написано три пункта.
877.92 900.36 "Игорь Лабутин" Во-первых, создать простой и хорошо документированный, так сказать, экспириенс, ну, create experience, не знаю, обеспечить простой и хорошо документированный подход для реализации аутентификации и авторизации, то есть, видимо, что-то будет меняться вокруг system identity и вот этих всех остальных вещей, которые довольно сложные.
900.36 916.00 "Игорь Лабутин" Точнее, не то что сложные, я так понимаю, что основная сложность вот всей этой работы вокруг identity, авторизации и аутентификации в Дотнете в том, что, одна из частей этой сложности в том, что терминология, которая там используется, не совсем совпадает с классическим OAuth и OpenID Connect.
916.00 920.80 "Игорь Лабутин" Они ссылаются все время на них, но фактически у них своя технология исторически сложившаяся.
920.80 924.88 "Игорь Лабутин" Из-за этого тяжеловато мне, например, было читать документацию местами.
924.88 951.68 "Игорь Лабутин" А дальше они говорят, что они хотят сделать, по-английски это называется provide clear steps and tools for production environments, то есть, видимо, это в камень в огород всяких identity серверов и прочего, то есть, они хотят документировать как-то, собственно, что же делать-то в production, как там, может быть, будут что-то писать про то, как интегрироваться с kicklock и прочими сторонними сервисами, типа Auth0, не знаю, посмотрим.
951.68 965.16 "Игорь Лабутин" А, и третий пункт это deliver meaningful diagnostics, то есть, с диагностикой, мы, кстати, это обсуждали в прошлый раз, что там identity server, да, какие-то там логи, логи, он, по-моему, писал какие-то у нас не те, не на тех уровнях.
965.16 968.64 "Игорь Лабутин" Ну, да, не на стандартных, которые Microsoft обычно использует.
968.64 986.20 "Игорь Лабутин" И вообще с диагностикой аутентификационной части в дублинете, видимо, по мнению самого Microsoft, не так, чтобы хорошо, не то, чтобы я, например, сильно страдал, когда с ней работал, но нормально, можно было понять, что там происходит, хотя и не всегда, то есть, в общем, будут какие-то улучшения в диагностике вокруг аутентификации и авторизации.
986.20 1008.52 "Игорь Лабутин" И последний третий пункт это nativeout, с nativeout есть большая проблема в ISP-найте, он сейчас не работает, потому что он использует огромное количество всякой кода генерации на лету, там, динамики, лямпды, рефлекшн и вот это все, и поэтому прямо сделать так, что любое ISP-найт приложение заработает в nativeout, это пока цель слишком амбициозная.
1008.52 1024.48 "Игорь Лабутин" На dotnet 8 цель сделать так, чтобы API-приложение, то есть мы пока не говорим про всякие Razer и прочее, причем API-приложение создано исключительно с minimal API, то есть пока без контроллеров, вот они должны научиться работать в режиме nativeout.
1024.48 1029.48 "Анатолий Кулаков" Ну, началось, теперь уже деление у нас с minimal API хорошее, контроллеры плохие.
1029.48 1033.32 "Игорь Лабутин" Я думаю, что в контроллерах просто слишком много рефлексии и всего остального.
1033.32 1034.32 "Игорь Лабутин" Сделано.
1034.32 1048.32 "Анатолий Кулаков" Понятное дело, да, что контроллеры намного уже сложнее, обросли всем этим старьем, но все же, люди пользуются и контроллеров сейчас все равно намного больше, чем minimal API, и пользы они могли бы принести намного больше.
1048.32 1049.32 "Игорь Лабутин" Правда.
1049.32 1054.24 "Игорь Лабутин" С другой стороны, не знаю, насколько нужен nativeout прямо вот на сервере, ну, честно говоря.
1054.24 1055.24 "Игорь Лабутин" Черт знает.
1055.24 1056.24 "Игорь Лабутин" Я не знаю пока.
1056.24 1057.92 "Анатолий Кулаков" Да, да, наверное, ты прав.
1057.92 1071.96 "Анатолий Кулаков" Может, это как раз и делается для таких каких-нибудь, знаешь, маленьких локальных веб-серверов, знаешь, когда утилитка поднимается локально, и плюс тебе наружу выставляют веб-сервер, который, скорее всего, ты будешь делать на minimal API, и там уже nativeout может тебе что-то интересное
1071.96 1073.96 "Игорь Лабутин" сделать. Да.
1073.96 1079.24 "Игорь Лабутин" Мы, кстати, сейчас чуть-чуть дальше поговорим, где это может быть полезно, почему это может быть полезно для локальных утилиток.
1079.24 1088.84 "Игорь Лабутин" Вот, это были планы, но есть и улучшения, точнее, новинки, улучшения, не знаю, импровменты, как хотите, назовите, в превью 1, которые вышли.
1088.84 1096.48 "Игорь Лабутин" Некоторые из них как-то соотносятся с этими планами, а некоторые вообще просто, так сказать, внезапно сделаны, ну, потому что сделаны.
1096.48 1108.32 "Игорь Лабутин" Первая штука — это route tooling, как они назвали, то есть различный tooling вокруг маршрутов, и это не то, чтобы там что-то поменялось в самой маршрутизации S/P, но это нет, это исключительно всякие.
1108.32 1119.48 "Игорь Лабутин" Синтекс хайлайтинг в Visual Studio раутов, автокомплит параметров и имен маршрутов, аналайзеры всякие, фиксеры, вот это все.
1119.48 1133.36 "Игорь Лабутин" То есть наборов всяких, если вы работаете с раутами, то есть у вас теперь появится аналайзер, который проверяет, что вы нигде не задублировали маршрут, их там можно будет, что-нибудь он там, видимо, будет проверять с учетом всяких минимал-API-ных групп и всего такого.
1133.36 1136.24 "Игорь Лабутин" То есть с маршрутами должно работать полегче.
1136.24 1147.12 "Игорь Лабутин" Ну а в райдере, я так понимаю, давно есть вот это вот… ну не очень давно, где-то в прошлом году уже появилась какая-то продвинутая работа с маршрутами, где можно посмотреть все endpoints твоего приложения и так далее.
1147.12 1149.72 "Анатолий Кулаков" Да-да-да, там какой-то endpoint window или что-то такое.
1149.72 1150.72 "Игорь Лабутин" Вот-вот-вот.
1150.72 1153.20 "Игорь Лабутин" Ну вот, видимо, они что-то вокруг этого тоже в студии пытаются сделать.
1153.20 1169.08 "Игорь Лабутин" При этом появилось улучшение перформанса, то есть вот все эти constraints раутов, то есть когда мы пишем внутри раута, там в фигурных скобочках, мы можем написать, что вот тут может быть, не знаю, только такой-то часть пути, причем удовлетворяющей regex, например.
1169.08 1171.84 "Игорь Лабутин" Их же можно было regexом писать в этом числе.
1171.84 1175.08 "Игорь Лабутин" И вот regex-ы теперь они по дефолту компилируются.
1175.08 1181.44 "Игорь Лабутин" Если и там, и сям у нас используются какие-то одинаковые кусочки, то они будут шариться между друг другом.
1181.44 1188.32 "Игорь Лабутин" Ну и там, где получится, будет использоваться сургенерированные regex-ы, которые работают быстрее, как известно.
1188.32 1194.88 "Игорь Лабутин" Ну это занимает меньше кода, там reflection не используется, ну не reflection, а коды генерации в рантайме не используются и так далее.
1194.88 1198.44 "Игорь Лабутин" В общем, перформанс там тоже улучшится.
1198.44 1204.78 "Игорь Лабутин" Новые аналайзеры вокруг работы с именно ispnet-специфичными штуками.
1204.78 1214.28 "Игорь Лабутин" Есть такой класс, называется header dictionary, это словарик, собственно, где лежат значения хедеров, которые к вам пришли в реквесты, либо вы отправляете в респонсе.
1214.28 1219.12 "Игорь Лабутин" Вот теперь есть аналайзеры, которые подскажут, как правильно с ним работать.
1219.12 1223.96 "Игорь Лабутин" Писать к нему add на самом деле не очень эффективно, проще говорить set или append.
1223.96 1229.08 "Игорь Лабутин" Он там пооптимально работает в этом случае.
1229.08 1244.40 "Игорь Лабутин" Поскольку в прошлом релизе появилась такая штука, что параметр, который передает, вы можете в обработчик вашего, либо в контроллер, либо в minimal API передать теперь параметры какого-то типа, не обязательно примитивного.
1244.40 1255.16 "Игорь Лабутин" И если у него есть метод try_parse или bind_async, то они будут использованы для того, чтобы замапить значение из query строки в значение в instance этого типа.
1255.16 1265.20 "Игорь Лабутин" Так вот теперь есть аналайзер, который проверит, что у этого типа в таком случае корректная асигнатура try_parse или bind_async, или может ее вообще нет, тогда будет ворник писаться и так далее.
1265.20 1276.20 "Игорь Лабутин" Ну и вокруг реквест делега, там всякие асинки, таски, таска t проверяет тоже, что там все корректно написано и ваш реквест делегат тоже ожидаемой асинкой обладает.
1276.20 1281.88 "Игорь Лабутин" В blazor exception теперь можно диспатчить синхронизационный контекст, если вам это зачем-то надо.
1281.88 1288.32 "Игорь Лабутин" Ход reload в webassembly теперь поддерживает изменения в instance, в field, в property и в event.
1288.32 1294.72 "Игорь Лабутин" Так что если вы в webassembly все это отлаживаете, будет теперь поприкольнее, ход reload будет срабатывать.
1294.72 1301.16 "Игорь Лабутин" Удивительно, но раньше не были поддержаны символ сервера, когда мы дебажили .NET в webassembly, теперь поддержаны.
1301.16 1303.84 "Анатолий Кулаков" Какой ужас, как мы дебажили-то без этого?
1303.84 1304.84 "Игорь Лабутин" Не знаю.
1304.84 1305.84 "Игорь Лабутин" Это нужная штука.
1305.84 1313.80 "Игорь Лабутин" В webassembly можно теперь дебажить в Firefox, видимо раньше можно было только в Edge и в Chrome, вероятно.
1313.80 1315.80 "Игорь Лабутин" Ну, скорее всего в Chrome, да.
1315.80 1322.96 "Игорь Лабутин" Ну там, опять же, Edge и Chrome шарят общий движок, поэтому видимо более-менее было одинаково, в Firefox теперь можно, там же свой этот рендеринг.
1322.96 1327.52 "Игорь Лабутин" Ну да, поэтому там все равно в Chrome ничем не отличался.
1327.52 1334.64 "Игорь Лабутин" Так, теперь, да, важное изменение, которое будет видно визуально, была следующая проблема.
1334.64 1341.00 "Игорь Лабутин" Когда вы собираете ваше Blazor webassembly приложение, вы на выходе получаете, что вам правильно, .dll файлик.
1341.00 1346.68 "Игорь Лабутин" Как у нас firewallы в интернете реагируют на попытку там изоду-думлодить какой-нибудь .exe или .dll?
1346.68 1351.28 "Игорь Лабутин" Ну в общем, некоторые firewallы весьма агрессивно настроены и не дают такое делать.
1351.28 1356.28 "Игорь Лабутин" Хотя это всего лишь webassembly приложение, которому можно наверное доверять, потому что оно будет исполняться в sandbox.
1356.28 1382.20 "Игорь Лабутин" В результате, ну это на самом деле проблема, и для того чтобы ее решить, если вы ставите в ASM experimental workload и внутри project файла ставите в ASM enable web CIL, то будут генерироваться файлики с расширением .web CIL, это отдельный формат для сборок, про который firewallы в курсе, что там все хорошо.
1382.20 1386.20 "Анатолий Кулаков" Ну по факту это тот же самый webassembly код, ничем не отличается.
1386.20 1390.08 "Игорь Лабутин" Да, да, да, это тот же самый webassembly код, но вот у него со своим собственным расширением.
1390.08 1391.08 "Анатолий Кулаков" Просто с другим расширением.
1391.08 1397.96 "Игорь Лабутин" Да, да, да, но просто возможно ваш остальной туллинг будет очень удивлен, не увидев длн файлов, увидев какие-то странные.
1397.96 1404.60 "Игорь Лабутин" Поэтому, видимо поэтому не стали это делать включенным по дефолту, а пока только надо включать явно через propertune.
1404.60 1412.36 "Анатолий Кулаков" Да нет, мне кажется вообще странно поступили, что изначально сделали их для лильки, ну то есть по сути что ты от длн что-то ждешь, что ты ее запустишь и она пойдет работать.
1412.36 1416.56 "Анатолий Кулаков" В webassembly скорее всего так просто не запустишь, и так просто она работать не пойдет.
1416.56 1417.56 "Анатолий Кулаков" Ну в этом смысле.
1417.56 1419.44 "Анатолий Кулаков" И там нужен специальный рантайм и все такое.
1419.44 1425.80 "Игорь Лабутин" Да, ну надо сказать, что видеть длн когда ты собираешь приложение на макоси, например, тоже странно.
1425.80 1428.76 "Анатолий Кулаков" Да, да, и на линуксе такая же история.
1428.76 1437.48 "Игорь Лабутин" Поэтому на линуксе есть хотя бы еще so, на макоси по идее тоже so, шаритопши, по-моему там тоже самое.
1437.48 1445.84 "Игорь Лабутин" Хотя это не so в понимании, так сказать, линукс и макоси, это просто контейнер с какими-то данными, которые нужно специальной приложеникой выполнять.
1446.84 1449.52 "Игорь Лабутин" Так, что еще у нас завезли?
1449.52 1467.32 "Игорь Лабутин" А вот, если вы разрабатываете синглпейдж аппликейшены, ну то есть у вас есть какой-то фронтенд, да, у вас есть какой-то бэкэнд на спендкоре, и как правило у вас есть, это значит, что у вас может быть какой-то отдельный специальный сервер, который собственно сервит ваш фронтенд.
1467.32 1496.00 "Игорь Лабутин" Ну короче есть теперь опция, называется spa development server options keep running, которая делает следующую штуку, если вы стопите ваш спендкор процесс, чтобы например внести какие-то изменения в бэкэнд, то вот этот тот самый сервер, который сервит спа, не будет останавливаться, он короче не будет останавливаться вместе с вашим спендкорным отлаживаемым процессом, а будет продолжать работать, чтобы вы могли перезапустить спендкор процесс и продолжить дальше без необходимости поднимать что-то там.
1496.00 1502.16 "Игорь Лабутин" Я не занимаюсь спендкор девелопментом, поэтому не знаю деталей, но в общем если вы этим занимаетесь, посмотрите, может что-то полезное.
1502.16 1513.88 "Игорь Лабутин" И вот фича, которая может быть актуальна с точки зрения minimal API и native auto, как ты говоришь маленькие тузы, которые выставляют себя как веб-сервера.
1513.88 1518.72 "Игорь Лабутин" Так вот теперь Kestrel научился работать по неймпайпам.
1518.72 1535.20 "Игорь Лабутин" Kestrel теперь может выставиться как сервер неймпайпов, что я например довольно часто, не в смысле Kestrel через неймпайпы, а вообще в принципе вот это вот общение через неймпайпы я очень часто использовал, когда писал какое-то общение между процессами, которые точно работают на одной машинке.
1535.20 1544.84 "Игорь Лабутин" То есть когда мне нужно было из какого-нибудь там фронтенда типа десктопного приложения доступиться к бэкэнду типа виндовому сервису, то вот неймпайпы были прямо самое оно.
1544.84 1549.24 "Игорь Лабутин" Ну там был конечно VCF, нет пайп и погнали.
1549.24 1554.44 "Игорь Лабутин" Портов не нужно, ничего не нужно, ты генеришь свое уникальное имя неймпайпа и все работает.
1554.44 1557.84 "Игорь Лабутин" Вот теперь можно делать через Kestrel.
1557.84 1564.76 "Анатолий Кулаков" Ну да, у меня тоже такой же опыт, когда мы локально что-то делали, естественно неймпайп это самый быстрый и самый оптимальный способ.
1564.76 1574.84 "Анатолий Кулаков" Ну не знаю, я что-то в современности даже немножко сомневаюсь, а нужно ли это, пользуется ли этим кто-то, потому что это же автоматически тебя делает привязанным к винде.
1574.84 1580.00 "Игорь Лабутин" Ну во-первых, не факт, пайпы есть не только на винде.
1580.00 1590.36 "Анатолий Кулаков" Ну есть-то да, по-моему вот так вот используются и они оптимальны только на винде, потому что мне кажется на линуксе какие-то local сокеты, они намного быстрее на mid-pipe.
1590.36 1594.16 "Анатолий Кулаков" То есть там их смысла нет в таком ключе использовать.
1594.16 1595.16 "Анатолий Кулаков" Но это не точно.
1595.16 1600.88 "Игорь Лабутин" Может быть, если не точно, я действительно не помню, давно не занимался, я писал когда-то на пайпах, в том числе на линуксе, но совсем уже не помню.
1600.88 1609.32 "Игорь Лабутин" В общем надо посмотреть, будет, но по крайней мере вот кейс, когда может быть действительно это будет полезно и все это в найти фаот завести, вообще будет зашибись.
1609.32 1612.32 "Игорь Лабутин" Маленькая тулза, которая может представляться себя как маленький сервер.
1612.32 1623.00 "Игорь Лабутин" Http3 теперь включено по дефолту, http2 поверх TLS, то есть по сути https, поддержана на mac оси, этого не было.
1623.00 1631.44 "Игорь Лабутин" Фича под названием gRPC JSON transcoding, мы про нее говорили когда-то давно, которая автоматически ваши gRPC endpoints представляет в виде REST endpoints.
1631.44 1638.64 "Игорь Лабутин" Она требовала включения явного файлика в http proto и annotations proto, в ваш контракт теперь не надо, они автоматически из nougat-пакета приедут.
1638.64 1647.04 "Игорь Лабутин" В SignalARIA всякие изменения небольшие, в конфигурации можно там тайм-ауты теперь выставлять.
1647.04 1661.60 "Игорь Лабутин" А Clasp IP Network теперь умеет парсить классическую аннотацию типа сетей, типа там 10000/24, раньше нельзя было писать /24, теперь он умеет делать.
1661.60 1663.60 "Игорь Лабутин" Ну наконец-то, чередуя, затянули.
1663.60 1667.60 "Игорь Лабутин" Ну вот пользователя теперь удобнее будет, да, если что.
1667.60 1671.56 "Игорь Лабутин" И вот мы и до новых конфига в spnet.
1671.56 1679.28 "Игорь Лабутин" Раньше мы всегда, ну как, не всегда, но тем не менее для spnet приложения нужно задать urls, на которых оно будет слушать.
1679.28 1685.84 "Игорь Лабутин" Всегда это делалось через spnet_urls, по-моему это так называется переменная, spnet_core_urls.
1685.84 1691.72 "Анатолий Кулаков" Ну там есть несколько способов, через переменное окружение, через командную строку, через config file, в общем, через
1691.72 1703.56 "Игорь Лабутин" код. Да, но оно все так или иначе сваливается в тот факт, что вам нужен сеттинг под названием urls, по сути, вот, там после отрезания всех префиксов и прочего, да, то на которых он слушает.
1703.56 1712.52 "Игорь Лабутин" И на самом деле довольно много приложений, туда писало http://*9.80, ну по сути как бы, а и пишник не важен, главное порт.
1712.52 1727.96 "Игорь Лабутин" Вот, теперь у нас есть два конфига, называется http_ports и https_ports, которые можно просто использовать, указав туда через, по-моему, точку запятой, или запятую не помню, список портов, на них, собственно, будет слушаться.
1727.96 1737.40 "Игорь Лабутин" При этом, если у вас где-то указан urls старинным способом, то urls будут иметь преимущество, то есть нужно сначала читать порты, если порты эти переменные пустые, ну, то есть если задано urls, то порты игнорируются.
1737.40 1742.48 "Игорь Лабутин" В общем, такой более легкий способ, по-моему, список портов.
1742.48 1749.28 "Игорь Лабутин" Так, ну и, в общем-то, все более-менее, без таких важных и интересных вещей.
1749.28 1756.72 "Игорь Лабутин" Давай быстренько пойдем дальше, с EF-Core разберемся, у нас сегодня тем много, попытаемся не очень долго тормозить.
1756.72 1766.24 "Игорь Лабутин" Во-первых, я заметил, не знаю, было ли это в семерке, но во всей статье про EF-Core почти всегда они называют его EF-8 уже.
1766.24 1772.96 "Игорь Лабутин" То есть кажется, что вот в шестерке точно нужно было называть EF-Core-6, чтобы не путать с NTF-реймворком шестым.
1772.96 1782.80 "Игорь Лабутин" В семерке уже не так обязательно, но, видимо, по старой памяти много кто называл EF-Core-7, а в восьмерке все уже просто стали называть EF-8, ну вот, по крайней мере, то, что я вижу в статьях и в вышлих репозиториях.
1782.80 1787.88 "Анатолий Кулаков" Ну, то есть мы, скорее всего, в будущем ждем переименование,
1787.88 1794.56 "Игорь Лабутин" да? Ну, не то, чтобы переименование, то есть он, видимо, может быть и останется EF-Core, но называют его просто EF-8, вот именно в текстах.
1794.56 1795.56 "Игорь Лабутин" Не знаю, можно?
1795.56 1801.72 "Анатолий Кулаков" Опять же, чтобы не путалось, наверное, легче переименовать, как сделали с .NET, чего вы там тащите за собой.
1801.72 1805.08 "Анатолий Кулаков" Ну и заодно можно ASP.NET тоже подтянуть.
1805.08 1809.20 "Игорь Лабутин" Ну да, с другой стороны, действительно, почему бы нет.
1809.20 1815.68 "Игорь Лабутин" Ну, значит, с EF-Core примерно такая же тема, значит, основной объем статьи — это про их планы.
1815.68 1818.48 "Игорь Лабутин" Значит, планы делятся на 5 частей.
1818.48 1831.60 "Игорь Лабутин" Во-первых, первая часть называется Highly Requested Features, и там есть JSON-колонки, часть поддержки была добавлена в 7-ом EF, но там не все, и остатки поддержки будут добавлены в 8-ом, как я понимаю.
1831.60 1838.12 "Игорь Лабутин" Value-объекты — это те, которые не, ну, как бы, вложены в другие объекты, да, и по сути маппят только часть колонок-таблички.
1838.12 1844.44 "Игорь Лабутин" Их поддержка должна улучшиться, они тоже были поддержаны частично, но не все.
1844.44 1862.00 "Игорь Лабутин" И SQL queries для типов, про которые EF ничего не знает, то есть те, которые не мапятся на таблице, но тем не менее хотелось бы делать кверки, например, какие-то ad-hoc-типы, куда вы собираете какую-то очень странную комбинацию из разных таблиц, там, поджойнили что-нибудь, выбрали 4 колонки и положили в новый тип.
1862.00 1870.56 "Игорь Лабутин" Не в анонимный тип, как можно было бы сделать это раньше, да, через select, а прямо в конкретный тип с конкретными полями, ну вот, про которые EF ничего не знает.
1870.56 1875.28 "Игорь Лабутин" Это очень от них хотят, они этим будут заниматься.
1875.28 1880.08 "Игорь Лабутин" Дальше раздел под названием Cloud Native and Devices, там как раз OutM и Trimming.
1880.08 1887.08 "Игорь Лабутин" Причем там два раздела, один называется OutM Trimming для EF Core, а второй почему-то то же самое, только для Adonet.
1887.08 1890.04 "Игорь Лабутин" То есть команда EF Core занимается еще немножко Adonet.
1890.04 1892.28 "Игорь Лабутин" Ну, наверное, это важно.
1892.28 1893.28 "Игорь Лабутин" Performance.
1893.28 1895.72 "Анатолий Кулаков" Ну, кому это заниматься, не SPNL же команде?
1895.72 1900.32 "Игорь Лабутин" Ну, там есть отдельные команды, которые занимаются всякими SQL Server драйверами.
1900.32 1902.08 "Игорь Лабутин" Вот как раз следующий пункт про Performance.
1902.08 1908.76 "Игорь Лабутин" У EF Core тема такая, что они сейчас продвигают, есть такой репозитор, по-моему, это репозитор, прям отдельный, называется Woodstar.
1908.76 1913.36 "Игорь Лабутин" Это, короче, полностью менеджовая библиотека для доступа к SQL Server.
1913.36 1931.28 "Игорь Лабутин" И они прямо-прямо говорят, что да, это, короче, fast, она, короче, очень менедж, все такое, но вот стандартный этот систем, да, так как он зовутся SQL Server Client, короче, который обычный, он никуда не девается, он будет развиваться, то же самое, но он типа не менедж, он, значит, использует эти библиотечки от SQL Server.
1931.28 1938.96 "Игорь Лабутин" Ну вот тоже как-то странно, чтобы EF Core команда занималась, значит, проектом по доступу конкретно к SQL Server, ну, видимо.
1938.96 1942.96 "Игорь Лабутин" Может, отажуру надо очень сильно, непонятно.
1942.96 1951.00 "Игорь Лабутин" Вижу Tooling, T4, помните, они в прошлый раз, в прошлом релизе добавили T4-темплейты для scaffolding'а, можно было редактировать.
1951.00 1966.16 "Игорь Лабутин" В общем, они хотят эту штуку расширить побольше, T4-темплейтов, и получше experience, если вы работаете с database-first подходом, то там они хотят что-то улучшить в поддержке, опять же, Tooling'а от Visual Studio и Tool'ов вокруг.
1966.16 1973.88 "Игорь Лабутин" Ну и последний раздел, он называется Developer Experience, мне очень понравился, там есть единственный пункт, и он называется Make EF Core Better.
1973.88 1979.40 "Анатолий Кулаков" Неплохо, а до этого они что делали, пытались его испортить, сделать медленнее, я не знаю.
1979.40 1988.04 "Игорь Лабутин" Я причем прочитал те три абзаца, которые там написаны потом, я так и не понял, что они хотят сделать better, там дальше переведен список ищусов на, по-моему, 60 штук.
1988.04 1996.20 "Игорь Лабутин" Видимо, фикс этих ищусов и заключается в том, чтобы сделать его better, но мне кажется, фикс любых ищусов сделает better, как бы, лишь бы новых багов не поладили.
1996.20 2002.00 "Игорь Лабутин" Так что хотят тоже, могут быть и ищусы, которые ухудшают, почему нет.
2002.00 2006.84 "Анатолий Кулаков" Настолько ничего в анонсе писать, что они просто перечисляют, что будем закрывать ищусы?
2006.84 2010.80 "Игорь Лабутин" Погоди, мы найдем других анонсов, там будет еще интереснее.
2010.80 2011.80 "Игорь Лабутин" Ладно.
2011.80 2016.20 "Игорь Лабутин" При этом в превью 1 завезли некоторое количество прям нововведений.
2016.20 2041.36 "Игорь Лабутин" Для Unmapped типов, то что я говорил, что это одна из highly requested features, в седьмом entity framework можно было исполнять запросы, у которых возвращаются скалярные типы, теперь можно использовать любой тип, который является, ну, то что называется mappable, то есть тот, который, ну, хоть как-то маппится, сейчас, тот, у которого field или property маппятся на SQL типы.
2041.36 2048.88 "Игорь Лабутин" То есть понятно, что если вы туда завезете какой-то там динамик или там что-то очень свое кастомное, то не получится.
2048.88 2070.08 "Игорь Лабутин" Но если там просто у вас обычный тип с какими-то стрингами, интами, date/time и прочим, то теперь вы можете написать кверку и выполнить ее через SQL query или SQL query raw, это два метода, которые позволяют исполнять, собственно, все эти методы и в результате получить результат, проецировать в тип, про который EF, в общем-то, ничего не знает, оно само разберется.
2070.08 2087.24 "Игорь Лабутин" И вторая штука, которая появилась, ну да, вторая штука, которая появилась, это lazy loading для query, который не non-tracking, то есть вы делаете as no-tracking, но при этом у вас будет срабатывать lazy loading.
2087.24 2105.96 "Игорь Лабутин" Там есть тонкости, как это взаимодействует с db-контекстом, нужно, в принципе, поскольку вы делаете as no-tracking, может показаться, что как только вы закончили, ну, в смысле, вызвали этот запрос и он у вас материализовался в память, можно db-контекст использовать, потому что, ну он же не трек, он не трек, блин, на query, зачем вам db-контекст?
2105.96 2113.44 "Игорь Лабутин" Но вот если вы используете lazy load при этом, то там db-контекст становится важным, и поэтому внимательно почитайте описание этой фичи.
2113.44 2127.96 "Игорь Лабутин" Ну и если вы работаете с SQL-сервером, добавили поддержку типа в data-only и time-only, мы обсуждали, что в EF7 она была поддержана в Postgres, в MySQL, в SQLite, по-моему, могу ошибаться с SQLite, а вот SQL-сервера не было, ну вот наконец-таки сделали в Preview 1.
2127.96 2138.72 "Игорь Лабутин" Вот примерно такие дела у нас в DotNet 8 Preview 1, много чего нового, много планов, мы еще вернемся немножко к планам, но давай сначала отвлечемся на что-нибудь другое.
2138.72 2177.00 "Анатолий Кулаков" Давай разомнемся, небольшой теорий, у меня есть прекрасная статья про криптографию в Дотнете, и мне кажется это очень важная тема, поэтому хотелось бы ее в выпуске поднять, потому что многие разработчики не хотят туда лезть, думая, что криптография это сложно, секьюрити это сложно, и там какие-то страшные алгоритмы, и умные очекокастые дядьки только все это пилят, но на самом деле криптография имеет одну интересную особенность, что если вы изучите там хотя бы 20% основных концепций, то вы будете понимать 80% всех особенностей, которые вам нужны в повседневной работе.
2177.00 2194.16 "Анатолий Кулаков" И вот как раз данная статья мне попалась, которая рассказывает про вот эти основные концепции, которые есть в криптографии, и мне кажется, если мы сейчас с вами пройдем их, то вы больше никогда не будете бояться ничего, что связано с криптографией, и вполне уверенно будете держаться на плаву, что бы там ни случилось.
2194.16 2201.44 "Анатолий Кулаков" И поэтому давайте немножко поговорим про криптографию как таковую и в Дотнете в частности.
2201.44 2225.32 "Анатолий Кулаков" Прежде всего криптография это очень важное, это сейчас можно сказать база современной безопасности, она позволяет нам держать данные и держать коммуникацию, то есть каналы связи какие-нибудь, способы обмена информацией немножко защищенными, то есть скрытыми от того, что бы их можно мог прочитать какой-нибудь злоумышленник или стащить или еще что-то сделать.
2225.32 2240.16 "Анатолий Кулаков" И поэтому вся криптография нацелена на то, что бы изучать, разрабатывать и применять на практике в нашем случае математические алгоритмы, которые позволяют защищать данные или коммуникацию от какого-нибудь легкого чтения.
2240.16 2252.44 "Анатолий Кулаков" То есть есть конечно прецеденты, когда это все ломается, читается, но просто так элементарно, легко, обычно криптография защищает от таких простых легких чтений.
2252.44 2261.36 "Анатолий Кулаков" В Дотнете вся криптография сосредоточена, по крайней мере, все высокоуровневая криптография сосредоточена в пространстве имен систем секьюрити криптографии.
2261.36 2268.92 "Анатолий Кулаков" В общем там можно найти всевозможные алгоритмы, различные векторы инициализации, фабрики по созданию.
2268.92 2274.76 "Анатолий Кулаков" В общем, как таковые классы там не представляют собой ничего такого интересного.
2274.76 2282.80 "Анатолий Кулаков" Любое шифрование или расшифрование делается в 5 строчек стандартных, плюс какие-то настройки вам нужно знать.
2282.80 2290.32 "Анатолий Кулаков" Самое главное это как раз таки знать, а что нужно делать и какие типы криптографии применяются и какие они вообще существуют.
2290.32 2294.88 "Анатолий Кулаков" Вот поэтому давайте сейчас вот этими аспектами и озаботимся.
2294.88 2306.92 "Анатолий Кулаков" Прежде всего мы рассмотрим самые три основных подхода криптографии и первой большой зоной для этого у нас будет хэш функции и в частности криптографические хэш функции.
2306.92 2309.00 "Анатолий Кулаков" Так, что же это такое?
2309.00 2319.88 "Анатолий Кулаков" Это такая функция, которая преобразовывает, однонаправленно преобразовывает некие данные в какой-то хэш в итоге на выходе.
2319.88 2331.88 "Анатолий Кулаков" Прелесть этой функции заключается в том, что какие бы данные вы ей на вход не дали, какого бы размера вы их туда не засунули, на выходе вы всегда получите фиксированный размер хэша.
2331.88 2340.68 "Анатолий Кулаков" Этот фиксированный размер, он обычно намного меньше, чем сами данные и обладает он очень интересным и прекрасным свойством.
2340.68 2341.68 "Анатолий Кулаков" Он необратимый.
2341.68 2348.76 "Анатолий Кулаков" То есть, имея вот этот фиксированный хэш, вы никогда не сможете понять, какие данные были изначально.
2348.76 2354.18 "Анатолий Кулаков" То есть, грубо говоря, разжать вам их не получится.
2354.18 2357.08 "Анатолий Кулаков" Сжать элементарно, а вот разжать никак.
2357.08 2372.36 "Анатолий Кулаков" И свойства того, что у нас всегда получается понятно фиксированный хэш сумма и то, что он необратимый, это эти свойства дают нам интересную возможность, то что мы можем проверять некие данные на корректность, на валидность.
2372.36 2379.20 "Анатолий Кулаков" То есть, проверив их хэш, мы вполне можем понимать, что это одни и те же данные и при этом не раскрывая сами эти данные.
2379.20 2381.64 "Анатолий Кулаков" То есть, сами данные могут не передаваться.
2381.64 2387.72 "Анатолий Кулаков" Достаточно только иметь тот факт, что они те, на которые мы рассчитываем.
2387.72 2389.32 "Анатолий Кулаков" То есть, они не повреждены.
2389.32 2404.72 "Анатолий Кулаков" Также хэш-функции, они обычно обладают алгоритмом, который позволяет приводить нам, получая на входе одни и те же результаты, выдавать все время один и тот же хэш.
2404.72 2407.20 "Анатолий Кулаков" Что, соответственно, логично.
2407.20 2415.20 "Анатолий Кулаков" И теоретически не существует таких двух разных входов, которые дадут нам один и тот же хэш.
2415.20 2417.72 "Анатолий Кулаков" Этот, конечно, только теоретически.
2417.72 2422.76 "Анатолий Кулаков" Но на практике иногда разные входы могут давать одинаковый хэш.
2422.76 2425.20 "Анатолий Кулаков" И этот случай называется коллизией.
2425.20 2426.20 "Анатолий Кулаков" Коллизией хэш-функций.
2426.20 2428.20 "Анатолий Кулаков" Может быть, вы даже о таких терминах уже слышали.
2428.20 2433.84 "Анатолий Кулаков" И это логично, потому что у нас фиксированный размер хэша всегда.
2433.84 2440.76 "Анатолий Кулаков" То есть, этот размер хэша всегда меньше, чем те огромные файлы, в которых мы их засовываем.
2440.76 2451.80 "Анатолий Кулаков" А раз они всегда меньше, значит, мы всегда знаем, что могут быть такие коллизии, когда два разных алпута дадут в итоге один и тот же хэш.
2451.80 2455.96 "Анатолий Кулаков" То есть, таких коллизий в теории могут существовать.
2455.96 2457.16 "Анатолий Кулаков" Они могут появляться.
2457.16 2467.84 "Анатолий Кулаков" Но в данном случае, в подходе к рептографических функциям, мы считаем, что каждая такая коллизия – это больше исключения, чем правила.
2467.84 2474.36 "Анатолий Кулаков" И в повседневной жизни получить такие коллизии существует очень-очень малая вероятность.
2474.36 2481.68 "Анатолий Кулаков" Чтобы их не получать, чтобы получить как можно меньше коллизий, прежде всего есть несколько рекомендаций.
2481.68 2484.60 "Анатолий Кулаков" Во-первых, используйте не задеприкеченные алгоритмы.
2484.60 2492.12 "Анатолий Кулаков" То есть, новые, они всегда совершенствуются, часто обновляются, поэтому следите и используйте самые последние актуальные.
2492.12 2498.12 "Анатолий Кулаков" И алгоритмы, которые не подвержены криптографическому взлому.
2498.12 2505.12 "Анатолий Кулаков" Тоже интересная такая терминология, потому что не очень понятно, каким образом может быть взломан алгоритм.
2505.12 2508.92 "Анатолий Кулаков" В общем, такая возможность есть.
2508.92 2528.60 "Анатолий Кулаков" Взлом алгоритма называют некую последовательность или символов, или некие способы перебора, которые позволяют обойти всю сложность алгоритма хэширования и сделать, может быть перебрать с более быстрой скоростью, или может быть сделать специальные коллизии.
2528.60 2532.92 "Анатолий Кулаков" То есть, подобрать очень легко коллизии какому-то уже известному хэшу.
2532.92 2536.32 "Анатолий Кулаков" Таким образом, якобы ломают эти алгоритмы.
2536.32 2544.28 "Анатолий Кулаков" Естественно, сам алгоритм никак не ломается, но вот различные подходы его использования с разных сторон, с точки зрения обнаружения коллизий, в общем, они существуют.
2544.28 2551.04 "Анатолий Кулаков" И, как я уже сказал, вероятность все-таки коллизий настоящих криптовстоких алгоритмов, они очень-очень малы.
2551.04 2561.76 "Анатолий Кулаков" Например, SHA-256 алгоритм дает шанс коллизий 4 в 3, и в 10 в -60 степени.
2561.76 2563.68 "Анатолий Кулаков" То есть, это очень-очень мало.
2563.68 2566.56 "Анатолий Кулаков" Гораздо вероятнее, скорее всего, что у вас гуиды совпадут.
2566.56 2574.04 "Анатолий Кулаков" Так, теперь рассмотрим, а как же можно применять хэш-функции.
2574.04 2580.64 "Анатолий Кулаков" На самом деле, хэш-функции применяются в огромном числе всяких сфер, алгоритмов.
2580.64 2586.84 "Анатолий Кулаков" Самый элементарный, думаю, с которым каждый из вас мог сталкиваться, это хэширование паролей.
2586.84 2598.08 "Анатолий Кулаков" Нормальные пацаны никогда не хранят пароли в открытом виде в базе данных, потому что всегда есть какой-то шанс, что база данных будет украдена, и тогда злоумышленник получит прямой доступ ко всем паролям.
2598.08 2600.12 "Анатолий Кулаков" Ну и это абсолютно бессмысленно.
2600.12 2604.88 "Анатолий Кулаков" Поэтому обычно где-нибудь в базах хранятся хэшированные пароли.
2604.88 2610.28 "Анатолий Кулаков" Хэшированные по сложным алгоритмам, по сложным стратегиям, которые мы, может быть, с вами еще дальше обсудим.
2610.28 2613.88 "Анатолий Кулаков" В общем, нам хранится хэш, из которого настоящий пароль получить абсолютно невозможно.
2613.88 2621.36 "Анатолий Кулаков" И для того, чтобы пользователю пустить систему, нам, опять же, не нужно открытого пароля.
2621.36 2627.28 "Анатолий Кулаков" Нам достаточно посчитать хэш из того пароля, который он ввел, и сравнить с тем, который хранится у нас в базе данных по определенному алгоритму.
2627.28 2633.72 "Анатолий Кулаков" Поэтому хэширование паролей - это самая первая вещь, где используются криптостойкие хэш-функции.
2633.72 2638.64 "Анатолий Кулаков" Дальше очень частая штука - это проверка целостности файла.
2638.64 2649.60 "Анатолий Кулаков" Наверное, тоже в интернете, если вы что-то скачивали, допустим, те же самые дистрибутивы .NET или Visual Studio или еще что-то, обычно рядом с дистрибутивом пишут хэш этого файла.
2649.60 2662.36 "Анатолий Кулаков" Это нужно для того, чтобы после скачивания какого-то образа или инсталлятора вы могли посчитать у себя на локальном компьютере хэш этого файла и сравнить с тем, что вы видите на сайте.
2662.36 2669.64 "Анатолий Кулаков" Как я уже говорил, при одинаковом входе хэш-функции дают обычно одинаковый выход, то есть одинаковый хэш-суммар.
2669.64 2680.96 "Анатолий Кулаков" И поэтому вы легко можете узнать, был ли этот файл изменен по пути, или, например, заражен вирусом, или подменен провайдером, или скачен случайно не из того ресурса, из которого хотелось бы скачать.
2680.96 2696.08 "Анатолий Кулаков" Этот подход очень популярен, например, когда у нас есть распределенные системы для скачивания, когда официальный сайт, допустим, официальная компания может выдавать только хэш, а предлагать дистрибутив скачивать откуда угодно, из торрентов.
2696.08 2702.04 "Анатолий Кулаков" Естественно, в торрентах кто угодно может этот файлик подменить или каким-то образом заразить его каким-нибудь страшным вирусом.
2702.04 2712.96 "Анатолий Кулаков" И если вы вдруг придете, скачаете такой файлик и сверите хэш-сумму с официального сайта, который можно хэш-сумму хостить намного легче, чем сам файлик и раздавать по всему миру.
2712.96 2720.44 "Анатолий Кулаков" Вот вы можете легко определить, нормальный этот файлик или уже кем-то изменен.
2720.44 2723.28 "Анатолий Кулаков" Давайте же теперь рассмотрим, какие есть хэш-алгоритмы.
2723.28 2729.96 "Анатолий Кулаков" Прежде всего, наверное, самый популярный, у всех на слуху, ну может быть был у всех на слуху, это MD5 - Message Digest алгоритм.
2729.96 2741.56 "Анатолий Кулаков" Это самый широко используемый алгоритм и, наверное, многие из вас слышали, что MD5 больше использовать нельзя.
2741.56 2745.44 "Анатолий Кулаков" Это как раз-таки пример того алгоритма, который был криптографически взломан.
2745.44 2753.56 "Анатолий Кулаков" То есть, его можно каким-то образом использовать для того, чтобы скомпрометировать данные или быстро найти корризию.
2753.56 2767.04 "Анатолий Кулаков" И поэтому любой анализатор, который только вы подключите в свой проект, security анализатор, и который увидит там строчка MD5, сразу начинает орать как не в себя, что бросайте, не используйте, не делайте так, не трогайте его.
2767.04 2769.56 "Анатолий Кулаков" На самом деле, это правда только наполовину.
2769.56 2775.40 "Анатолий Кулаков" То есть, действительно, в целях криптографии и какого-нибудь хеширования криптостойкого использовать MD5 нельзя.
2775.40 2777.32 "Анатолий Кулаков" Притом, нельзя уже очень-очень давно.
2777.32 2784.56 "Анатолий Кулаков" И MD5 уже практически весь период подобран.
2784.56 2791.16 "Анатолий Кулаков" То есть, существуют радужные таблицы, которые помогают, позволяют вам восстановить по хэшу изначальную строчку.
2791.16 2807.00 "Анатолий Кулаков" Как я уже говорил, что по хэшу, по идее, нельзя восстановить изначальные строчки, но если мы вдруг представим, что у нас существует некая база данных, где абсолютно ко всем строчкам в мире подобраны их хэши, тогда это конечно с помощью обычного лукапа сделать возможно.
2807.00 2814.12 "Анатолий Кулаков" И такие хэши на самом деле сделать для больших серьезных алгоритмов очень-очень сложно.
2814.12 2827.00 "Анатолий Кулаков" Но так как MD5 довольно старый, у него есть специальные подходы, как его, этот алгоритм использовать не настолько дорого, то есть быстро сгенерить эти хэши.
2827.00 2834.00 "Анатолий Кулаков" Плюс он уже оптимизирован на железе, на достаточно многих процессорах и видеокартах.
2834.00 2836.76 "Анатолий Кулаков" Поэтому обычно MD5 считается прямо на железке.
2836.76 2842.16 "Анатолий Кулаков" В общем, такие радужные таблицы уже давно созданы, уже они есть в интернете и давно всем успешно используются.
2842.16 2845.56 "Анатолий Кулаков" Поэтому в этом плане MD5 действительно небезопасен и использовать нельзя.
2845.56 2850.96 "Анатолий Кулаков" Но он по-прежнему может использоваться для проверки целостности файла.
2850.96 2862.84 "Анатолий Кулаков" То есть если вы просто хотите проверить огромный файл, считать у него чек суммы, отправить ее там на посетив на другой сервер и чтобы он тоже проверил эту чек сумму, MD5 это идеальный алгоритм.
2862.84 2867.20 "Анатолий Кулаков" Идеален он потому, что он оптимизирован практически везде.
2867.20 2873.12 "Анатолий Кулаков" Как я уже сказал, практически любая железка любого года выпуска поддерживает мега-быстрый MD5.
2873.12 2882.60 "Анатолий Кулаков" И у меня были случаи, когда были огромные файлы и нужно было очень быстро считать хэш сумму и мне абсолютно была не нужна какая-то криптостойкость, еще что-то.
2882.60 2887.68 "Анатолий Кулаков" И MD5 это был мой первый выбор и он достаточно хорош.
2887.68 2891.84 "Анатолий Кулаков" То есть чтобы вы понимали насчет коллизий, хэшей.
2891.84 2897.32 "Анатолий Кулаков" Хэши коллизий конечно подобрать можно, если специально сесть и очень сильно-сильно постараться.
2897.32 2901.40 "Анатолий Кулаков" Но случайно эти коллизии практически нереально получить.
2901.40 2903.72 "Анатолий Кулаков" То есть это что-то из ряда фантастики.
2903.72 2908.00 "Анатолий Кулаков" Поэтому MD5 все еще хорош для того, чтобы проверять целостность файлов.
2908.00 2915.24 "Анатолий Кулаков" И естественно он требует намного меньше вычислительных ресурсов, чем те алгоритмы, которыми надо пользоваться.
2915.24 2923.48 "Анатолий Кулаков" А вот если вам нужно пользоваться нормальными криптостойкими хэш функциями, вам на помощь приходит семейство SHA - Security Hashing Algorithm.
2923.48 2928.44 "Анатолий Кулаков" Начинался он с SHA1, который уже безумно устарел.
2928.44 2934.48 "Анатолий Кулаков" Продолжался он с помощью SHA2, это сейчас самый популярный алгоритм хэш функции.
2934.48 2938.84 "Анатолий Кулаков" Но все же тоже не рекомендуемый к использованию, потому что сейчас уже есть SHA3.
2938.84 2942.12 "Анатолий Кулаков" Это последняя текущая версия, которая рекомендуется.
2942.12 2947.84 "Анатолий Кулаков" И именно ее надо брать, если вы вдруг хотите почему-то использовать такую штуку.
2947.84 2954.68 "Анатолий Кулаков" На самом деле, как я уже сказал, рекомендуется использовать SHA3, но в большинстве алгоритмов используется SHA2.
2954.68 2961.64 "Анатолий Кулаков" По той причине, что адаптация новых алгоритмов происходит довольно медленно.
2961.64 2969.72 "Анатолий Кулаков" По сути, вам нужно будет переписать все ваши библиотеки, переписать какие-то алгоритмы, при том это нужно сделать не на одной стороне, а на нескольких.
2969.72 2976.00 "Анатолий Кулаков" В общем, адаптация - это сложная штука, и именно поэтому самая популярная версия - это сейчас не самая безопасная.
2976.00 2984.52 "Анатолий Кулаков" Ну и другой неприятный факт с SHA3 - это то, что он сейчас на данный момент недоступен для дотнет платформы.
2984.52 2992.20 "Анатолий Кулаков" Все они как-то там не заимплементируют, не договорятся по лицензиям, не внедрят в винду и прочие у них отговорки, потому что идут уже много-много лет.
2992.20 2997.16 "Анатолий Кулаков" Поэтому из коробки вы его не получите, но естественно можно поставить какую-нибудь дополнительную библиотечку.
2997.16 3006.56 "Анатолий Кулаков" Еще один интересный алгоритм, который стоит упомянуть в разделе к хэширующих функций - это HMAC.
3006.56 3012.48 "Анатолий Кулаков" Это хэширующая функция, которая требует для создания кэша специальный ключ.
3012.48 3028.00 "Анатолий Кулаков" И соответственно, если вы смогли с помощью этого ключа посчитать тот же самый хэш, вы можете теперь утверждать не только то, что эти данные не повреждены, но и то, что эти данные были прохэшированы специальным ключом.
3028.00 3038.16 "Анатолий Кулаков" То есть по сути вы можете сделать авторизацию, вы можете понять, а кто именно, кому принадлежит этот ключ, с помощью которого был посчитан этот хэш-код.
3038.16 3044.08 "Анатолий Кулаков" Это тоже очень популярная стратегия, которая часто используется в различных алгоритмах.
3044.08 3049.92 "Анатолий Кулаков" Закончились с хэш-функциями, надеюсь вам было примерно понятно для чего используется хэш-функция, какими свойствами обладает.
3049.92 3054.20 "Анатолий Кулаков" Теперь перейдем непосредственно к самой шифрованию и дешифрованию.
3054.20 3058.20 "Анатолий Кулаков" Естественно какая же криптография может быть без шифрования и дешифрования.
3058.20 3062.68 "Анатолий Кулаков" Самым примитивным способом шифрования является симметричное шифрование.
3062.68 3068.68 "Анатолий Кулаков" Симметричное шифрование, да как и в принципе любое шифрование, нацелено на то, чтобы скрыть данные.
3068.68 3078.36 "Анатолий Кулаков" Но не просто скрыть, а чтобы можно было в скрытом виде передать и на другой стороне, в отличие от хэш-функций, декриптовать, расшифровать их.
3078.36 3081.56 "Анатолий Кулаков" То есть иметь возможность их так же точно раскрыть.
3081.56 3084.12 "Анатолий Кулаков" У нас есть два основных подхода к шифрованию.
3084.12 3086.52 "Анатолий Кулаков" Это симметричное и асимметричное шифрование.
3086.52 3088.96 "Анатолий Кулаков" Сейчас мы поговорим с вами о симметричном.
3088.96 3098.08 "Анатолий Кулаков" Итак, симметричное - это специальный класс математических алгоритмов, который шифрует ваши данные с помощью специального ключа.
3098.08 3101.76 "Анатолий Кулаков" И он может дешифровать ваши данные с помощью того же самого ключа.
3101.76 3110.12 "Анатолий Кулаков" То есть, если вы хотите, например, между двумя серверами обмениваться какой-то шифрованной информацией, перед вами стоит большая дилемма.
3110.12 3112.24 "Анатолий Кулаков" Как передать вот этот секретный ключ?
3112.24 3121.60 "Анатолий Кулаков" Потому что если у вас посередине будет какой-то злоумышленник, который этот ключ у вас стащит, то в принципе все ваше шифрование сразу можно отменять, оно будет бесполезным.
3121.60 3127.12 "Анатолий Кулаков" Потому что дешифровать эти данные может любой человек, у которого есть тот же ключ, которым вы шифровали.
3127.12 3134.24 "Анатолий Кулаков" Из-за вот этого свойства, что нам нужен всего лишь навсего один ключ, этот подход еще часто называют шифрование с помощью приватного ключа.
3134.24 3143.32 "Анатолий Кулаков" Я думаю, что когда все изучают шифрование, то первым делом они сталкиваются с симметричным шифрованием.
3143.32 3155.16 "Анатолий Кулаков" Допустим, многим известен шифр Цезаря, где мы просто-напросто сдвигаем буквы на какую-то определенную позицию и таким образом проходимся по всем остальным буквам.
3155.16 3157.64 "Анатолий Кулаков" Это, кстати, типичный пример симметричного шифрования.
3157.64 3174.60 "Анатолий Кулаков" Или, например, когда мы ксорим какое-нибудь число или какой-нибудь текст, ксорим на специальный ключ, это тоже пример симметричного шифрования, который элементарно восстанавливается, если мы знаем тот ключ, с помощью которого мы ксорим.
3174.60 3184.40 "Анатолий Кулаков" Есть очень интересные способы взлома симметричных шифров, но они немножко уходят сейчас за нашу дискуссию.
3184.40 3190.04 "Анатолий Кулаков" Поэтому просто вам нужно запомнить, что симметричное шифрование там, где ключ всего один.
3190.04 3193.64 "Анатолий Кулаков" С помощью него и шифруются, и расшифровываются данные.
3193.64 3201.68 "Анатолий Кулаков" Казалось бы, что это довольно много минусов у этого подхода, это довольно плохой подход, но на самом деле у него есть огромные преимущества, огромный плюс.
3201.68 3210.76 "Анатолий Кулаков" Он очень быстр, он работает с огромными массивами данных, делает это очень быстро и очень бережно относится к памяти.
3210.76 3216.32 "Анатолий Кулаков" В отличии от второго типа, от асимметричного, о котором мы поговорим немножко подальше.
3216.32 3220.24 "Анатолий Кулаков" Итак, какие же здесь есть уже стандартные математические алгоритмы?
3220.24 3223.24 "Анатолий Кулаков" Во-первых, это IES.
3223.24 3229.80 "Анатолий Кулаков" IES - это сейчас наиболее популярный симметричный алгоритм шифрования.
3229.80 3246.88 "Анатолий Кулаков" Он очень быстрый, он позволяет обрабатывать данные любого размера и основные его фишки заключаются в том, что у него размер блока 128 бит и он может использовать размеры ключей 128, 192 и 256 бит.
3246.88 3258.52 "Анатолий Кулаков" Чем больше размер ключа, тем сложнее будет теоретически расшифровать этот блок и тем более стойкий будет ваш шифр.
3258.52 3263.96 "Анатолий Кулаков" Также вы можете столкнуться с алгоритмами DES и Triple DES.
3263.96 3266.36 "Анатолий Кулаков" Это Data Encryption Standard расшифровывается.
3266.36 3277.40 "Анатолий Кулаков" Это тоже симметричные алгоритмы шифрования, они еще были до IES и на данный момент считаются устаревшими, поэтому использовать вам их скорее всего не придется.
3277.40 3282.32 "Анатолий Кулаков" Triple DES интересен тем, что он просто берет DES и три раза накладывает его на текст.
3282.32 3285.16 "Анатолий Кулаков" Вот так получается новый алгоритм шифрования.
3285.16 3295.20 "Анатолий Кулаков" То есть на практике он вам практически не нужен и вот проблема, из-за которой он практически не используется, это то, что его ключ как раз таки это 56 бит.
3295.20 3302.60 "Анатолий Кулаков" Очень маленький по мерам современных криптостойких взломователях алгоритмов, поэтому скорее всего он вам не пригодится.
3302.60 3311.68 "Анатолий Кулаков" Итак, если мы знаем все проблемы асимметричного шифрования, в том, что там есть ключ, который непонятно как передавать.
3311.68 3314.88 "Анатолий Кулаков" Все эти проблемы решает асимметричное шифрование.
3314.88 3321.28 "Анатолий Кулаков" А асимметричное шифрование это точно такой же математический метод шифрования, который обладает интересными свойствами.
3321.28 3333.12 "Анатолий Кулаков" Он зашифровывает данные с помощью одного ключа, который называется public key, то есть публичный ключ, а дешифрует их с помощью приватного ключа, который называется private key.
3333.12 3338.56 "Анатолий Кулаков" И приватный и публичный ключ они с собой математически связаны.
3338.56 3346.60 "Анатолий Кулаков" Это обозначает, что приватный ключ может расшифровать только те данные, которые были зашифрованы связанным публичным ключом.
3346.60 3350.00 "Анатолий Кулаков" То есть это не какой-то рандомный приватный и публичный ключ.
3350.00 3356.96 "Анатолий Кулаков" Это ключи, которые генерировались вместе, которые грубо говоря знают друг про друга и могут работать только в паре.
3356.96 3364.72 "Анатолий Кулаков" Также этот алгоритм из-за данного свойства называется алгоритм изшифрования публичным ключом.
3364.72 3372.52 "Анатолий Кулаков" Он намного медленнее, чем симметричное шифрование, то есть асимметричный этот намного медленнее.
3372.52 3384.92 "Анатолий Кулаков" И он редко используется для больших массивов данных, потому что как раз таки из-за своей прожорливости по памяти и по скорости, и по вычислительной сложности.
3384.92 3388.44 "Анатолий Кулаков" Но у него есть куча преимуществ.
3388.44 3392.68 "Анатолий Кулаков" Как я уже сказал, публичный ключ, он не зря называется публичный.
3392.68 3396.80 "Анатолий Кулаков" Вся его прелесть в том, что его можно расшарить абсолютно с кем угодно.
3396.80 3405.72 "Анатолий Кулаков" Вы без всякого зазрения совести публичный ключ раздаете всем подряд, публикуете на сайте, паблишите в твиттере и где угодно.
3405.72 3412.80 "Анатолий Кулаков" И с помощью этого публичного ключа другие пользователи системы могут зашифровать некие данные.
3412.80 3417.24 "Анатолий Кулаков" А вот вторая часть, приватный ключ, это самый главный секрет.
3417.24 3419.36 "Анатолий Кулаков" Вот его ни в коем случае нельзя никому отдавать.
3419.36 3423.04 "Анатолий Кулаков" Именно с помощью него можно расшифровывать все данные.
3423.04 3427.64 "Анатолий Кулаков" Таким образом мы можем создать, например, доверенное соединение.
3427.64 3436.92 "Анатолий Кулаков" Потому что нам теперь для того, чтобы два компьютера общались по зашифрованному каналу, нам уже не нужно передавать некий секретный ключ, который может перехватить злоумышленник.
3436.92 3437.92 "Анатолий Кулаков" Нет.
3437.92 3442.80 "Анатолий Кулаков" Это публичный ключ, который и так все знают, который мы можем злоумышленнику безбоязненно рассказать.
3442.80 3448.36 "Анатолий Кулаков" И с помощью этого публичного ключа обратная сторона может зашифровать нам любые данные.
3448.36 3451.68 "Анатолий Кулаков" Но злоумышленник, зная публичный ключ, никогда их не расшифрует.
3451.68 3457.84 "Анатолий Кулаков" А вот приватный ключ, который есть только у нас, мы будем использовать для расшифровки всех передных данных.
3457.84 3461.36 "Анатолий Кулаков" Именно по подобному способу работает, например, VPN.
3461.36 3470.24 "Анатолий Кулаков" Когда мы устанавливаем доверенное соединение, то есть зашифрованное соединение, которое не может быть никем прослушано, внутри недоверенного окружения, то есть интернет.
3470.24 3474.52 "Анатолий Кулаков" Интернет там сидит куча злобных хацкеров, которые только мечтают стырить ваши пароли.
3474.52 3480.80 "Анатолий Кулаков" Но нам это не мешает, потому что вся информация ходит зашифрованная и ключи для шифрования никуда не передаются.
3480.80 3484.80 "Анатолий Кулаков" Поэтому все довольно-таки в безопасности.
3484.80 3493.56 "Анатолий Кулаков" Таким образом, каждый, кто угодно, зная публичный ключ, может зашифровать ваши данные и только владелец приватного ключа может их дешифровать.
3493.56 3498.08 "Анатолий Кулаков" Данный подход, данный способ дает еще один интересный сайд-эффект.
3498.08 3500.00 "Анатолий Кулаков" Заключается он в подписи.
3500.00 3503.80 "Анатолий Кулаков" То есть мы можем приватным ключом подписать сообщение.
3503.80 3506.44 "Анатолий Кулаков" Это значит, что само сообщение может быть открытое.
3506.44 3509.68 "Анатолий Кулаков" Какая-нибудь декларация или какое-нибудь письмо.
3509.68 3513.72 "Анатолий Кулаков" Оно вполне может быть открытое и его прочитать может быть кто угодно.
3513.72 3517.88 "Анатолий Кулаков" Но мы можем поставить там криптографическую подпись с помощью нашего приватного ключа.
3517.88 3526.40 "Анатолий Кулаков" И публичный ключ, то есть все те клиенты, которые обладают публичным ключом, они могут проверить достоверность этой подписи.
3526.40 3532.24 "Анатолий Кулаков" То есть никто не может это письмо подделать и в тот же самый момент подделать эту подпись.
3532.24 3537.52 "Анатолий Кулаков" То есть каждый, у кого есть публичный ключ, они могут проверить то, что эта подпись валиная.
3537.52 3541.40 "Анатолий Кулаков" Ее поставили именно тем приватным ключом, на который мы рассчитываем.
3541.40 3550.44 "Анатолий Кулаков" На этой основе, как вы наверное догадались, и работает электронная подпись.
3550.44 3553.60 "Анатолий Кулаков" А это цифровая подпись.
3553.60 3556.72 "Анатолий Кулаков" Естественно подписать ее можно только приватным ключом, а проверить публичным.
3556.72 3559.16 "Анатолий Кулаков" И никто без приватного ключа ее воссоздать не может.
3559.16 3567.68 "Анатолий Кулаков" Другой интересный стандарт, нет, это был стандарт асимметричного шифрования.
3567.68 3568.68 "Анатолий Кулаков" Вот, про алгоритмы.
3568.68 3572.08 "Анатолий Кулаков" Давайте поговорим, какие же здесь есть алгоритмы.
3572.08 3573.52 "Анатолий Кулаков" Прежде всего это RSA.
3573.52 3578.68 "Анатолий Кулаков" Это самый популярный алгоритм с публичными ключами.
3578.68 3582.64 "Анатолий Кулаков" И это сейчас стандарт для асимметричного шифрования.
3582.64 3586.60 "Анатолий Кулаков" И он существует уже больше 10 лет, по-моему его изобрели.
3586.60 3590.72 "Анатолий Кулаков" И до сих пор нет доказанных методов его взлома.
3590.72 3598.20 "Анатолий Кулаков" То есть он подтвердил, что если выбирать достаточно большой ключ, то этот алгоритм стойк, красив и все еще актуален.
3598.20 3602.36 "Анатолий Кулаков" Достаточно большой это от 2048 бит.
3602.36 3607.32 "Анатолий Кулаков" Если вдруг будете использовать меньше этого числа, не советую делать ключи.
3607.32 3612.00 "Анатолий Кулаков" Еще один интересный алгоритм это DSA Digital Signing Algorithm.
3612.00 3615.20 "Анатолий Кулаков" Это другой алгоритм с публичным ключом.
3615.20 3627.04 "Анатолий Кулаков" Если сравнивать его с RSA, то его специфика в том, что он быстрее генерирует ключи, у него быстрее подпись и он быстрее дешифрует.
3627.04 3632.76 "Анатолий Кулаков" При этом RSA быстрее шифрует и быстрее проверяет подпись.
3632.76 3636.52 "Анатолий Кулаков" Если для вас важны вот такие тонкости, то вот здесь уже можно поиграться.
3636.52 3639.80 "Анатолий Кулаков" Вы можете выбрать тот или иной алгоритм с теми или иными свойствами.
3639.80 3651.44 "Анатолий Кулаков" Итак, как же выбрать самый правильный алгоритм для вашего приложения в вашей ситуации, рассмотрев три вот этих основных подхода, которые у нас есть в криптографии.
3651.44 3655.16 "Анатолий Кулаков" Прежде всего вам нужно ответить на кучу нетривиальных вопросов.
3655.16 3676.64 "Анатолий Кулаков" То есть каким образом выглядят ваши данные, насколько большие данные, которые вы собираетесь шифровать, важна ли для вас производительность, какой уровень безопасности вы хотите использовать, будете ли вы эти же данные передавать куда-либо, как вы собираетесь передавать ключ шифрования, с помощью которого будут обрабатываться данные и так далее.
3676.64 3681.08 "Анатолий Кулаков" Но на самом деле в принципе можно пойти от обратного.
3681.08 3683.52 "Анатолий Кулаков" Можно примерно определить.
3683.52 3691.60 "Анатолий Кулаков" То есть всегда мы пытаемся использовать самый секретный механизм, который только существует.
3691.60 3701.80 "Анатолий Кулаков" Самым секретным из этих трех механизмов естественно является асимметричное шифрование, потому что его ключи элементарно передаются и он очень стойкий, и он очень красивый.
3701.80 3707.00 "Анатолий Кулаков" То есть по дефолту поробуйте использовать асимметричное шифрование.
3707.00 3714.04 "Анатолий Кулаков" Никогда вы не должны не хотеть использовать асимметричное шифрование, прежде всего если у вас большой набор данных.
3714.04 3718.46 "Анатолий Кулаков" Я напомню, что с большими наборами этот подход работает достаточно медленно.
3718.46 3729.46 "Анатолий Кулаков" Другой способ, когда не нужно использовать асимметричное шифрование, это когда вам всего лишь нужно проверить целостность данных.
3729.46 3737.30 "Анатолий Кулаков" То есть вам не нужно поправить шифровать и расшифровать, а просто убедиться, что данные целые, никто их не повредил, никто их не изменил.
3737.30 3744.46 "Анатолий Кулаков" Вот для этого лучше использовать хэш-алгоритм, который намного производительнее и оптимальнее в данной ситуации.
3744.46 3753.18 "Анатолий Кулаков" Если же у вас огромный набор данных, который нужно очень быстро расшифровать и дешифровать, то ваш выбор это асимметричное шифрование.
3753.18 3759.46 "Анатолий Кулаков" И соответственно, если вам нужно убедиться, что данные ни кем не менялись, то ваш выбор хэш-функция.
3759.46 3760.46 "Анатолий Кулаков" Вот и все.
3760.46 3769.62 "Анатолий Кулаков" В принципе, вот такое элементарное дерево выбора, совсем небольшое, совсем очевидное, совсем понятное, вам необходимо для того, чтобы просто-напросто разбираться в современной криптографии.
3769.62 3773.90 "Анатолий Кулаков" Также никто не возбраняет вас использовать некий гибридный подход.
3773.90 3780.90 "Анатолий Кулаков" Например, допустим, у вас небезопасный канал, и при этом вы гоняете огромные наборы данных.
3780.90 3793.54 "Анатолий Кулаков" То есть, чтобы использовать безопасную коммуникацию, вам нужно асимметричное шифрование, а для того, чтобы работать с огромным объемом данных, вам нужно симметричное шифрование.
3793.54 3794.54 "Анатолий Кулаков" Как же быть здесь?
3794.54 3796.38 "Анатолий Кулаков" На самом деле, элементарно.
3796.38 3806.34 "Анатолий Кулаков" Как мы знаем, асимметричное шифрование позволяет нам безопасно передавать некие данные в небезопасном канале.
3806.34 3821.14 "Анатолий Кулаков" Таким образом, мы берем и используем для большого набора данных симметричное шифрование, и вот секретный ключ, который очень чувствителен к перехвату, мы этот ключ шифруем с помощью асимметричного шифрования.
3821.14 3834.54 "Анатолий Кулаков" Безопасно передаем его на другую сторону, там его с помощью асимметричного медленного шифрования расшифровывают, но зато после того, как этот ключ безопасно передан, с помощью симметричного быстрого шифрования мы начинаем молотить данные.
3834.54 3837.50 "Анатолий Кулаков" И такой гибридный подход себя отлично показывает.
3837.50 3845.14 "Анатолий Кулаков" Здесь отдельно стоит также упомянуть о криптографически случайных числах.
3845.14 3847.90 "Анатолий Кулаков" Я думаю, что с обычным рандомом вы знакомы все.
3847.90 3855.22 "Анатолий Кулаков" Система рандома, которая выдает вам псевдослучайные числа, и в криптографических функциях его не используют.
3855.22 3862.74 "Анатолий Кулаков" Потому что на самом деле он, естественно, псевдорандомный, ну все функции псевдорандомные, но псевдорандомность у всех разная.
3862.74 3865.02 "Анатолий Кулаков" У всех разный уровень псевдорандомности.
3865.02 3872.30 "Анатолий Кулаков" И система рандом, он не настоящий рандом, конечно же, и он делался с упором на перформанс.
3872.30 3881.38 "Анатолий Кулаков" То есть он очень быстрый и для обычных нужд, когда вы ни к чему не придираетесь, его перформанс великолепен, но его можно предсказать.
3881.38 3886.10 "Анатолий Кулаков" Наверное, самые внимательные из вас знают, что в рандом можно передать некий сид.
3886.10 3893.38 "Анатолий Кулаков" Это специальное начальное значение, от которого будут генерироваться все остальные значения, которые там будут.
3893.38 3897.54 "Анатолий Кулаков" Зная, например, этот сид, вы можете рандом сделать абсолютно не случайно.
3897.54 3901.66 "Анатолий Кулаков" Передав в рандом два одинаковых сида, рандом вам будет генерировать одинаковые значения.
3901.66 3911.18 "Анатолий Кулаков" И существуют вообще другие способы взламывания системы рандома, в общем, для криптографии он абсолютно не пригоден.
3911.18 3919.10 "Анатолий Кулаков" Для этого есть специальный другой класс, который находится в систем-секьюрити криптографии и называется он рандом number generator.
3919.10 3924.06 "Анатолий Кулаков" Именно его нужно использовать, если вам зачем-то нужны криптостоки, случайные функции.
3924.06 3928.46 "Анатолий Кулаков" Здесь, наверное, хотелось бы закончить.
3928.46 3936.74 "Анатолий Кулаков" Надеюсь, это введение вам более-менее помогло разобраться, как работает криптография, что там есть и каким образом ее можно использовать.
3936.74 3946.78 "Анатолий Кулаков" Если же вам хочется более подробной лекции с картинками и от более продвинутого профессионала, я вам настоятельно рекомендую доклад Владимира Кочеткова.
3946.78 3951.38 "Анатолий Кулаков" Называется он подводный камень систем-секьюрити криптографии.
3951.38 3959.54 "Анатолий Кулаков" Шикарный доклад, несмотря на дату, криптография наука не самая быстро развивающаяся в этом плане, это ее плюс.
3959.54 3963.06 "Анатолий Кулаков" В общем, несмотря на дату доклада, он по-прежнему полностью актуален.
3963.06 3971.82 "Анатолий Кулаков" Там рассматривается прекрасно и .NET, и различные атаки на шифрование, и способы, и подходы, каким образом мы должны это делать.
3971.82 3981.10 "Анатолий Кулаков" В общем, все то, что я вам рассказал, только гораздо более интереснее, с картинками и от человека, который не первый год этим занимается.
3981.10 3988.50 "Анатолий Кулаков" Второй доклад, который я вам хочу посоветовать, это доклад Стэна Драбкина, который называется Pitfall of High-Level Cryptography.
3988.50 4004.86 "Анатолий Кулаков" Здесь, в этом докладе Стэн рассуждает о проблемах, которые связаны с низкоуровневой криптографией, то есть когда мы должны задумываться об алгоритмах, о векторе инициализации, о размере ключа шифрования, о том, как это все передавать.
4004.86 4017.78 "Анатолий Кулаков" В общем, это довольно низкоуровневая штука, и если вы там вдруг углубитесь в код, то там есть очень много моментов, где вы можете прострелить себе все ноги, руки и голову.
4017.78 4027.98 "Анатолий Кулаков" И поэтому Стэн рассказывает о том, как бы сделать нам такую высокоуровневую криптографию, которая позволяет не заботиться о всех этих буферах, векторах, инициализациях, алгоритмах и прочего.
4027.98 4033.22 "Анатолий Кулаков" То есть сделать нормальные высокоуровневые классы, которые позволяют работать с этим безопасно.
4033.22 4040.14 "Анатолий Кулаков" И также Стэн прекрасен тем, что он рассматривает очень много проблем, которые есть в дот-нете с точки зрения безопасности.
4040.14 4043.64 "Анатолий Кулаков" То есть некоторые из этих алгоритмов, они недостаточно хороши.
4043.64 4050.38 "Анатолий Кулаков" И естественно, решение всех этих проблем и высокоуровневые библиотеки Стэн тоже приводит.
4050.38 4056.54 "Анатолий Кулаков" Поэтому если вы плотно работаете с криптографией, обязательно доклад Стэна просто к просмотру Must Have.
4056.54 4059.26 "Анатолий Кулаков" Так, на этом кажется все.
4059.26 4061.30 "Анатолий Кулаков" Надеюсь стало понятнее.
4061.30 4063.58 "Анатолий Кулаков" Надеюсь пригодится кому-то в будущем.
4063.58 4070.42 "Игорь Лабутин" Да, я надеюсь, что весь этот длинный монолог Анатолия был нормально можно воспринять на слух.
4070.42 4077.18 "Игорь Лабутин" Ну если действительно тяжеловато на слух, посмотрите доклады, там и Владимир, и Стэн отлично все рассказали.
4077.18 4078.18 "Игорь Лабутин" А мы пойдем дальше.
4078.18 4080.70 "Игорь Лабутин" Вернемся немножко к дот-нету восьмому.
4080.70 4082.62 "Игорь Лабутин" Теперь что-нибудь более лайтовое посмотрим.
4082.62 4085.30 "Игорь Лабутин" Это будут роадмапы.
4085.30 4092.42 "Игорь Лабутин" Мы уже посмотрели немножко и обсудили роадмапы спнета и EF Core, или EF8, как теперь его называют.
4092.42 4102.18 "Игорь Лабутин" Но есть еще ряд компонентов или библиотек, которые строятся на дот-нет платформе, которые тоже выпустили свои роадмапы касательно дот-нет восьмого.
4102.18 4110.54 "Игорь Лабутин" И я по ним кратенько пробегусь, потому что там есть местами где-то интересно, где-то не очень, но просто чтобы все были в курсе, что нас ждет.
4110.54 4111.54 "Игорь Лабутин" Начнем мы с Maui.
4111.54 4121.54 "Игорь Лабутин" Maui - это, наверное, штука, на которую Microsoft возлагает большие надежды в плане того, чтобы стать большим UI-фреймворком для всего в СИА и всех платформ.
4121.54 4139.62 "Игорь Лабутин" Но глядя на роадмап, не кажется, что там планируются какие-то большие мировые завоевания, потому что, во-первых, первый пункт роадмапа - это Improved Upgrade Path из Xamarin в дот-нет, то есть будут упрощаться и улучшаться пути миграции существующих Xamarin-продолжений в Maui.
4139.62 4149.94 "Игорь Лабутин" Там подтянут SDK-quality, напишут Upgrade Assistant, напишут еще кучку документаций, но никаких каких-то революционных нововведений нет.
4149.94 4155.18 "Игорь Лабутин" Второй пункт - это ускорить UI-рендеринг, видимо там все еще что-то подтормаживает.
4155.18 4169.14 "Игорь Лабутин" И третий пункт - это улучшить то, что называется Inner Loop Developer Time, то есть время, которое тратится разработчиками на момент разработки, а именно Build Time улучшения и Hot Reload улучшения.
4169.14 4174.42 "Игорь Лабутин" Вот такой вот скромненький роадмап Maui по сути весь этот год.
4174.42 4182.90 "Игорь Лабутин" Ну, Get, который не является вообще, говорят, штукой, которая прям как-то релизится вместе с дот-нетом.
4182.90 4187.78 "Игорь Лабутин" Ну, Get.org вообще свои собственные циклы релизов, они релизятся, когда захотят.
4187.78 4210.58 "Игорь Лабутин" У дот-нетов, ну, понятно, что они связаны с дот-нетом, но тем не менее, ну, Get выкатил довольно обширный роадмап, я не буду проходить по всему, но у них довольно большой фокус на security, то есть они сделают что под названием Package Vulnerability Audit, то есть они будут сканировать, видимо, пакеты на предмет известных уязвимостей и каким-то образом уведомлять вас.
4210.58 4216.94 "Игорь Лабутин" Пока деталей я не читал, не видел, как только будет что-то выкатываться ближе к релизу, будем смотреть.
4216.94 4229.46 "Игорь Лабутин" Дальше есть, видимо, некоторые проблемы с тем, как хранить пароли к NuGet-сурсам, если у вас они каким-то образом запаролены, тоже с этим будут работать, на тему encryption и прочее.
4229.46 4249.46 "Игорь Лабутин" Появится довольно много, ну, не то чтобы диагностик, но различных, там, упрощений, улучшений вокруг работы с HTTP и HTTPS, то есть если у вас, допустим, вы к чему-то доступаете по HTTP, а должны по HTTPS, в чём-то таком духе, то, кажется, всё будет там вордингом писаться и так далее.
4249.46 4271.50 "Игорь Лабутин" И мы рассмотрели фичу когда-то давно, летом, чуть ли не на прошлом она была выкачена, это package-source-mapping, это когда вы можете сказать, что вот такие пакеты с таким-то префиксом, бери только с этого соурса, вот эта штука-то есть, но там с tooling-ом пока не очень хорошо, вот надо там немножко подработать tooling-ом в этой области.
4271.50 4289.58 "Игорь Лабутин" В tooling-ом ещё нужно подработать это central package-management, это когда вы можете указать всё в едином файлике в корне вашего проекта, и после этого все csproj просто ссылаться на имя пакета без указания версии, вот tooling-ом тут тоже пока не очень хорошо поддерживает, видимо, ресторы, там, апдейты, апгрейды и так далее.
4289.58 4296.46 "Игорь Лабутин" Дальше у них есть интересный раздел, он называется season of giving, ну то есть типа такие штуки, которые полезные, которые они типа раздают, типа бесплатно.
4296.46 4308.22 "Игорь Лабутин" Не знаю, я не знаток иностранных, в данном случае, фразеологизмов или что это такое, возможно, эта фраза что-то значит более интересная, но тем не менее.
4308.22 4327.26 "Игорь Лабутин" Там будут штуки про... вокруг в основном tooling-а в части .NET-а, а именно .NET list package будет выводить что-то, что можно прочитать в компьютер, то есть то, что machine-readable output, то есть вы можете парсить и встраивать это дело в свои tools, например.
4327.26 4335.58 "Игорь Лабутин" А также огромное количество импровьментов у них заявлено для Nuget.exe и для .NET Nuget Command, всяких restore и прочих package.
4335.58 4345.26 "Игорь Лабутин" Так что если вы работаете с Nuget пакетами через command-line, следите внимательно за тем, что там будет выкатываться, видимо там будут какие-то улучшения, упрощения и импровьменты.
4345.26 4380.82 "Игорь Лабутин" В самом сайте Nuget они, вот уже мы обсудили, добавили фильтр по таргетам, также они планируют сделать очень важную фичу, добавить dark mode в сайт, он сейчас пока не умеет dark mode, и тоже очень большая фича, которую они хотят сделать, я пока не понимаю, как это будет работать и выглядеть, но это называется, не называется, фича заключается в том, что они хотят каким-то образом ранжировать пакеты по популярности, качеству, степени поддержки и какому-то комьюнити фидбэку.
4380.82 4394.50 "Игорь Лабутин" В общем, у нас будет, сейчас по-моему ранжируется только по количеству скачиваний, если я правильно помню, больше не почему, ну и по имени, наверное, можно сортировать еще, а вот будет какое-то более сложное и умное ранжирование, посмотрим, во что это выльется.
4394.50 4407.06 "Игорь Лабутин" И последнее в их родмапе, это сделать C# API, чтобы можно было ресторить и доунлодить пакеты, потому что сейчас это можно делать только тулингом через command line, а будет нормальная C# API для этого.
4407.06 4413.70 "Игорь Лабутин" Вот примерно такие планы у Nuget команды, и мы пойдем дальше в Roslyn.
4413.70 4432.58 "Игорь Лабутин" Roslyn это уже все-таки такая, ну, неотъемлемая часть тут нета, в смысле, что компилятор C# как-никак, и по большому счету страничка, которая называлась родмап для Roslyn, в смысле ссылка, которая называлась родмап для Roslyn, по сути ведет просто на страничку, где написаны те фичи C#, которые они собираются поддержать.
4432.58 4441.22 "Игорь Лабутин" Мы их уже смотрели, я на них смотрел, когда мы где-то в декабре делали выпуск про то, что нас может ждать в следующем C#.
4441.22 4448.30 "Игорь Лабутин" Сейчас можно посмотреть, что уже некоторые вполне себе в импрогрессе, есть отдельные бранчи, где над ними работают.
4448.30 4490.50 "Игорь Лабутин" Это полуавтоматические property, когда можно будет указать только getter и только setter, а второе оставить автоматическим, там для этого нужно новое ключевое слово field, так что вот сейчас пока работа ведется, primary конструкторы, сделать, возможность передавать вот params, параметр произвольный для произвольного количества аргументов через span t, а не через array, name of для instance member, lambda default параметры, collection literals, новая тема, так что можно будет у нас коллекции прямо в квадратных скобочках, если я правильно помню, текущий пропозал написать в квадратных скобочках 1, 2, 3, и это будет коллекция из элементов 1, 2, 3.
4490.50 4494.90 "Игорь Лабутин" Но когда до релиза дойдет какой-нибудь превью, мы подробнее, конечно, посмотрим на все эти фичи.
4494.90 4525.54 "Игорь Лабутин" И большая работа, похоже, активно началась над тем, что известно под очень разными названиями, сейчас этот пропозал называется roles или extensions, то есть в каком-то из интервью Мэтт Торгерсон говорил, что очень хочется сделать концепцию extend everything, сейчас у нас есть extension методы, хочется иметь возможность сделать extension property, extension что-нибудь еще, extension реализации интерфейсов на существующих классах.
4525.54 4533.70 "Игорь Лабутин" Вот сейчас ведется над этим работа, кажется, что в этом релизе .NET мы что-то можем на эту тему увидеть.
4533.70 4536.22 "Игорь Лабутин" По крайней мере, там есть бранч и что-то делается.
4536.22 4543.34 "Анатолий Кулаков" Ну, выглядит так, что это, кажется, будет самая большая фича, если она будет в этом релизе, потому что все остальное какое-то совсем мелкое.
4543.34 4560.66 "Игорь Лабутин" Пока да, то есть либо над чем-то крупным работают, что находятся еще пока на этапе пропозал, и поэтому бранча пока нет, ну и они обсуждают на language design митингах, я сейчас не следил последнее время за репозиториями C#, не смотрел, что там последние горячие топики в плане design митингов, посмотрим.
4560.66 4575.50 "Игорь Лабутин" Но про extension действительно был разговор, что вот хочется уже начать что-то с этим делать и спланировать так, чтобы, ну, получилось что-то сделать в .NET 8, но чтобы это не помешало потом сделать что-то дальше в следующих .NETах, так что посмотрим.
4575.50 4585.66 "Игорь Лабутин" Может что-нибудь в формате превью или там в каком-нибудь превью что-нибудь выкатят, но в релизе не будут релизить или под флагом превью сделают, но в общем посмотрим, не знаю пока.
4585.66 4602.66 "Игорь Лабутин" Дальше WinForms, WinForms живет прям, так сказать, активной жизнью, там есть работа над accessibility improvement, high DPI, в общем все стандартные UI фишки, которые они потихонечку, по мере того как винда видимо поддерживает что-то новенькое, они, соответственно, термят это WinForms тоже.
4602.66 4614.78 "Игорь Лабутин" Они работают над перформансом, как рантайма, так и дизайнера, и по аналогии с WPF, видимо, хотят что-то сделать с тестовой инфраструктурой и тест-кабриджем, будут над этим работать.
4614.78 4648.46 "Игорь Лабутин" Скорее всего рассматривать вариант, дописать еще недостающие в раперы для всяких контролов, которых не было поддержано в WinForms, ну типа там не знаю всякие, эти всплывающие вот хитрые подсказки из Trey, ну ToolTip в смысле, SearchBox, улучшить поддержку ListView, в общем, всячески поработать над контролами, которых почему-то вдруг не оказалось в WinForms, потому что над ними какое-то время не работали, и добавить еще поддержку этих самых тем для операционной системы, чтобы оно выглядело чуть более правильно в современных виндах.
4648.46 4653.62 "Игорь Лабутин" Никаких-то прорывных фич в WinForms нету, есть еще WPF.
4653.62 4697.98 "Игорь Лабутин" С WPF ситуация интересная, потому что где-то вот в районе анонса 7-го .NET-а звучали какие-то слова про то, что WPF, там community, короче там, мол, не ждите ничего, кроме того, что принесет community, а в этом статье с roadmap там прозвучала какая-то так мельком фраза про то, что команда WPF вообще говоря новая, ну типа, то есть такое ощущение, что они сначала разогнали всю команду WPF, а потом все-таки решили, что надо что-то с ним делать не только силами community, и в статье про roadmap прямо сказано, что типа team is new, и поэтому, мол, мы сейчас будем думать вообще над виженом для WPF, и ждите какой-нибудь документ в течение ближайшего полугодика, примерно так написано.
4697.98 4732.38 "Игорь Лабутин" При этом какие-то цели все равно заявляются на ближайший релиз, это будет, понятно, поддержка тем для Windows 11, новые контроллы, на лоббилити хотят завести, ну в смысле на local reference type поддержку, инфраструктуры поработают, будут как-то пытаться мержить community пиары, хотя сразу говорят, что мы пока не планируем мержить больше чем 5-6 пиаров в месяц, типа команды не хватит на большее, поэтому, мол, сильно не надо активно кидать пиары.
4732.38 4738.54 "Игорь Лабутин" Accessibility будут работать, и на ARM64, у них там пока с перформансом что-то не очень, тоже будут улучшать.
4738.54 4751.78 "Игорь Лабутин" В общем, такие скромненькие планы, посмотрим, что из этого вылезет, и вообще куда подвинется WPF при условии наличия MAU, и куда, видимо, основной фокус сейчас на разработке направлен с точки зрения UI.
4751.78 4777.98 "Игорь Лабутин" Хочу напомнить еще, что есть такой замечательный сайт, который называется themesof.net, который это по сути надстройка над GitHub, который просто ходит в GitHub и с помощью тщательно выстроенной системы тегов забирает из GitHub всех этих команд нужные issues, которые помечены как там, APIC и не APIC, и рендерит их в красивое дерево, где можно фильтровать по milestone и так далее.
4777.98 4789.14 "Игорь Лабутин" В шоуноутах будет ссылочка на .NET 8, можно там посмотреть, как красиво, что делается где в рантайме, что делается в библиотеках, ну и что делается во всех остальных местах .NET.
4789.14 4791.82 "Игорь Лабутин" Такие дела, такое будущее нас ждет.
4791.82 4797.74 "Игорь Лабутин" Ну, опять же, это roadmap, поэтому что из этого сбудется, мы пока не знаем, но по крайней мере, какие планы на будущее нас ждут.
4797.74 4808.74 "Анатолий Кулаков" Да, интересно уже вопрос, какой UI останется в конце, какой из них один или может быть уже несколько, не так очевиден как буквально год назад, когда обещали MAU все заменить.
4808.74 4811.02 "Игорь Лабутин" Да, все так, WinForms останется.
4811.02 4816.30 "Анатолий Кулаков" Ну, видишь, тут уже допьев собирают, поэтому непонятно.
4816.30 4820.14 "Игорь Лабутин" Ну, собирают, какая-то новая команда, не знаю, что будет делать, посмотрим.
4820.14 4821.14 "Игорь Лабутин" Посмотрим.
4821.14 4822.14 "Анатолий Кулаков" Посмотрим.
4822.14 4828.22 "Анатолий Кулаков" Ладно, пойдем еще в практическую плоскость сгоняем и хочу с вами обсудить интересную статью.
4828.22 4832.74 "Анатолий Кулаков" Автор задался вопросом, а как же нам непреднамеренно не раскрывать секреты.
4832.74 4835.30 "Анатолий Кулаков" Вот об этом мы сейчас с вами поговорим.
4835.30 4837.50 "Анатолий Кулаков" Прежде всего, что такое секреты?
4837.50 4845.30 "Анатолий Кулаков" Это какая-нибудь информация, которая не должна просто так фигурировать в открытом виде просто где-то везде.
4845.30 4863.58 "Анатолий Кулаков" Ну, например, это пароли, это какие-нибудь секретные ключи, сертификаты, лицензии, API ключи, токены и вот прочее-прочее вещи, которые как бы каким-то образом связаны может быть с безопасностью и они не должны просто так быть доступны абсолютно всем и каждому.
4863.58 4870.38 "Анатолий Кулаков" В нашей текущей парадигме, в нашей текущей картине мира все происходит гораздо прозаичнее.
4870.38 4881.94 "Анатолий Кулаков" Во-первых, обычно токены и пароли и прочая информация передается нам сейчас стандартно через различные опции.
4881.94 4899.78 "Анатолий Кулаков" В частности, переменные среды окружения, конфигурационные файлы или в лучшем случае это через какие-нибудь специализированные программы типа Volta, которые есть там у каждого клаудного провайдера или там HashiCorp, Volt, допустим, приложение вы можете себе поставить.
4899.78 4908.58 "Анатолий Кулаков" В общем, автор не задается вопросом, а как правильно это хранить и передавать в приложение, у него задача намного проще.
4908.58 4917.26 "Анатолий Кулаков" Каким образом в самом приложении, случайно, по глупости, без какого-то злого умысла эти все данные не раскрыть.
4917.26 4920.14 "Анатолий Кулаков" А раскрываются эти данные достаточно просто.
4920.14 4929.78 "Анатолий Кулаков" Например, случайно разработчик может залогировать какой-то класс, который в одном из свойств содержит секретные данные.
4929.78 4931.58 "Анатолий Кулаков" Например, какую-то конфигурацию, у которой есть поле паспорт.
4931.58 4936.86 "Анатолий Кулаков" И он хотел просто залогировать конфигурацию для того, чтобы ее как-то удобно дебажить.
4936.86 4940.98 "Анатолий Кулаков" И при этом опубликовал пользовательский пароль.
4940.98 4947.74 "Анатолий Кулаков" Или, допустим, хотел засериализовать какой-то объект, чтобы передать по сети какой-нибудь респонс.
4947.74 4952.62 "Анатолий Кулаков" И из этого респонса внезапно аксесс токен был записан для каких-то нужд.
4952.62 4957.38 "Анатолий Кулаков" И вот у нас аксесс токен утек в незашифрованном виде, не пойми куда.
4957.38 4965.54 "Анатолий Кулаков" Другая проблема, которая существует с секретами, это в том, что в обычном дотнет коде они представляются в виде просто строки.
4965.54 4973.82 "Анатолий Кулаков" Раз это просто строка, то уже довольно-таки сложно вообще понять, где этот секрет используется, как используется, кому передается.
4973.82 4978.94 "Анатолий Кулаков" В общем, следить за этими полями с секретными данными становится очень и очень сложно.
4978.94 4992.74 "Анатолий Кулаков" И еще одна проблема это в том, что когда вам приходит секрет, и приходит какая-то просто строка, вы не можете в коде определить, кто из них секрет, а кто не секрет, кто просто текст.
4992.74 4994.90 "Анатолий Кулаков" Типичным примером является connection string.
4994.90 5001.06 "Анатолий Кулаков" Я думаю, многие в своем коде могут найти методы, которые принимают connection string для доступа к базе.
5001.06 5006.86 "Анатолий Кулаков" Но мало, наверное, кто задумывался, что часто connection string внутри себя может содержать какие-нибудь пароли.
5006.86 5014.58 "Анатолий Кулаков" С помощью которых любой злоумышленник, владеющий строкой подключения, может доступиться до святая святых, до нашей базы данных.
5014.58 5020.14 "Анатолий Кулаков" И вот все эти проблемы автор предлагает красиво и элегантно решить.
5020.14 5024.50 "Анатолий Кулаков" И для решения он прибегает к нашему любимому Primitive Obsession.
5024.50 5029.02 "Анатолий Кулаков" Он говорит, что все это можно свести в принципе к зависимости от примитивов.
5029.02 5033.14 "Анатолий Кулаков" Мы в подкасте уже много раз поднимали тему Primitive Obsessions.
5033.14 5036.54 "Анатолий Кулаков" Если вы хотите поподробнее, поищите наши предыдущие выпуски.
5036.54 5044.94 "Анатолий Кулаков" А вкратце же, смысл заключается в том, что он предлагает сделать специальную обертку над чувствительными данными.
5044.94 5050.66 "Анатолий Кулаков" И эта обертка, этот классик, обладает очень интересными свойствами.
5050.66 5055.54 "Анатолий Кулаков" Во-первых, он не публикует наружу никаких свойств.
5055.54 5064.06 "Анатолий Кулаков" Это как раз таки для того, чтобы если этот класс случайно попадет в логер или в сериализатор, то никаких публичных свойств у этого класса нет.
5064.06 5067.90 "Анатолий Кулаков" И с большой долей вероятности сериализатор и логер ничего не запишут.
5067.90 5076.26 "Анатолий Кулаков" И также он не реализует класс ToString в том виде, в котором довольно казалось бы очевидно это сделать.
5076.26 5078.86 "Анатолий Кулаков" Просто-напросто раскрыть секрет в этом методе.
5078.86 5079.86 "Анатолий Кулаков" Но нет.
5079.86 5086.58 "Анатолий Кулаков" Как раз таки потому, что ToString очень часто используется логерами для того, чтобы записать какую-то информацию.
5086.58 5088.34 "Анатолий Кулаков" Поэтому ToString здесь тоже скрыт.
5088.34 5099.70 "Анатолий Кулаков" В качестве имплементации, естественно сейчас все современные приложения используют Microsoft Extensions Configuration, .NET-овские приложения.
5099.70 5107.70 "Анатолий Кулаков" И наш класс секрета нужно научить работать с этими опциями, с этой конфигурацией.
5107.70 5125.82 "Анатолий Кулаков" Делается это довольно просто, потому что уже в инфраструктуре заложено такой специальный Extension Poet, который говорит, что если некий тип декларирует TypeConverter для себя, то мы сможем в этот тип записать любую конфигурацию, которую TypeConverter сможет преобразовать.
5125.82 5134.42 "Анатолий Кулаков" Это значит, что мы сделаем класс секрет, декларируем ему специальный TypeConverter.
5134.42 5137.38 "Анатолий Кулаков" И практически это все, что нам нужно.
5137.38 5144.14 "Анатолий Кулаков" Единственное, что хочется отметить, отдельный подход автора насчет скрытия самого текста, самого секрета.
5144.14 5150.42 "Анатолий Кулаков" Естественно в конструктор класс секрет передается открытая строка, а вот что с ней делать дальше?
5150.42 5153.42 "Анатолий Кулаков" Никакого публичного свойства, как я уже сказал ранее, ее положить нельзя.
5153.42 5167.58 "Анатолий Кулаков" Также ее нежелательно складывать в обычный StringField, потому что многие сериализаторы умеют сериализовать приватные филды, и от этого мы тоже хотим случайно защититься.
5167.58 5172.78 "Анатолий Кулаков" Поэтому автор придумал хранить строку в типе, который называется Read-only Memory Chars.
5172.78 5185.62 "Анатолий Кулаков" То есть это специальная коллекция специальных Read-only Memory, куда мы можем преобразовать строку, а также при необходимости из этой Read-only Memory достать строку, сконструировать заново по сути.
5185.62 5191.78 "Анатолий Кулаков" И на данный момент ни один из известных сериализаторов не умеет правильно сериализовать Read-only Memory.
5191.78 5200.30 "Анатолий Кулаков" Воспользуясь этим странным фактом, автор решил спрятать строку именно в приватный филд Read-only Memory.
5200.30 5201.30 "Анатолий Кулаков" Забавный подход.
5201.30 5212.50 "Анатолий Кулаков" Также к этому классу автор добавил публичный метод Reveal, который конструирует строку из нашего Read-only Memory массива и представляет ее наружу в первозданном виде.
5212.50 5221.82 "Анатолий Кулаков" Здесь отдельно хочется отметить, что все данные манипуляции никаким образом не имеют отношения к криптографичности.
5221.82 5233.18 "Анатолий Кулаков" То есть эта строка не шифруется, и если вдруг вы зайдете там под дебаггером или под отладчиком, или еще каким-то образом эта строка утечет все-таки, то ее элементарно можно будет посмотреть или восстановить.
5233.18 5248.70 "Анатолий Кулаков" Если же вы хотите загоняться прям к криптографии и не просто так хранить, а хранить ее всегда зашифрованную, чтоб даже если кто-то через Reflection к вам пришел, не обладая ключом шифрования, он ее не получил, тогда посмотрите на класс Microsoft ISP Netcore Data Protection.
5248.70 5250.38 "Анатолий Кулаков" Там для этого есть все необходимые механизмы.
5250.38 5256.90 "Анатолий Кулаков" И следующий классик после Secret нам нужен естественно Secret Type Converter, который я упомянул ранее.
5256.90 5271.26 "Анатолий Кулаков" Он интересен тем, что у него метод convertFrom позволяет конвертиться только из строки, convertTo возвращает false, то есть не позволяет никуда конвертиться, и convertTo метод бросает exception.
5271.26 5275.62 "Анатолий Кулаков" То есть canConvertTo возвращает false, а canConvertTo бросает exception.
5275.62 5279.46 "Анатолий Кулаков" А convertFrom соответственно создает наш класс Secret.
5279.46 5282.22 "Анатолий Кулаков" Вот такую классную оберточку придумал автор.
5282.22 5284.06 "Анатолий Кулаков" Мне кажется довольно полезная штука.
5284.06 5287.10 "Анатолий Кулаков" Наверное попробую себе повнедрять, посмотрим как пойдет.
5287.10 5293.30 "Анатолий Кулаков" И использовать ее довольно легко, так как мы ее подписали под стандартный класс Options.
5293.30 5311.38 "Анатолий Кулаков" Мы можем из сервиса контейнерных запросить IOptions с нашим классиком или же попросить в конструкторе, как обычно все делают, вызвать специальный метод раскрытия чистой строки пароля и использовать этот пароль уже, или этот Secret, или лицензионный ключ везде, где нам нужно.
5311.38 5313.22 "Анатолий Кулаков" Таким образом мы решили все проблемы.
5313.22 5318.38 "Анатолий Кулаков" То есть у нас теперь отличаются строка и Secret.
5318.38 5322.38 "Анатолий Кулаков" Мы можем четко понять, кто к нам в класс пришел, какую зависимость мы требуем.
5322.38 5326.18 "Анатолий Кулаков" Мы просто так уже не сможем ни залогировать, ни засериализовать его.
5326.18 5329.74 "Анатолий Кулаков" И также мы можем отличить в коде строку Secret.
5329.74 5334.62 "Анатолий Кулаков" Мы можем не только отличить, мы можем посмотреть все использования Secret в нашем коде.
5334.62 5340.66 "Анатолий Кулаков" И одновременно может быть даже сделать какой-то анализ правомерно данный класс использует Secret или может это не стоит ему делать.
5340.66 5345.50 "Анатолий Кулаков" В общем, замечательный классик вы найдете по ссылке в статье.
5345.50 5357.26 "Анатолий Кулаков" Также у автора там есть прекрасные тесты, которые проверяют, что JSON сериализатор не может прочитать настоящее значение, то есть не может сериализовать настоящее значение, если ему вдруг этот класс случайно попадется.
5357.26 5365.62 "Анатолий Кулаков" И даже если вы попросите сериализовать приватные филды и сделаете флажок include fields, он все равно этого сделать не сможет.
5365.62 5378.02 "Анатолий Кулаков" Это проверено на Newtonsoft и на системе текст JSON и много других полезных тестов, которые пытаются взломать этот классик, естественно, случайным таким способом, за считай дурачка, и у него не получается.
5378.02 5382.82 "Анатолий Кулаков" Хороший классик, я думаю, стоит попробовать, как он поведет себя на практике.
5382.82 5396.98 "Игорь Лабутин" Ну надо только не забывать, что строчку, полученную из этого самого reveal метода, не надо передавать никуда дальше, иначе все эти ухищрения пойдут лесом, если вы дальше ее передадите в какой-нибудь другой класс уже в виде строки.
5396.98 5404.66 "Анатолий Кулаков" Да, но тут уже отход ревью, наверное, никто не защитит, и мы от него не избавимся, поэтому все равно придется каким-то образом смотреть и следить за собой.
5404.66 5405.66 "Анатолий Кулаков" Да, придется.
5405.66 5418.58 "Игорь Лабутин" Но, с другой стороны, действительно, от какого-то случайного утекания может действительно помочь или явно подсветить, что именно в этом месте используется что-то секьюрное.
5418.58 5419.58 "Игорь Лабутин" Давай пойдем дальше.
5419.58 5430.34 "Игорь Лабутин" У нас есть еще одна статья от Microsoft, в которой, вообще говоря, Microsoft подошел немножко, ну скажем так, неожиданно для меня.
5430.34 5434.10 "Игорь Лабутин" И это первая статья в серии, как они обещают.
5434.10 5441.54 "Игорь Лабутин" И озаглавлена эта серия "What is .NET and why should you choose it?" То есть, что такое .NET и зачем вам его выбирать.
5441.54 5443.54 "Игорь Лабутин" Причем она в .NET блоге.
5443.54 5449.94 "Игорь Лабутин" То есть, как я понял, ну ладно, давай с другой стороны начнем.
5449.94 5453.94 "Игорь Лабутин" Давай сначала статью обсудим, а потом уже все остальное проговорим.
5453.94 5462.42 "Игорь Лабутин" Они хотят в этой серии статей рассказать, что такое .NET с точки зрения, почему он именно так задизайнен.
5462.42 5472.54 "Игорь Лабутин" Что является какими-то фундаментальными решениями или моментами, которые были выбраны при дизайне текущей .NET платформы.
5472.54 5475.54 "Игорь Лабутин" И почему это, вообще говоря, полезно вам.
5475.54 5477.30 "Игорь Лабутин" Чем .NET может быть вам полезен.
5477.30 5484.94 "Анатолий Кулаков" То есть, это не статья для новичков, которые переползают из какого-нибудь питона в .NET, который объясняет, что это такое .NET.
5484.94 5490.18 "Анатолий Кулаков" А это все-таки что-то более глубокое, инженерное, для людей, которые знакомы с .NET.
5490.18 5510.70 "Игорь Лабутин" Вот это как раз странно, потому что, и мы про это сейчас будем говорить, давай, наверное, сразу увидим это, в смысле обсудим, что я эту статью, когда увидел, я ее как-то по диагонали прочитал, посмотрел, что там стандартные слова .NET, платформа, менедж, garbage tracker, вот это все, ну, короче, там, безопасно.
5510.70 5523.14 "Игорь Лабутин" Я чуть даже ее не стал глубоко читать, а потом вышла статья через несколько дней от Андрю Лока, где были его мысли на тему того, что это за статья, и тут я понял, что нет, ну, как бы он такие статьи пишет редко, обзорные на соседей.
5523.14 5525.82 "Игорь Лабутин" И я решил ее прочитать внимательнее.
5525.82 5550.30 "Игорь Лабутин" И на самом деле и Андрю Лок, и я в каком-то смысле с ним согласен, в том, что поначалу, вообще говоря, не очень понятно, на кого рассчитана эта статья, потому что она описывает, вообще вся статья описывает про то, что .NET это про productivity, безопасность, про то, что у нас, значит, все там секьюрно, при этом быстро, перформансно, и все такое прочее.
5550.30 5570.22 "Игорь Лабутин" То есть такой очень широкий обзор того, что из себя представляет .NET, но при этом он не то, что, то есть с одной стороны, он широкий, потому что вот раздел под названием .NET Design Point говорит про то, что, ну, как бы основная цель .NET это быть, во-первых, эффективным, а во-вторых, эффективным.
5570.22 5577.86 "Игорь Лабутин" Ну, по-английски это effective и efficient, в том смысле, что он и работает быстро, и программисты на нем работают тоже эффективно.
5577.86 5585.26 "Игорь Лабутин" Причем и в, так сказать, безопасном окружении, и в небезопасном окружении, если вам нужен какой-то интероп и так далее, .NET там тоже хорош.
5585.26 5607.34 "Игорь Лабутин" И что, мол, .NET это, наверное, одна из единственных таких менедж платформ, где, значит, у нас наибольшая, так скажем, функциональность туда зашита и позволяет при этом практически бесшовный интероп, значит, с миром плюсов, да, ну, обычно с кем интеропитесь, с плюсами, при этом по возможности все еще оставаясь в safe мире.
5607.34 5609.26 "Игорь Лабутин" Ну, смотри, спаны там, вот это все.
5609.26 5623.74 "Игорь Лабутин" При этом у нас есть там статический динамический код, интринсики, портабилити, а дальше пошли слова про gRPC, OpenTelemetry, то есть оно все такое, как бы, в очень разные места, где-то про интеропы и интринсик они говорят, а где-то про OpenTelemetry это вообще говорят.
5623.74 5629.94 "Игорь Лабутин" Но аудитория таких высказываний, по идее, должна быть немножко разной, но тем не менее.
5629.94 5661.58 "Игорь Лабутин" Дальше они говорят, что, ну, у нас есть основные, так сказать, составляющие .NET stack, это, понятно, runtime, библиотека и языки, при этом, правда, на 99% статья про C#, F#, напоминается, по-моему, один или два раза, ну и VB, то есть, но, как говорит Эндрю, ну, наверное, может это правильно в том смысле, что для перетаскивания скорее всего большинство народу будет переходить все-таки на C#, а не на F#, хотя, конечно, F# незаслуженно обойдет страной немножко в этом посте.
5661.58 5710.74 "Игорь Лабутин" А дальше пошел прям детальный разбор, ну, детальный, там, по 2-3 абзаца на каждый пункт, про то, какая у нас type-система, что мы объектно-ориентированные, значит, среда, что у нас там есть генерики, делегаты, лямбды, value-тайпы, ref-тайпы, то есть, вот понимаешь, да, там с одной стороны рассказывают про наследование интерфейса, а с другой про ref-тайпы, то есть, там вот такое очень разные глубины темы, про автоматику memory management, GC, safety, обработка ошибок, исключения, concurrency, там, async/await, reflection, код генерации, jit, aod, interop, и, в общем, вот такая вот большая-большая-большая статья, из которой, в принципе, если вы не знакомы с .NET, можно узнать, ну, такое поверхностное состояние, ну, это все-таки первая статья пока, дел в современном .NET, и в этом смысле она неплоха.
5710.74 5742.50 "Игорь Лабутин" Вот, кажется, и вот тут хочется вернуться к Эндрю Лоуку, он на самом деле высказывает разумные мысли, то есть, кажется, что это попытка Microsoft заполнить немножко нишу постов вида "почему я свичнулся с такой технологией на такую", то есть, на самом деле сейчас есть огромное количество постов про то, что типа "я много лет писал на Go, теперь пошел писать на Rust, или там я писал на Python, теперь я пошел писать на Go, или я писал на Java, я пошел писать на Kotlin", а вот про .NET такого нет, ну, практически нет.
5742.50 5788.22 "Игорь Лабутин" И, видимо, причина эта в том, что, ну, .NET, история такая, да, это Windows Only, медленный какой-то фреймворк, понятно, что сейчас это не так, но память-то у людей, где-то слышу, что .NET медленный, Windows Only, значит, я и буду считать, что это .NET и Windows Only, и, видимо, этими постами Microsoft собирается, то есть аудитория этих постов, видимо, все-таки те самые люди, которые сейчас уже пишут на каких-то языках и фреймворках, так что, может быть, это и даже для Python-разработчиков каких-нибудь начинающих, почему нет, и я надеюсь, что просто будут разные посты на разный уровень, которые покажут разным группам людей, что, мол, на .NET хорошо и прекрасно, и вообще надо туда идти, и там будет удобно.
5788.22 5814.34 "Игорь Лабутин" Так что будем следить за этими постами, то есть если вам интересно узнать, или кто-то вас спрашивает, я надеюсь, что вы и так знаете, что такое .NET, раз вы слушаете этот подкаст, но если вас кто-то спрашивает про то, что такое .NET, вот можно будет в том числе скидывать вот этот пост от Microsoft, всю серию, когда он появится полноценный, видимо, там будет хорошее описание того, что такое .NET.
5814.34 5815.34 "Игорь Лабутин" Посмотрим, будем следить.
5816.34 5825.78 "Анатолий Кулаков" Ну и действительно не хватает материалов, которые помогут людям с других языков свечиться на .NET, поэтому, может быть, это универсальное тоже сокроют, было бы приятно.
5825.78 5828.06 "Игорь Лабутин" Да, было бы приятно.
5828.06 5829.66 "Игорь Лабутин" Давай пойдём дальше.
5829.66 5831.66 "Игорь Лабутин" Дальше у нас Tooling.
5831.66 5847.34 "Игорь Лабутин" Tooling, я уже говорил, что вышло, ну так, кратенько говорил, что для .NET 8 нам нужна Visual Studio 17.6 Preview 1, но тем не менее у нас вышла ещё обычный нормальный релиз 17.5 для Visual Studio 2022.
5847.34 5852.38 "Игорь Лабутин" Там есть некоторое количество улучшений, изменений и так далее, о котором мы сейчас быстренько пробежимся.
5852.38 5856.02 "Игорь Лабутин" Первое раздел это Productivity и Performance.
5856.02 5874.22 "Игорь Лабутин" Там добавился, как добавился, был уже универсальный поиск All-in-One Search, его ещё немножко улучшили, ускорили, и он поумнел, так что смотрите, что там, Control+T, по-моему, да, называется по дефолту в студии, я уже не помню сейчас, он будет вам что-то интересное выдавать.
5874.22 5876.94 "Игорь Лабутин" Появились новые Suggestions, я, кстати, с ними поработал
5876.94 5892.74 None немножко, тут я что-то в студии работал, они там прям, да, всячески пытаются за вас комплетить код, ну не Copilot, хотя я Copilot полноценно не пользовался, но что-то похожее, прям полные методы не пишут, но строчки дописывают весьма прилично, вот.
5892.74 5905.30 "Анатолий Кулаков" Ну, кстати, до сих пор непонятно, почему Microsoft обладает технологиями Copilot, а часть GPT и OpenAI до сих пор не встроила в Visual Studio какого-нибудь нормального человеческого дополнения.
5905.30 5910.54 "Игорь Лабутин" Не, ну слушай, Copilot в студию встраивается, просто он нормально, Copilot денег стоит, поэтому…
5910.54 5917.22 "Анатолий Кулаков" Ну, я имею в виду, грубо говоря, в студии это тоже как бы коммерческий продукт, вот за коммерческой студией могли бы включить туда уже сразу Copilot.
5917.22 5919.22 "Анатолий Кулаков" Ну, какого-нибудь Enterprise версии, да.
5919.22 5921.94 "Анатолий Кулаков" Да, да, какой-нибудь максимальной версии, фиг ты с ними.
5921.94 5923.94 "Игорь Лабутин" Может и включат, кстати, не знаю.
5923.94 5934.18 "Игорь Лабутин" В общем, вот пока, но при этом пока вот эти AI-powered intent-based suggestions, ну, выглядят приятно, но такие мелкие вамошники.
5934.18 5938.26 "Игорь Лабутин" Мы уже упоминали Debugger Text Visualizers, все, они зарелизились, можно пользоваться.
5938.26 5959.98 "Игорь Лабутин" Они переработали систему билда, в смысле, когда студия пытается понять, что там нужно перебилдживать, когда у нас инкрементал билды включены, видимо, они смотрят на что-то похожее на то, что делает ReSharper Build, не настолько детально, но тем не менее утверждают, что инкрементал билды стали прям супер быстрыми и меньше проектов нужно перебилдживать.
5959.98 5967.70 "Игорь Лабутин" И кроме того, они ускорили работу окошка с трейдами, прям в два раза, типа оно работает быстрее, удобнее.
5967.70 5970.90 "Игорь Лабутин" То есть не трейды работают быстрее, а окошко работает быстрее.
5970.90 5980.50 "Игорь Лабутин" Да, да, ну, дебаггеры, вот этот вот дебаггер на окошке трейдов быстрее отображает все данные, потому что современные приложения многопоточные, они должны работать быстро, ну, в смысле, окошко, потому что ты отлаживаешь почти всегда многопоточный код.
5980.50 5989.86 "Игорь Лабутин" И улучшили немножко туллинг вокруг Razer, там всякие тоже хинты появились, там quickfixes и так далее при редактировании Razer шаблонов.
5989.86 5998.34 "Игорь Лабутин" В то, что они называют современном Cloud Development тоже появились интересные штуки.
5998.34 6003.46 "Игорь Лабутин" Во-первых, добавили поддержку .http и .rest файлов.
6003.46 6014.34 "Игорь Лабутин" То, что мы знали в Visual Studio Code, то, что мы знали в Ryder, но и в идеях везде, в IntelliJ, в JetDrains, теперь есть в студии тоже.
6014.34 6019.34 "Игорь Лабутин" Студия теперь тоже может нативно запускать .http и .rest файлы, запросы, которые в них написаны.
6019.34 6029.22 "Анатолий Кулаков" Ну, непонятно, почему это не сделали обычным плагином, как бы, в студии же есть система плагинов, как и другие IDE-шки, могли бы точно так сделать, а чем это тащить во большую студию.
6029.22 6041.86 "Игорь Лабутин" Слушай, ну, мы с тобой обсуждали, что кажется, что сейчас методика такая, что Matt Christensen быстренько пишет плагин, на нем, на этом плагине обкатывается какое-то там небольшое количество народу, после чего это идёт в основной релиз студии, видимо.
6041.86 6074.14 "Игорь Лабутин" То ли таким образом попроще конкурировать, грубо говоря, с большими VE, потому что, ну, ты не будешь, как Visual Studio пользователей, ну, то есть, я не знаю, ты, может, ты будешь, да, ходить и выискивать все удобные тебе экстенджеры, а кто-то не будет, а скажет, а, ладно, я поставлю условный Ryder, там всё это, почти всё, не так, не почти всё, гораздо больше есть из коробки, да, не надо ставить плагинов для чего-то, всё ещё нужно ставить плагины какие-то, хип-визуалайзеры, да, хип-аллокейшн-визуалайзер, но, тем не менее, больше всего есть из коробки.
6074.14 6075.14 "Игорь Лабутин" Ну, и здесь будет.
6075.14 6076.14 "Анатолий Кулаков" Да, ты прав.
6076.14 6090.58 "Анатолий Кулаков" Ну, и вот эти .http файлы, они очень полезны, мы тоже о них много говорили, ни один подкаст стёрли, поэтому, если вы вдруг не пользовались, то попробуйте, попробуйте, скорее всего, это будет один из очень удобных клиентов, который в некоторых ситуациях может вас сильно выручать.
6090.58 6116.54 "Игорь Лабутин" Да, значит, если вы пользуетесь дефтаннелами для какого-то ремолл-дебангинга или работают, то тоже там упростилась настройка и управление ими, если вы работаете с ажуром и с Azure Container Apps, то тоже там теперь попроще работать, и если вы работаете с WPF, там появился accessibility чекер, который вам прям подсветит, что вот-вот тут вот у вас не очень accessible, значит, UI нарисован, давай там добавим какие-нибудь штуки.
6116.54 6123.98 "Игорь Лабутин" Плюсов, очень много улучшений по плюсам, кроссплатформинга, победа, там, геймдевелопинг, много чего.
6123.98 6129.18 "Игорь Лабутин" Не буду вдаваться в детали, сам не занимаюсь, поэтому прям могу наврать много в чем.
6129.18 6146.34 "Игорь Лабутин" Отдельный раздел Enterprise Management, это интересный раздел, во-первых, теперь студию можно поставить через Winget, во-вторых, у нее появилась опция в настройках, которая называется Always Update on Close, то есть когда вы закрываете студию, она будет автоматически себя апдейтить, почти как Skype, по-моему, себя ведет к Skype, это делает при старте.
6146.34 6148.66 "Анатолий Кулаков" Хипстота какая-то пошла, что это такое?
6148.66 6150.62 "Игорь Лабутин" Да, мы всегда были на latest штуке.
6150.62 6172.54 "Игорь Лабутин" А в-третьих, можно заэкспортить layout в отдельный файлик и при запуске, короче, то ли при запуске, то ли еще как-то закастомизировать layout через config.file в студии, в общем, про Enterprise очень звучит, не знаю, зачем будет нужно, но, наверное, опять же, какой-то централизованной конфигурации, видимо, кто-то что-то просил, сделали.
6172.54 6184.66 "Игорь Лабутин" Одновременно с этим вышла студия для Mac, тоже 17.5, там очередные импровизации в GT, мы, кстати, их, по-моему, как-то где-то обозревали, там появилась фича под названием Hot Exit.
6184.66 6185.66 "Игорь Лабутин" Звучит заманчиво.
6185.66 6186.66 "Анатолий Кулаков" Да.
6186.66 6187.66 "Игорь Лабутин" Что она делает во время выхода?
6187.66 6201.70 "Игорь Лабутин" Я начал читать, первый абзац был написан следующим, при выходе из студии, когда у вас есть несохраненные изменения, вам не будет показываться окошко про save changes.
6201.70 6202.70 "Игорь Лабутин" Я такой, ну, блин, что?
6202.70 6203.70 "Игорь Лабутин" Отличный пост.
6203.70 6204.70 "Игорь Лабутин" Зачем, почему?
6204.70 6214.86 "Игорь Лабутин" Во втором абзаце, правда, было написано, что, типа, не, но при этом изменения не потеряются, они, типа, их сами куда-то сохранят во временные файлики и при следующем открытии просто обратно откроют.
6214.86 6230.46 "Игорь Лабутин" Ну, то есть, такой, типа, знаешь, как там, ну, под лет плюс себя так ведет, ну, сейчас довольно много всяких приложений ведет себя так, что, типа, они как бы заавтосейвили всё, но не в файлик, а вот куда-то во временные свои места, и после открытия всё вернётся обратно.
6230.46 6236.98 "Анатолий Кулаков" Мне кажется, в случае с кодом это какое-то извращение в Overkill, сохраните каждую секунду и всё, и будет нормально.
6236.98 6238.98 "Анатолий Кулаков" Там уже гид позаботится об истории и во всем остальном.
6238.98 6242.22 "Игорь Лабутин" Да, ну вот, зачем-то опять же кому-то нужно было.
6242.22 6253.58 "Игорь Лабутин" Дальше, в редакторе пофиксили поддержку фонтов, там были какие-то фонты, которые не поддерживались на Маке, ну, в смысле, можно было взять фонт, он на Маке работал, а в студии почему-то не работал, пофиксили.
6253.58 6260.94 "Игорь Лабутин" Ну и улучшили там всякие юнит-тестинги, опять ускорили этот юнит-тест браузера, видимо, там всё ещё есть что ускорять.
6260.94 6268.38 "Игорь Лабутин" Примерно так, ну, то есть, я не помню, по-моему, я себе уже обновился на 17.5, вторую студию.
6268.38 6271.98 "Игорь Лабутин" Посмотрим, поглядим, как будет жить.
6271.98 6275.58 "Анатолий Кулаков" Ну, отлично, я тоже обновлюсь, посмотрим, что там за новинки у нас будут.
6275.58 6280.30 "Игорь Лабутин" Ну и на этом, наверное, основную часть выпуска можно завершать.
6280.30 6300.30 "Игорь Лабутин" Долго сидим, много длинных интересных статей попалось, и Dota 2 8 вышел, и всё, начал выходить с первых превью, и студия, как обычно, в общем, мы потихонечку возвращаемся в руфло регулярных релизов, и я надеюсь, что в следующих выпусках подкаста потихонечку будут всё больше и больше новостей про то, что нас ждёт к ноябрю.
6300.30 6302.54 "Игорь Лабутин" Но у нас есть ещё немножко.
6302.54 6307.06 "Анатолий Кулаков" Да-да, погоди прощаться, ещё парочку мелких тем мы вбросим.
6307.06 6313.86 "Анатолий Кулаков" Прежде всего, нельзя обойти стороной просто эпическое событие, которое произошло в дружественном подкасте Подлодка.
6313.86 6326.38 "Анатолий Кулаков" Мы его уже не раз рекламировали в наших выпусках, там, опять же, подкаст про различные профессии около IT, да и в принципе не только около IT, у них там всё есть уже, сваливается в самые последние темы.
6326.38 6333.06 "Анатолий Кулаков" И у них есть специальное у Подлодки, есть специальное направление, это они рассказывают о языках программирования.
6333.06 6355.14 "Анатолий Кулаков" И вот, рассказали практически про все языки программирования, по-моему, там и NIM у них был, и Fortran я послушал, интересный выпуск, и я даже не знаю, про что ещё спуститься, но практически всё высосались, что только можно, даже эзотерические страшные будущие языки программирования в будущем, но вот до C# они не могли добраться целых 300 выпусков.
6355.14 6358.50 "Анатолий Кулаков" И вот, друзья, наконец-то свершилось чудо.
6358.50 6372.42 "Анатолий Кулаков" Вышел 303 выпуск, .NET часть первая, и 304 выпуск, .NET часть вторая, наконец-то широкий мир узнал о том, что .NET существует, C# есть, и вообще про всю инфраструктуру вокруг этого.
6372.42 6376.70 "Анатолий Кулаков" И рассказал нам об этом никто иной, как некий Игорь Лобутин.
6376.70 6377.70 "Анатолий Кулаков" Знаешь такого, Игорь?
6377.70 6378.70 "Игорь Лабутин" Слышал, слышал.
6378.70 6382.74 "Анатолий Кулаков" Ну-ка, просвети, да, что ты там наплёл.
6382.74 6436.62 "Игорь Лабутин" Ну, надо сказать, что про C# там не так много, это в основном действительно история про сам .NET, первая часть это историческая часть, и немножко мы успели, по-моему, затронуть рентайм, ну а во второй части был там тулинг, как раз обзор кратко, очень кратко про то, какие языки есть, что у нас с экосистемой, ну геты, вот это всё, то есть такое довольно поверхностное, без углублённых копаний, как мы любим здесь в подкасте, обзор того, что вообще такое современный .NET и как к нему подходить, как его понимать, потому что до сих пор, если читать статьи, встречается, кто-то говорит про .NET Framework, кто-то говорит про .NET Standard, кто-то говорит про .NET, вот как это всё различать, на чём сейчас всё это работает, я постарался каким-то образом описать.
6436.62 6471.74 "Игорь Лабутин" И возвращаясь вот сегодня к теме, о которой мы говорили, про статью Microsoft, что такое .NET, кажется, что по аналогии с, не по аналогии, в дополнении к статье, к серии статьи Microsoft, я надеюсь, что всё-таки будет серия про то, что такое .NET, можно в русскоязычном или в аудио варианте как раз две ссылки на этот подкаст выдавать, чтобы народ, который не знает, что такое .NET, потихонечку узнавал, что это такое, как им пользоваться и какую пользу он может извлечь из этой платформы. Ну вот я действительно
6471.74 6479.98 "Анатолий Кулаков" очень часто получал такие вопросы от коллег по цеху, типа расскажи, что такое .NET, как он сейчас живёт, что там в нём есть, какие там типы и всё в этом духе.
6479.98 6488.10 "Анатолий Кулаков" И не было нормальных статей, не было даже не статьи, а видосика, в общем, не было нормального места, где можно послать и вот такую вот обзорную часть получить.
6488.10 6553.14 "Анатолий Кулаков" И мне кажется, что вот эти выпуски, они получились просто идеально. Вот это как раз та таргет аудитория, которой хотелось покрыть. Люди, скорее всего, технари, но не знакомые с .NET, но может быть знакомы с другими какими-то вещами. На мой слух, когда я это услышал, мне вот показалось, что это вот именно то, чего не хватало и именно в таком изложении, как это должно быть. В общем, мне очень понравились выпуски. Интересно мнение людей, которые не очень глубоко в .NET, если вы вдруг только начинающий разработчик или у вас есть друзья, которые интересуются .NET, дайте им, пожалуйста, эти выпуски и напишите к нам в комментариях, как им зашло, насколько там всё понятно, насколько всё хорошо, то есть можно ли вот эти вот выпуски таким образом использовать. Мне кажется, даже начинающий разработчик, который не сильно шарит в нашей терминологии, в нашем фреймворке, вот там он не встретит каких-то таких страшных слов. То есть ему тоже должно быть удобно, ему должно быть интересно. В общем, если у вас будут какие-то интересные отзывы, замечания, тоже пишите нам в комменты, обязательно обсудим. Да, всё так. Ну
6553.14 6641.42 "Игорь Лабутин" и у нас осталась последняя наша рубрика, это кратко о разном. В этот раз там не так много разного и довольно кратко, но тем не менее, есть что рассказать и чем поделиться. Во-первых, Nougat. Я где-то уже упоминал в Nougat Roadmap, что они завезли фичу под названием «Поиск по target framework». Ну или может только думал упомянуть, но не упоминал. Смысл в том, что теперь, когда вы ищете пакет, у вас слева будет панелька, где можно выбрать, какой target framework вы хотите. Причём там сначала можно выбрать, типа я хочу .NET Framework, .NET Standard или .NET, например. Ну или там Mono, не помню, есть там Mono или нет. Но вот эти три точно есть. Но и тогда будут, например, если вы выберете .NET, то это значит, что, а .NET Core там ещё есть. Если вы выберете .NET, то это будет означать, например, .NET 5 и новее. Но если вам нужна какая-то прям специфическая версия, то есть вы хотите там для .NET 6 именно, то дальше можно это дело раскрыть и там в дереве выбрать уже прям конкретную версию .NET. Так что искать будет попроще. Вот. И вторая новость это то, что вышел новый релиз библиотеки Mediator 12.0. Это прям большой релиз. В смысле, много релизов уже было в этой библиотечке и мне кажется, что прошлый был как-то довольно давно, хотя я не слежу, я особо не пользуюсь. Толь, ты как-то Mediator пользуешься, нет?
6641.42 6648.90 "Анатолий Кулаков" Нет, нет, обхожусь. Ну в принципе, концепция понятна, я концепцию саму переиспользую, но этой библиотечке для меня слишком избыточна. Ну в общем, вот если вы
6648.90 6679.70 "Игорь Лабутин" вдруг пользуетесь Mediator, посмотрите, там прям как-то Джимми Богвард, который автор библиотеки, написал, что там прям как-то очень много breaking changes, там поменялись таргетинг, нет стандарт 2.1, 2.0, там вот это всё. В общем, если пользуетесь, гляньте, видимо, он как-то очень старался готовить этот релиз, раз прям там не такие большие эти change, как-то change, change, change, change, лог, короче, новые версии, но фраза про то, что contains many breaking changes намекает на то, что возможно какие-то существенные изменения в библиотеке произошли.
6679.70 6687.86 "Анатолий Кулаков" Отлично, ну что ж, да, давай закругляться, вроде хорошо посидели. Прекрасно.
6687.86 6689.82 "Анатолий Кулаков" Давай посмотрим, что мы сегодня покрыли.
6689.82 6715.86 "Игорь Лабутин" Да, что мы покрыли. Мы покрыли дотнет 8 превью 1, уже который раз говорю я, наконец-таки мы дождались превью, будет здорово. Мы прослушали лекцию от Анатолия про криптографию в дотнете, про то, какие бывают, ну на самом деле сначала про криптографию в целом, да, симметрично-асимметричное шифрование, там, подписи и вот это все, каширование, а потом как это все применять в дотнете, куда посмотреть, если хочется копать поглубже.
6715.86 6743.74 "Игорь Лабутин" Узнали род мапы на ближайший год от основных фреймворков поверх дотнета, в нужности которых входят в дотнет, так сказать, платформу. Выяснили интересный способ того, как попробовать не раскрыть свои секреты в логах, там, сериализации или еще где-то через хитрую систему классиков. Посмотрели начало первую статью в блоге Microsoft про то, что такое вообще дотнет и что он из
6743.74 6749.30 "Анатолий Кулаков" себя сейчас представляет. Хороший вопрос к 67 выпуску наконец-то, мы задались вопросом, а что же такое
6749.30 6798.90 "Игорь Лабутин" дотнет-то? Да мы-то ладно, мы сколько, 67 выпуск всего, Microsoft его уже пилит столько лет. Не первый десяток уже? Ну ладно, с десяток, я бы, я не удивлен, что такой статьи не было там про дотнет-фреймворк, ну она была в каком-то виде, но не это самое. Но вот кажется, что это тот тип статей, которые нужно было выпускать там в каком-то 14-м году, когда дотнет-кор только начинал выходить. Вот тогда. Ну да, именно так. Вот. Но тем не менее, хорошо, лучше поздно, чем никогда. Будем посмотреть, что из этого получится. Посмотрели на Visual Studio 2022, новая версия 17.5 и для Mac тоже. Ну и подкаст под лодку про дотнет в моем исполнении. И красненькие новости про то, что еще произошло в мире дотнета.
6798.90 6803.62 "Игорь Лабутин" На этом кажется, что можно точно заканчивать. Прекрасно.
6803.62 6810.54 "Анатолий Кулаков" Большое спасибо, друзья, что нас поддерживаете, слушаете, особенно если вы дослушали до этого места.
6810.54 6821.02 "Анатолий Кулаков" До встречи, до встречи в новых выпусках, пишите нам комментов побольше, какие темы вам нравятся и какие не нравятся, стоит ли загоняться по глубоким и долгим темам, или лучше мелких и быстрых поверхностных.
6821.02 6826.70 "Анатолий Кулаков" В общем, все это пишите, мы все комментарии обязательно читаем, отвечаем, учитываем. И ваш фидбэк очень важен
6826.70 6833.74 "Игорь Лабутин" для нас. А на этом все. С вами были Игорь Лобутин и… И Анатолий Кулаков. Всем
6833.74 6836.78 "Анатолий Кулаков" спасибо, всем пока. Всем пока. Пока.
6836.78 6848.54 None До новых встреч!
6848.54 6853.62 None [музыка]
