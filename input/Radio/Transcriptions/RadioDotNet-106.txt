0.00 13.12 "Анатолий Кулаков" Приветствую, дорогие слушатели, в эфире Радио.нет, выпуск 106 и его постоянный ведущий Анатолий Кулаков.
13.12 14.56 "Игорь Лабутин" И Игорь Лабутин, всем привет.
14.56 18.84 "Анатолий Кулаков" Также вместе с нами наши великолепные помогаторы.
18.84 35.60 "Анатолий Кулаков" Итак, друзья, большое спасибо вам, в частности, Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артомонов, Сергей Бензенко, Лазарев Илья, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Андрей Фазлеев, Дмитрий Павлов, Постарнаков Андрей, Дмитрий Сорокин, Александр Ерыгин.
35.60 39.04 "Анатолий Кулаков" Всем спасибо, а также тех, кто поддерживает нас на Boosty.
39.04 44.88 "Анатолий Кулаков" Поэтому, если вы еще не среди них, задумайтесь, может, пора стоит уже, там, к Новому году, нужные пельчинки, кефирчик, вот это все.
44.88 60.12 "Анатолий Кулаков" Кстати, мы что-то посмотрели, что наши новогодние выпуски, в которых мы болтаем обо всем подряд, а не только о новостях, набирают мало просмотров на YouTube, поэтому решили в этом году такого беспредела не делать, раз вы любите новости, останемся в этом формате, будем делать новости.
60.12 97.20 "Анатолий Кулаков" А вот такие выпуски на разные темы, о жизни и о том, о чем мы, в принципе, проводим с нашими патронами, и, наверное, этот новогодний выпуск тоже проведем вместе с нашими патронами, там, подключим всех, кого не… кто захочет прийти поболтать, поэтому, если вы вдруг хотите поучаствовать или хотите послушать подобный новогодний выпуск, то присоединяйтесь как раз к этому дружному коллективу, там же можно будет поговорить не только о новостях, не только о интернете, а о много других интересных темах, как-нибудь мы вам расскажем, чем мы там занимаемся, но, наверное, не сейчас.
97.20 110.40 "Анатолий Кулаков" Сейчас у нас будет нормальный стандартный выпуск, подготовились интересные хорошие новости, в принципе, много таких прям новогодних… на что нам надо поболтать, да, много там интересных анонсов, в общем, выпуск должен быть хорошеньким, жарким.
110.40 116.60 "Игорь Лабутин" Да, но при этом новогодним это будет последний выпуск в этом году, следующий уже ждите после Нового года.
116.60 120.12 "Игорь Лабутин" А пока поехали, начнём… Кстати, да, не будем зарекаться,
120.12 123.20 "Анатолий Кулаков" что он будет маленький, потому что мы в прошлый раз как-то зареклись, а не получилось.
123.20 126.04 "Анатолий Кулаков" Поэтому тоже будем стараться, но ничего не обещаем.
126.04 128.16 "Игорь Лабутин" Да не будем мы стараться, как пойдёт.
128.16 129.84 "Игорь Лабутин" Или даже не будем стараться.
129.84 135.76 "Игорь Лабутин" Да, мы с тобой только что час поговорили перед выпуском, поэтому размялись нормально, можно теперь 2 часа здесь поговорить.
135.76 144.68 "Анатолий Кулаков" Итак, новость номер 1… Подожди, подожди, тут хорошая вставочка идёт, если вы хотите знать, о чём мы разговариваем перед выпусками, то опять же есть прешоу, которые доступны всем на Boosty.
144.68 151.88 "Игорь Лабутин" Да, но не все они записываются, к сожалению, или к счастью для нас, не знаю, не все наши разговоры перед выпуском записываются и выкладываются.
151.88 153.32 "Игорь Лабутин" Ну ладно, вернёмся к новостям.
153.32 155.36 "Анатолий Кулаков" Да, не все мы выкладываем.
155.36 163.20 "Игорь Лабутин" Новость на самом деле довольно старая, в смысле что она вышла практически вместе с основным релизом 9 дутнета.
163.20 171.04 "Игорь Лабутин" Это драйвер для EF Core для Postgre, который NPG SQL, который наверняка все знают, кто пользуется Postgre и EF Core.
171.04 184.92 "Игорь Лабутин" Он был в… я не помню, как это называлось, там, бета или превью или что-то на момент релиза, прямо на момент dotnet.conf, потому что там были некоторые проблемы, которые нужно было завершить и дофиксить, чтобы объявить полноценный релиз.
184.92 188.60 "Игорь Лабутин" Вот он был объявлен, и мы наконец добрались до этой новости.
188.60 204.96 "Игорь Лабутин" Значит, напомню, что для того, чтобы работать с разными базами данных, EF Core использует разные всякие провайдеры, то есть это некоторые адаптеры, которые адаптируют нежележащую базу данных к… ну, собственно, к нейтральнке интерфейсом Entity Framework, внутренним интерфейсом его.
204.96 251.40 "Игорь Лабутин" При этом NPG SQL, EF-ный провайдер, он основывается на NPG SQL ADO.NET провайдере, и ранее вы могли, ну и сейчас на самом деле можете, конфигурить отдельно EF Core-ные настройки NPG SQL и отдельно дополнительно настраивать ADO.NET, а иногда вам нужно было прям обязательно настраивать ADO.NET-ные настройки, чтобы все нормально работало, потому что часть работы делается не в EF Core-ной части, EF Core-ная часть, она, понятно, ответственна за то, чтобы конвертировать всякие EF Core-ные штуки в синтаксис SQL, а непосредственно за выполнение запросов, за маппинг данных, например, отвечает ADO.NET-ная часть, за маппинг типов имеется в виду и так далее.
251.40 255.72 "Игорь Лабутин" Поэтому часть настроек, она была необходима на уровне ADO.NET.
255.72 266.32 "Игорь Лабутин" Теперь у вас есть, ну и была функция use_npg_sql, с помощью которой вы подключаете EF на провайдер, и с помощью нее конфигурите вообще все, что нужно.
266.32 280.64 "Игорь Лабутин" То есть там, туда теперь передается одна лямбдочка, в которой конфигурится, и в эту лямбдочку передается объект, у которого есть, если что, билдер для ADO.NET-ного, ADO.NET-ной части, в которой можно дополнительно передать какие-то доп.настройки еще внутри.
280.64 289.18 "Игорь Лабутин" То есть вы можете вызвать там внутри ConfigureDataSource, и внутри уже конфигурить еще и DataSource ADO.NET-ный.
289.18 296.88 "Игорь Лабутин" Внутри EF-ный драйвер, соответственно, сам все по дефолту настроит как надо, но если очень хочется, то можно все это подтюнить.
296.88 303.04 "Игорь Лабутин" Не нужно отдельно создавать mpg_sql_datasource, как это было нужно раньше делать, если вы хотели его как-то отдельно настроить.
303.04 304.04 "Игорь Лабутин" Дальше.
304.04 307.88 "Игорь Лабутин" Улучшили конфигурацию enums и вообще разных плагинов.
307.88 309.56 "Игорь Лабутин" Что такое плагины?
309.56 324.72 "Игорь Лабутин" Плагины — это довески, некоторые кусочки модулей, которые позволяют вам дополнить основной драйвер, основной провайдер, знанием про какие-то собственные дополнительные классы.
324.72 348.16 "Игорь Лабутин" Примером таким является плагин для NodaTime, то есть если вы используете у вас в коде NodaTime для работы с датой и временем, то естественно нужно как-то EF-корный провайдер обучить тому, как конвертить обычные DateTime колонки из PathGrid в NodaTime VT, потому что стандартный EF-корный провайдер умеет только в типы из базовой библиотеки конвертить все.
348.16 350.24 "Игорь Лабутин" Вот для этого нужен этот плагин.
350.24 358.64 "Игорь Лабутин" Также вы можете настраивать то, как конвертить enums, вы там можете захотеть их числами, строчками, еще как-то по-разному конвертить.
358.64 366.96 "Игорь Лабутин" Раньше это требовало довольно много разных приседаний и на уровне addonet, и на уровне EF-провайдера mpg_sql.
366.96 371.80 "Игорь Лабутин" Теперь достаточно все делать на уровне самого EF-а.
371.80 383.20 "Игорь Лабутин" Просто вы вызываете определенные функции, там map_enum или соответствующие кусочки плагинов от плагина, и все само работает, само сконфигурит как надо.
383.20 384.20 "Игорь Лабутин" Дальше.
384.20 423.36 "Игорь Лабутин" Если вы используете GUID, то в базе данных, то вы наверное знаете, и мы, кстати, про это, по-моему, делали, мне кажется, отдельную новость, про то, что SystemGUID теперь поддерживает UUIDV7, и это более качественный вариант, более хороший вариант для использования в базе данных, особенно если вы используете эту колонку с GUID, или с UUID, точнее, как это по сгревовой нотации называется, для индексов, потому что UUIDV7, он все-таки сортированный, по времени там есть кусочек, который ответственный за таймстэмп, причем он в начале, и за счет этого получается натуральная более-менее сортировка, и таким образом новые записи добавляются в среднем в конец.
423.36 434.76 "Игорь Лабутин" Так вот, UUIDV7 теперь используется по умолчанию для генерации тех самых UUID, и если нужно, это поведение можно отключить через настройки провайдера, но вообще говоря, не рекомендуется.
434.76 458.76 "Игорь Лабутин" Ну и еще улучшили, понятно, там много всяких разных мелких улучшений, в основном вокруг трансляции SQL в EF, соответственно, UNQ, обратно и в трансляции типов, например, разгревы JSON Path теперь нормально мапятся в датанетной обычной строчке, что позволяет вам запросы на них строить, если очень надо.
458.76 463.56 "Игорь Лабутин" Но девятый релиз не зря мажорный, в нем есть breaking change.
463.56 476.56 "Игорь Лабутин" Breaking change как раз касается тех самых маппингов UNUM-ов, они теперь обязаны быть на уровне EF Core, ну то есть на уровне конфигурации NPG SQL EF-ного провайдера, а не ниже.
476.56 492.28 "Игорь Лабутин" Раньше нужно было либо это конфигурить на уровне NPG SQL Data Source, то есть ARDUNET-ного провайдера, надо было там вызывать функцию mappinum, или даже еще глубже, на уровне NPG SQL Connection, там можно было в Global Type Mapper вызвать mappinum.
492.28 504.56 "Игорь Лабутин" Теперь наоборот все сделается, то есть теперь вы конфигурируете на уровне EF провайдера, а он сам сконфигурит все нижележащие слои, как ему нужно, все будет хорошо.
504.56 520.52 "Игорь Лабутин" И как я понял, именно вот эта проблема, именно эти breaking changes, допиливание всяких полирования проблем вокруг их breaking changes как раз и послужила причиной тому, что все немножко подзадержалось по сравнению с обычным выходом 9-го дотнета.
520.52 521.52 "Анатолий Кулаков" Как-то так.
521.52 527.34 "Анатолий Кулаков" Ну как я понял, это самый breaking changes в этом большом релизе.
527.34 533.04 "Игорь Лабутин" Да, там наверняка есть еще, но именно он был прям единственный обозначен в релиз ноутсах.
533.04 534.04 "Игорь Лабутин" Да, да.
534.04 543.00 "Анатолий Кулаков" А тут, наверное, просто стоит сказать, что никаких проблем, если вы там маппили обычные enums, здесь у вас ничего не изменится, здесь у вас ничего не breaking и не changes.
543.00 544.68 "Анатолий Кулаков" Речь идет именно о enums на уровне PostgreSQL.
544.68 549.84 "Анатолий Кулаков" То есть у PostgreSQL есть такой тип данных, который называется, не поверите, тоже enum.
549.84 554.20 "Анатолий Кулаков" Вы можете на уровне Postgre объявить enum, который можете использовать в своих Postgre табличках.
554.20 558.00 "Анатолий Кулаков" В общем, грубо говоря, никакого отношения к нашим дотнетовским enum нет.
558.00 559.60 "Анатолий Кулаков" Не, ну не связаны они были.
559.60 569.28 "Анатолий Кулаков" То есть вы их можете связать, как вот рассказал Игорь, но в принципе я ни разу не видел, чтобы кто-то использовал реально связь с настоящими нативными Postgre'овыми enum'ами.
569.28 580.12 "Анатолий Кулаков" Обычно enum'ы все-таки конвертятся в строчку, складываются в Postgre в обычную колонку со строковым значением и децерализуются оттуда, как строка, и все, и этого хватает в 100% случаев.
580.12 586.44 "Анатолий Кулаков" Поэтому мне таких случаев неведомо вообще, поэтому для кого из нас это будет breaking changes, я представить даже не могу.
586.44 592.22 "Игорь Лабутин" Ну, наверное, есть такие люди, есть такие проекты, где это, возможно, по каким-то историческим причинам было сделано.
592.22 608.92 "Игорь Лабутин" То есть я могу представить, что если ты взял какую-нибудь унаследованную BD, которая, не знаю, была на хранниках написана, еще на чем-нибудь, хотя я в Postgre такой сильно не видел, но почему нет, вот, и над этим сверху написал дотнетный код, который вынужден теперь работать вот с такими enum'ами.
608.92 620.92 "Анатолий Кулаков" Ну да, да, просто видишь, я когда прочитал там первый заголовок, что breaking changes, enum'ы не поддерживаются или переделываются, я думал, да, вот сейчас пойдем мигрировать как бы на полгода все наши запросики.
620.92 625.34 "Анатолий Кулаков" Оказывается, нет, в принципе, это вообще не затрагивает в основном никого никогда нигде.
625.34 626.34 "Игорь Лабутин" Да.
626.34 641.52 "Игорь Лабутин" Ну вот такая штука про NPG SQL и Postgre, также вторая новость, она не то чтобы сильно новость, потому что это речь идет про MongoDB, EF Core Provider.
641.52 696.14 "Игорь Лабутин" Сам по себе он был залилижен, ну какой-то первый релиз, что-то около полугода назад, мне кажется, какие-то первые были уже нормальные версии его, но тут видимо под релиз дотнет девятого вышла небольшая статья в блоге Майкрософта о том, в дотнетном блоге Майкрософта, видимо, чтобы напомнить, что он такой есть, ну и кратенько давайте пробежимся, что ж такое MongoDB Provider и зачем он вообще нужен и в чем с ним проблема, ну основная проблема с ним понятно в чем, EF Core в каком-то смысле, ну не то чтобы создавался конкретно для реляционных баз данных, но в общем довольно сильно на них опирается, плюс мы же все-таки используем linq-синтакс, который новей в каком-то смысле с SQL, и понятно, что он один в один на прям вот такие no-SQL базы данных как Mongo может быть не идеально ложится, но
696.14 697.14 "Анатолий Кулаков" тем не менее.
697.14 703.22 "Анатолий Кулаков" Лично с другой стороны он довольно, linq-синтакс он довольно объектно-ориентированный, а вот в объектно-ориентированности она довольно хорошо ложится в Mongo.
703.22 743.34 "Игорь Лабутин" То есть тут как бы есть и то, и другое, в итоге как бы понятно, что ребята подумали, решили, что ну вроде ложится нормально, давайте сделаем, и сделали, и действительно нормально плюс-минус работает, то есть напомню, что в no-SQL базы данных, ну по крайней мере в Монге, основа, центральная сущность хранения это документ, то есть это некоторый по сути произвольный набор свойств, пар, ключ, значения, как хотите, смотрите, просто некий документ без какой-то предопределенной схемы, и у вас в разных документах технически могут быть абсолютно разные вообще говоря свойства, даже если эти документы хранятся в одной единой коллекции.
743.34 753.58 "Игорь Лабутин" Как правило, конечно они, ну скажем так, чем-то похожи, да, и наверное чем-то подобные, может быть даже можно было бы на это дело навернуть схему, но как правило так никто не делает.
753.58 754.58 "Игорь Лабутин" Вот.
754.58 767.74 "Игорь Лабутин" В EF Core, соответственно, вы же все равно объявляете ваши какие-то классы, вы туда запихиваете какие-то проперти, и дальше EF Core пытается мапить эти проперти на свойства документа, которые хранятся в коллекции.
767.74 793.70 "Игорь Лабутин" Для того, чтобы эти свойства добавлять, в смысле объявлять, вы используете специальный атрибутик bsone-element, ну и с названием, соответственно, свойства, и вот как раз в статье указано, что даже если вы, например, добавите новое свойство, добавить его, естественно, лучше только nullable вариантом, потому что если вы добавите его не nullable, то не очень понятно, как будут децерализовываться документы, в которых этого свойства никогда и не было.
793.70 828.98 "Игорь Лабутин" Но если вы добавите nullable, то и старые документы, например, в которых этого свойства не было, и новые документы, в которых это свойство есть, прекрасно будут децерализовываться, и более того, EF Core, я подозреваю, что как бы не уверен, что прям специально обучили, но кажется, что, может быть, там нужны были некоторые дополнения, довольно неплохо работает с вариантом, то мы загрузили документ, в котором этого свойства не было, поменяли, и change tracking внутри EF Core прекрасно это понимает и выполнит правильные запросы по обновлению правильного документа с правильным, нормальным значением свойства.
828.98 873.58 "Игорь Лабутин" Также вы можете создавать индексы, не то чтобы здесь есть какая-то специфика EF Core, потому что используется вполне себе кусочек, грубо говоря, Mongo Client, то есть нет какого-то прям EF Core специфики, вы делаете client, get database, get collection, указываете название коллекции, после чего создаете, соответственно, объект под названием createIndexModel, ну и вызываете, собственно, на коллекции индексов метод createOneAsync, передавая туда тот самый createIndexModel, то есть непонятно, что делать в EF Core, как бы в EF Core мы так обычно, что-то я не помню, что мы так индексы создавали, то есть это миграция, и внутри миграции это делается.
873.58 898.74 "Игорь Лабутин" Но тем не менее, в точке зрения получения данных, как ты правильно сказал, linq в целом плюс-минус работает, и опять же, по-моему, там были какие-то исключения, что не все методы могут быть замаплены нормально, или сейчас, по крайней мере, в текущей версии, на mongodb-шный синтаксис, но базовые основные, там вся qr, понятно, first и вот это вот все, нормально мапится.
898.74 916.66 "Анатолий Кулаков" Я думаю, это справедливо даже к SQL коннекторам, потому что не все linq-шные методы поддерживаются всеми SQL-провайдерами, поэтому тут, как мы уже обсуждали, эта абстракция, она очень сильно течет, поэтому вам точно нужно знать, к какой базе данных вы обращаетесь, когда пишете linq-запросы.
916.66 929.98 "Игорь Лабутин" Да, ну в общем, можете писать нормальные linq-методы, как обычно, оно будет транслироваться в монговские запросы, нормально выполняется, можно эти запросы полагировать, там, если правильно настроить EF Core, он будет выплевывать уже монговские запросы, которые он формирует.
929.98 966.86 "Игорь Лабутин" Ну и, несмотря на то, что в no-SQL базы данных, в монго, в частности, как правило, не сильно речь идет о всякой транзакционности и так далее, но если вам нужно, то монго это поддерживает, и, соответственно, EF Core тоже, то есть по дефолту SafeChanges и SafeChanges.sync пытаются быть транзакционными, то есть либо у вас все сохранится, либо не сохранится, и так же поддерживается работа с Optimistic Concurrency с помощью двух методов, то есть либо через RawVersions, либо через ConcurrencyCheck.
966.86 1039.78 "Игорь Лабутин" Ну RawVersions, понятно, он просто сверяет, ну не timestamp, а версию записи, версию документа, каждый раз увеличивая ее на единичку, и если они не совпали, то считается, что вы обновляете документ, который уже обновился и, соответственно, нужно выкинуть исключение, и вы сами будете думать, что с ним делать, но ConcurrencyCheck — это, соответственно, некая проверка уникального токена, более-менее уникального-рандомного токена, делается через атрибут ConcurrencyToken, а RawVersions — через атрибут Timestamp, и несмотря на то, что он Timestamp, типа там long, в общем, такая вот забавная штука, можно все это выключить, транзакционность, по крайней мере, есть, прям специальное свойство, AutoTransactionBehavior, можно сказать never, и он, соответственно, будет нормально работать уже без тогда попыток сделать транзакционность, если она вам не нужна, скорее всего, я бы ее выключил, потому что, ну, я думаю, что она оказывает некоторую влияние на перформанс, я, честно говоря, особо не пробовал, с Монгой я из Дотонета никогда не работал, был опыт чуть-чуть из других, так скажем, ну я в основном, давайте так, я в основном туда ходил просто клиентом посмотреть, что в ней лежит, к точке зрения программиста я с Монгой как-то особо не сталкивался, поэтому сильно детальнее ничего тут рассказать не смогу, но приятно, что я Concur поддержал.
1039.78 1074.62 "Анатолий Кулаков" – Ну, во-первых, разработчиков, так как они перевели свои, как сказать, блин, свои привычки, да, SQL-ного мира, где всегда есть транзакция, явная, неявная, неважно, вот они перевели ее на как раз документно-ориентированную базу данных, которой, в принципе, обычно как раз такие транзакции не используются, то есть здесь, мне кажется, вот они ошибку немножко сделали, они, может, конечно, рассчитывали на то, что юзеры будут переходить и для них этот экспириенс должен быть какой-нибудь максимально гладкий, но концептуально они поступили неправильно, потому что концептуально все-таки по дефолту нет там никаких транзакций, а они видишь концептуально… – Нет, ну подожди, Монга поддерживает.
1074.62 1075.62 "Анатолий Кулаков" – …транзакция есть.
1075.62 1082.78 "Анатолий Кулаков" Поддерживает, но обычно не пользуются юзеры транзакциями по умолчанию, в отличие от реляционных баз данных.
1082.78 1085.14 "Анатолий Кулаков" – Ну да, но тем не менее… – Тут два разных подхода.
1085.14 1089.94 "Анатолий Кулаков" – Тем не менее, в принципе… – Опять же, они там появились в Монге даже совсем недавно, эти транзакции относительно,
1089.94 1090.94 "Игорь Лабутин" самой Монге.
1090.94 1100.10 "Игорь Лабутин" – Ну да, но есть, поэтому если есть, чего бы не поподдерживать, тем более, я думаю, что со стороны ЕФа, скорее всего, это не сильно дорого было бы.
1100.10 1102.78 "Анатолий Кулаков" – Не знаю, мне кажется, просадка какая-нибудь будет.
1102.78 1103.78 "Анатолий Кулаков" – Да наверняка.
1103.78 1104.78 "Анатолий Кулаков" – Транзакции просто так не даются.
1104.78 1105.78 "Анатолий Кулаков" – Конечно, конечно.
1105.78 1110.86 "Анатолий Кулаков" – Поэтому вот тебе ответ, разработчики на Монге обычно транзакциями не пользуются, а ты взял им на пустом месте и сделал просадку.
1110.86 1113.14 "Игорь Лабутин" – Да Монга быстро вывезет, не переживай.
1113.14 1123.30 "Игорь Лабутин" В общем, вот такие новости про ЕФ-кор, обычно у нас как-то их маловато, тут про ЕФ поднакопилось, решили их всех вместе выкинуть.
1123.30 1128.10 "Игорь Лабутин" Но это не последний релиз, про который мы хотим рассказать, а есть у нас еще про релизик.
1128.10 1171.30 "Анатолий Кулаков" – Ну, даже не релизик, как-то ты скромный, это релизище, потому что зарелизился прямо вот буквально третьего дня X-Unit, X-Unit версии 3, и это просто мега событие, даже намного больше событий, наверное, чем релиз всего дотнета, потому что третий X-Unit мы ждем как минимум с 2018 года, сколько, 6 лет, 6 лет мы ждали третий X-Unit, то есть все, весь тот прекрасный фрейворк, который завоевал весь мир тестирования, он, грубо говоря, рассчитывает, что он устарел там 6 лет назад, да, то есть уже авторы поняли 6 лет назад, что нам нужна какая-то новая версия, которая будет вот все, наше все, на котором все будет работать и все будут счастливы.
1171.30 1198.62 "Анатолий Кулаков" И вот где-то с тех самых пор там было очень много изменений, очень много каких-то предложений, дизайн-ревью и всего прочего, ну и если честно, я от него ожидал гораздо больше, чем вышло, но вышло тоже неплохо, поэтому давайте посмотрим, что же такого нас ждет в X-Unit третьем, на чем мы, то есть зачем мы будем переписывать в следующий год все наши юнит-тесты, которые только есть в нашем проекте, во всех наших проектах, безусловно.
1198.62 1242.24 "Анатолий Кулаков" X-Unit это прекрасно, это тестовый фрейворк, который мегапопулярный и это, наверное, самый популярный POP сейчас с фреймворк по скачиванию на Nougeti, раньше он делил место с N-Unit, но вроде сейчас немножко перегнал, но там, опять же, у них паритет обычно, то есть может быть такой же популярный, безусловно, поэтому, скорее всего, каждый разработчик с ним должен сталкиваться, мне кажется, этот фреймворк даже популярнее, чем ISP и Entity Freework, потому что ISP не у всех есть, а тесты, скорее всего, есть у всех, даже у вашего консольного приложения какого-нибудь, должны быть тесты, так что после .NET Framework окажется, что это самый популярный фреймворк, который только может быть, вот почему эта новость вызывает у меня столько радости и восторга.
1242.24 1249.26 "Анатолий Кулаков" Давайте же разберемся, а что уж нам, собственно, такая большая мажорная третья версия, которая делалась без малого шесть годков, то нам готовит?
1249.26 1266.62 "Анатолий Кулаков" Ну, если заспейлилить, то ничего такого страшного брекни-ченчиза не будет, то есть все ваши текущие тесты, если они написаны без всякого extensibility и извращения, они легко перенесутся один в один, как бы, просто подменой пакета, это так, чтобы вы просто не волновались, а теперь пойдем по подробностям.
1266.62 1367.04 "Анатолий Кулаков" Прежде всего, осталась поддержка .NET версий только 4.7.2 большого фреймворка или позже, и .NET 6 или позже, и также стандарт 2.0, то есть если у вас какой-нибудь старый .NET, типа 3.0, 5.0, то уже вы не сможете использовать третий XUnit, вам придется пока на втором оставаться, но эта возможность, то есть когда авторы отказались от более-менее старых уже фреймворков, ну, по сути, неподдерживаемых фреймворков, эта возможность дала им очень сильно почистить код, они там поудаляли просто тонну legacy кода, и естественно, кодовая база стала быстрее, понятнее, красивше и все такое, поэтому это ограничение, конечно, может быть для многих и страшное, но в целом позитивно для всего сообщества, и опять же, вторая версия никуда не девается, она поддерживается, патчится, поэтому можно ей пользоваться без всяких проблем, также поддерживается только новый SDK style проекты, если кто не помнит, то у нас раньше были проекты, в которых перечислены все cs-файлики, которые вы должны были закомпилить, в общем, какой-то страшный и лютый ужас там творился, и SDK проекты, которые появились в принципе относительно недавно, они там с .NET Core появились, мне кажется, они прям сразу захватили умы человечества, и все, что только можно было перевести на них, было на них переведено в нормальных компаниях, потому что boost очень большой от них, сразу исчезали все межконфликты, сразу файлы становились читаемыми, переиспользуемыми, в общем, много всего интересного появилось, как только SDK style проекты вошли в нашу жизнь, поэтому, мне кажется, тоже здесь особых проблем нет, все, кто молодец, тот перевел, а кто не молодец, те пусть пользуются ранними версиями.
1367.04 1388.92 "Анатолий Кулаков" Заблокировали использование Async/void тестов, это тоже вообще мегабигдил, потому что почему-то до сих пор разработчики никак не могут понять, что Async/void это плохо, и использовать его практически никогда не надо, и даже в тестах я часто встречал такие вещи, как Async/void, и было бы неплохо, если бы XUnit просто бил за это по-разному, по рукам к топорам.
1388.92 1405.84 "Анатолий Кулаков" В общем, теперь будет он это делать, поэтому Async/void больше не поддерживается, напомню, что Async/void прекрасно меняется на обычный Task или в третьем ValueTask, вы можете заменить на Task или ValueTask и продолжать делать асинхронные тесты без всяких каких-то проблем.
1405.84 1441.92 "Анатолий Кулаков" Немножко изменилась модель запуска, что имеется в виду, если раньше во второй версии раннеры загружали себе библиотечки с вашими тестами в свой In-M-Space, и там их запускали, в свое адресное пространство, и эта технология, она вся пошла из большого .NET Framework, может кто-то помнит, у нас в большом .NET Framework были такие прекрасные штуки, как Application Domains, Абдомены, и эти Абдомены как раз-таки разрабатывались для того, чтобы независимо, изолированно загружать какую-то песочницу, какую-то среду, и именно в эту песочницу загружались сборки с вашими тестами и там исполнялись.
1441.92 1452.32 "Анатолий Кулаков" Но когда мы переехали на .NET Core, все Абдомены быстренько отменили, сказали, что это больше не хорошо, и поэтому в Core-овских библиотеках уже не так одозначно, что нам нужно делать.
1452.32 1464.14 "Анатолий Кулаков" Ну и вот как 3XUnit, он же как по приверженности всего Cora, он у себя тоже эти Абдомены отменил и прекратил загружать в единое адресное пространство различные тесты, а сделал намного проще.
1464.14 1470.24 "Анатолий Кулаков" Он сделал отдельный экзешник, в который этот экзешник грузит уже ваши библиотеки, ваши тесты и запускает их.
1470.24 1482.52 "Анатолий Кулаков" Таким образом, во время билда, сейчас, у нас порождаются не только .dll, как было раньше, но также порождаются .exe файл, который вы можете просто-напросто откнуть и он запустит вам ваши тесты.
1482.52 1489.80 "Анатолий Кулаков" Вот, это тоже небольшое изменение, которое в принципе скорее всего на обычных пользователях никак не повлияет.
1489.80 1493.12 "Анатолий Кулаков" Это больше интересно для всяких людей, которые расширяют тестранер.
1493.12 1498.32 "Анатолий Кулаков" В общем, для расширения там тоже много всего интересного появилось.
1498.32 1499.32 "Анатолий Кулаков" Пойдем дальше.
1499.32 1500.68 "Анатолий Кулаков" Что нужно делать для миграции?
1500.68 1509.24 "Анатолий Кулаков" Ну, на самом деле, самое, наверное, заметное изменение, которое случилось в плане миграции, это изменение имен.
1509.24 1518.48 "Анатолий Кулаков" Теперь, если раньше у вас были пакеты, которые назывались там xunit или xunit.assert, то теперь они стали называться xunit.v3, xunit.v3.assert.
1518.48 1526.60 "Анатолий Кулаков" То есть, вместо xunit, стал называться xunit.3.
1526.60 1532.84 "Анатолий Кулаков" И очень много namespaces поменялось, не только в связи с этим, но в связи с этим в том числе.
1532.84 1538.16 "Анатолий Кулаков" И тут, наверное, интересно разобрать этот аспект поподробнее.
1538.16 1545.08 "Анатолий Кулаков" Почему xunit пошел по пути того, что не стал придерживаться semantic version, ну, то есть, по сути, что он должен был сделать?
1545.08 1551.48 "Анатолий Кулаков" Он должен был увеличить мажорную версию просто-напросто своего пакета и пойти точно так же называться дальше xunit.
1551.48 1558.84 "Анатолий Кулаков" По факту он сменил имя продукта, то есть, если раньше это был продукт, который назывался xunit, теперь это продукт, который называется xunit.v3.
1558.84 1570.12 "Анатолий Кулаков" И дальше у этого xunit.v3 уже пошло свое какое-то семантическое версионирование, которое вполне может пересекаться с теми версиями, которые были у простого xunit, а может и продолжить.
1570.12 1572.20 "Анатолий Кулаков" Как бы здесь тоже больших проблем нет.
1572.20 1576.12 "Анатолий Кулаков" Почему же авторы пошли на столько нестандартный шаг?
1576.12 1579.04 "Анатолий Кулаков" Давайте посмотрим их объяснение.
1579.04 1593.64 "Анатолий Кулаков" Ну, прежде всего, они сказали, что мы хотим сделать так, чтобы выбор разработчиков был очень осознанным, чтобы вы не просто нажали где-то update, и Visual Studio вам сама обновила все пакетики, и вы радостно пошли дальше.
1593.64 1606.28 "Анатолий Кулаков" Они захотели так, чтобы вы удалили старый продукт, старый пакет, и поставили новый пакет, совсем под другим названием, чтобы вы осознавали точно, что вы делаете.
1606.28 1619.56 "Анатолий Кулаков" По-моему, аргумент притянут за уши, потому что совместимость практически 100% на пользовательском коде, то есть совместимость очень большая, и даже если вы автоматически про-updated, ничего страшного с вами не случилось.
1619.56 1625.80 "Анатолий Кулаков" Ну и как бы мажорная версия намекает, что если что-то и поломалось, то вы сами updated, сами молодцы.
1625.80 1637.36 "Анатолий Кулаков" И все проблемы, которые бы у вас возникли, скорее всего, они бы решились на уровне компилятора, потому что никаких таких breaking changes, которые компилятор бы проглотил, оно пошло бы работать по-другому, здесь нет.
1637.36 1639.44 "Анатолий Кулаков" То есть все проблемы выловились бы на уровне компилятора.
1639.44 1642.52 "Анатолий Кулаков" В общем, аргумент кажется какой-то левой отмазкой.
1642.52 1645.08 "Анатолий Кулаков" Вообще не для этого, вообще не для того.
1645.08 1660.52 "Анатолий Кулаков" Второй аргумент, который они приводят, это то, что их очень часто просили сделать так, чтобы XUnit придерживался симвера, семантического версионирования, но это было невозможно, по той причине, я не понял по какой причине.
1660.52 1683.88 "Анатолий Кулаков" То есть они говорят, что в старой версии, когда мы начали это версионировать, у нас версия продукта включалась в семантическую версию, это было плохо, в мажорную версию семантического продукта, а вот в новой версии пакета, вот эта продуктовая версия, она уже в мажорную версию не включается, она уже включается в версию продукта, как я уже сказал, отдельное имя пакета v3.
1683.88 1691.84 "Анатолий Кулаков" И именно поэтому мы теперь можем начать следовать семантическому версионированию так, как нас просили много лет.
1691.84 1705.44 "Анатолий Кулаков" Вообще непонятная причина, то есть почему не старую версию с мажорной версии 2 не могли переименовать в мажорную версию 3, там следовать чему угодно, чему следует, я не понял, я не распарсил.
1705.44 1721.20 "Анатолий Кулаков" Если у вас есть какие-то соображения по этому поводу, напишите нам обязательно в комментариях, или может бы вы участвовали во внутренней переписке xUnit, где автор обсуждал это более подробно или более конкретно, или вы знаете статью, где это лучше обсуждается, обязательно скажите.
1721.20 1738.88 "Анатолий Кулаков" Потому что прецедент на самом деле очень интересный, я на самом деле сталкивался у себя на проектах, где хотелось бы сделать именно такое, то есть прям занести версию в имя продукта, но здесь я не вижу этих предпосылок и очень интересно, что это за такая ситуация.
1738.88 1759.72 "Анатолий Кулаков" Авторов xUnit нельзя назвать мега глупыми людьми, то есть эти люди подходят к архитектуре, к структуре, к проектированию очень серьезно, ну за исключением iOutput Helper может быть, но в общем очень серьезно, поэтому скорее всего здесь есть какой-то интересный грааль, до которого хотелось бы докопаться, поэтому если у вас есть сведения, обязательно напишите, мне было бы интересно узнать.
1759.72 1779.88 "Анатолий Кулаков" И после, еще третье, третье у них есть обоснование, зачем они на такое извращение пошли, они говорят, что мы очень много пакетов смержили, некоторые пакеты появились новые, некоторые пакеты мы разделили, и поэтому как-то нам непонятно было, какую версию давать семантическую, поэтому мы решили переназвать продукт.
1779.88 1791.52 "Анатолий Кулаков" Ну, тоже звучит довольно странно, потому что опять же, мерж разных сборок, выделение разных сборок никогда не мешало сохранять семантическое версионирование на месте и никуда от этого не дергаться.
1791.52 1794.40 "Анатолий Кулаков" В общем, тоже третий аргумент меня как-то не сильно убедил.
1794.40 1808.00 "Анатолий Кулаков" Ну в общем, если подытоживать, то переименование множества сборок, рефакторинг там множества сборок, перемещение туда-сюда классиков поменяло сильно namespace, но не бойтесь, эти namespace в основном поменялись для тех, кто любит расширять XUnit.
1808.00 1821.56 "Анатолий Кулаков" Вообще, XUnit, он очень популярен как раз таки стало из-за того, что его легко расширять, вы можете написать свой какой-нибудь test_runner, test_discoverer, test_logger, в общем, всего что угодно, подцепите любой хросскатинг консерв в middleware.
1821.56 1846.84 "Анатолий Кулаков" Он очень гибкий, очень расширяпельный, и вот те, кто любил писать под него расширения, особенно очень извращенные глубокие расширения, вот у тех третья версия вызовет, наверное, больше всего проблем, потому что там они очень хорошо там переделали структуру, она действительно у них была немножко устаревшая, немножко не поддерживала разные там сложные какие-то фишки, теперь она поддерживает, теперь она молодец, теперь она хорошая, но за это пришлось оплачиваться тем, что экстеншн-писатели должны страдать.
1846.84 1865.56 "Анатолий Кулаков" Ну, товарищи как бы пострадали, ничего страшного, наверное, они под это как бы и рассчитывали, но, повторюсь, опять же, различным обычным людям, которые пользовались максимум атрибутами для запуска тестов, по идее ничего сломаться не должно, ничего такого у них не поехало, все на месте как бы осталось.
1865.56 1879.20 "Анатолий Кулаков" Итак, а что же, собственно, добавилось у нас в Ascension Library, наверное, как сердце самого тестового фреймворка, да что ж мы такого сердца нового научились, ну, фактически только работа со скипом, вот и все, что там добавилось.
1879.20 1880.20 "Анатолий Кулаков" Что это такое?
1880.20 1901.08 "Анатолий Кулаков" Наверное, как многие из вас знают, тесты можно скипать, ну, то есть пропустить их запуск по какой-то той или иной причине, и вот раньше тесты можно было скипать только с помощью атрибута, то есть вы навешиваете атрибут skip, указываете там причину, по которой вы хотели этот тест пропустить из нашего раннера, и все, и как бы статически оно там висело, и он там не запускался.
1901.08 1910.40 "Анатолий Кулаков" Теперь можно это делать динамически во время выполнения с помощью там трех новых skip методов, это assert.skip, да, и вы там указываете сообщение, почему вы скипнулись.
1910.40 1912.12 "Анатолий Кулаков" Что это позволяет сделать?
1912.12 1918.16 "Анатолий Кулаков" Позволяет оно динамически скипать тесты в зависимости от того окружения, на котором вы работаете, например, операционная система.
1918.16 1928.84 "Анатолий Кулаков" Ну, вы понимаете, что, например, для винды у вас этот тест не актуален, и все, пожалуйста, вы можете динамически задетектировать, что у вас операционная система Windows, и написать, что для винды я это скипнул, а вот на Linux, пожалуйста, запущусь.
1928.84 1939.80 "Анатолий Кулаков" Ну и так далее, опять же, можно там фантазировать насчет development окружения, запускать, допустим, интеграционные там тесты только на development окружении, какие-нибудь smoke-тесты только на интеграционном окружении, каком-нибудь другом окружении.
1939.80 1943.92 "Анатолий Кулаков" В общем, дальше с этим можно играться, полезный, наверное, механизм.
1943.92 1944.92 "Анатолий Кулаков" Почему бы и нет.
1944.92 1955.86 "Анатолий Кулаков" Все, что нам добавили в Assertion Library, ну там есть пару мелких еще вещей, которые обещали довезти, я думаю, их там довезли, но из существенного это практически все.
1955.86 1957.84 "Анатолий Кулаков" Что еще интересного есть?
1957.84 1961.96 "Анатолий Кулаков" Появились такие понятия, как explicit tests, то есть явные тесты.
1961.96 1968.20 "Анатолий Кулаков" Если вы пометили тест явным, то он не будет запускаться при обычном запуске всех тестов.
1968.20 1973.80 "Анатолий Кулаков" Это значит, что он будет запускаться только явно, только если вы специально скажете "хочу запустить вот этот тест".
1973.80 1981.04 "Анатолий Кулаков" Ну, или так же это можно сказать с помощью команд-лайна, то есть вы в команд-лайн пишете, типа "запусти мне все явные тесты", и тогда он явно запускается.
1981.04 1983.60 "Анатолий Кулаков" Концепция на самом деле довольно спорная.
1983.60 1986.16 "Анатолий Кулаков" Мне больше нравится, как этот момент сделан в InUnity.
1986.16 1999.44 "Анатолий Кулаков" В InUnity, если вы навесили атрибут skip на тест, то вы этот тест, естественно, не увидите среди общей массы всех тестов, которые запускаются, он скипнется, как этот атрибут и просил.
1999.44 2005.64 "Анатолий Кулаков" А вот если вы пойдете явно на этот тест и скажете "запусти мне этот скипнутый тест", то InUnit без проблем его запустит.
2005.64 2010.76 "Анатолий Кулаков" И это на самом деле безумно удобная фишка, которую почему-то до сих пор не может перенять у себя XUnit.
2010.76 2015.32 "Анатолий Кулаков" В XUnity, если вы хотите запустить скипнутый тест, то у вас ничего не получится.
2015.32 2023.28 "Анатолий Кулаков" Из раннера тестов это не работает, вам придется идти, закомментировать код, который, атрибут, который скипает, и только потом его запустить.
2023.28 2029.04 "Анатолий Кулаков" Безумно неудобно это делать, и плюс мы бы как раз ввели концепцию explicit тестов отдельно.
2029.04 2035.04 "Анатолий Кулаков" Странное решение, опять же, лучше бы взяли практику InUnit и пошли бы дальше работать.
2035.04 2041.46 "Анатолий Кулаков" А из другого у нас еще добавилось такое понятие как filtering expression.
2041.46 2046.36 "Анатолий Кулаков" То есть это способ определить тот набор тестов, который у вас будет запускаться.
2046.36 2055.68 "Анатолий Кулаков" Раньше мы уже могли сортировать какие-то тесты, то есть по каким-то базовым вещам, типа "запусти мне все тесты из такого-то класса", или "запусти мне такой-то метод в виде теста".
2055.68 2064.40 "Анатолий Кулаков" Ну то есть у нас были какие-то определенные методы, где мы могли какие-то фильтры, где мы могли из командной строки, допустим, указать какие тесты в данный момент мы хотим выполнить.
2064.40 2070.32 "Анатолий Кулаков" Опять же, те же самые разделения на интеграционные тесты, на Unit-тесты и так далее.
2070.32 2074.20 "Анатолий Кулаков" Теперь появилась такая штука, как Query Filter Language.
2074.20 2079.32 "Анатолий Кулаков" С помощью атрибута командной строки, которая называется Filter, вы можете указать более сложные выражения.
2079.32 2085.08 "Анатолий Кулаков" Там с if-ами, с end-ами, с какими-то regex-пами, со звездочками, в общем.
2085.08 2089.88 "Анатолий Кулаков" Там люди навратили целый свой язык, с помощью которого вы можете определить именно тот набор тестов, который вам интересен.
2089.88 2092.40 "Анатолий Кулаков" Ну, наверное, тоже может быть кому-то интересно.
2092.40 2095.80 "Анатолий Кулаков" Тоже может быть, кто-то это будет использовать.
2095.80 2099.28 "Анатолий Кулаков" Дальше появился такой полезный класс, как TestContext.
2099.28 2102.32 "Анатолий Кулаков" Очень интересный, хороший классик, давайте познакомимся с ним поближе.
2102.32 2113.80 "Анатолий Кулаков" Это класс, который позволяет вам получать информацию о текущем пайплайне выполнения, ну, не только получать, но и немножко управлять этим пайплайном.
2113.80 2115.64 "Анатолий Кулаков" Что же там есть у этого TestContext?
2115.64 2123.32 "Анатолий Кулаков" Ну, это собрали, как всегда, в контексте, собирают все как бы утилитки, которые нужны для работы с юнит-фреймворком.
2123.32 2127.68 "Анатолий Кулаков" В частности, там есть такое полезное свойство, как CancellationToken.
2127.68 2134.40 "Анатолий Кулаков" Действительно, иногда бывает полезно запустить какой-нибудь интеграционный тестик, который там крутится у вас, допустим, несколько часов, да.
2134.40 2146.24 "Анатолий Кулаков" И как понять, когда пользователь перехотел ждать уже этот тестик, он уже нажал кнопочку стоп, уже хватит, уже хорош, а у вас там цикл какой-нибудь молотит ваши данные, тестирует ваши данные, что-то там делает.
2146.24 2148.68 "Анатолий Кулаков" Раньше простого хорошего способа для этого не было.
2148.68 2160.76 "Анатолий Кулаков" Теперь у нас есть понятный CancellationToken, можно сравнить его с тем CancellationToken, который, допустим, приходит к вам в HTTP-реквесте и вы его забрасываете в ваш код, который дальше продолжает выполняться.
2160.76 2176.56 "Анатолий Кулаков" Вот точно так же и вот этот CancellationToken вы можете запросить дальше в ваши тесты, из тестов передать куда-то дальше, возможно, даже есть какой-то способ и пробросить его в HTTP-клайн, который отдаст его вашему HTTP-контроллеру, который отдаст его всему остальному пайплайну.
2176.56 2187.16 "Анатолий Кулаков" И есть способ нормально среагировать на тот момент, когда фреймворк уже требует прекращения всех тестов и хочет оборвать все выполнение, вот хороший прекрасный способ, отлично.
2187.16 2188.16 "Анатолий Кулаков" Что же дальше?
2188.16 2189.72 "Анатолий Кулаков" Еще интересного есть у этого тест-контекста.
2189.72 2219.00 "Анатолий Кулаков" Это метод по посылке диагностических сообщений, SendDiagnosticMessage, это хороший метод для отладки, его часто используют опять же те, кто пишет там всякие расширения для раннеров тестов и туда можно отправить какое-то сообщение, которое позволит вам рассказать, что, собственно, происходит с вашими тестами, какой тест выполняется, с каким статусом завершился, какие параметры взял, много таких интересных сообщений можно почитать или в том числе дописать.
2219.00 2251.84 "Анатолий Кулаков" Появился интересный KeyValueStorage, это специальный такой дикшнер, специальный объект, сумка, которая позволяет вам обмениваться различными данными между различными шагами тестов в вашем тестовом пайплайне, ну, допустим, вы можете перехватить момент, когда у вас тесты только дискаверятся, в этот дикшнере сложить какую-то информацию, потом, когда тест запускается, из этого дикшнере что-то достать, может быть, когда он завершил запускаться или начал выпускаться другой тест, оттуда что-то положить, то есть такое расшаренное состояние между тестами.
2251.84 2261.90 "Анатолий Кулаков" На самом деле это мега плохо, все знают, что расшаренное состояние это плохо, тем более между тестами, которые должны выполняться параллельно и должны выполняться в разном порядке.
2261.90 2275.34 "Анатолий Кулаков" Это еще более плохо, чем плохо, ну, наверное, для каких-то специфических вещей, для каких-то там мега узких расширений оно может и понадобиться, но опять же, в обычной жизни ни в коем случае эту штуку не используйте.
2275.34 2305.30 "Анатолий Кулаков" Вот, что более интересно использовать, это метод addAttachment, который тоже у нас появился в тест-контексте, он позволяет вам присобачить к результатам тестирования какой-то, какой-то полезный отчет, этот отчет может быть в plain-тексте, а может быть в каком-нибудь в байнаре формате, в котором вы можете еще указать MIME-type, ну, то есть тот тип, который внутри этого байнаря зашит и средство, ну, то есть провайдер результатов теста может с ним как-то работать.
2305.30 2322.42 "Анатолий Кулаков" Ну, допустим, во время теста вы там собрали какую-то хорошую табличку, допустим, из Benchmark.net, который дает красивые таблички, вы можете ее не просто в консоль вывести, а сделать из нее какой-нибудь Excel-файл или CSV-файл или JSON-файл и присобачить этот JSON-файл или Excel-файл к результатам вашего тестирования.
2322.42 2342.34 "Анатолий Кулаков" И в результатах тестирования, например, в тест-провайдере вы можете посмотреть не только то, что этот тест зеленый, но и посмотреть, а с каким Excel-файлом этот тест зеленый, то есть открыть там какой-нибудь файлик в результатах тестирования и посмотреть, что там произошло, то есть каждый тест может какие-то файлы добавлять.
2342.34 2351.50 "Анатолий Кулаков" Или, допустим, вы там тестируете генерацию, как рисует, допустим, ваш тест на битмапе, и результат этого битмапа, который он нарисовал, вы можете не только проверить, но и приложить к аттачментам.
2351.50 2366.74 "Анатолий Кулаков" Или, допустим, если у вас какой-то снапшот тестирования, то есть вы сверяете вашу картинку или ваш файлик с тем файликом, который должен был получиться, у вас что-то не сработало, и в негативном тесте вы, допустим, этот DIV или тот файл, который получился, опять же, цепляете в результаты тестирования.
2366.74 2370.50 "Анатолий Кулаков" Очень полезная штука, я думаю, вот этим он будет часто пользоваться.
2370.50 2387.74 "Анатолий Кулаков" Так, еще метод интересный, это addWarning, как и полагается, addWarning к вашему тестовому результату, то есть вы сможете видеть, что тест не просто зеленый, а он зеленый, но с каким-то там ворнингом, то есть что-то в процессе выполнения пошло не так, или этот тест начал что-то подозревать, в общем, можно обратить на это внимание.
2387.74 2389.22 "Анатолий Кулаков" Тоже, наверное, полезная штука.
2389.22 2396.30 "Анатолий Кулаков" В общем, вот много таких интересных тестовых утилитных методов представляет TestContext, как же нам его достать?
2396.30 2417.22 "Анатолий Кулаков" Ну, достать довольно просто, у нас есть теперь статический метод testcontext.current, и там вы можете все эти методы, тесты найти, или если вы не любите обращаться к статике, предпочитаете более такой концептуальный подход, то у нас есть itestcontextaccessor, который можно заинтерфейсить, который можно заинжектировать к себе в конструктор и пользоваться всеми вышеупомянутыми методами.
2417.22 2420.38 "Анатолий Кулаков" То есть тоже хороший такой DI способ.
2420.38 2421.38 "Анатолий Кулаков" Погнали дальше.
2421.38 2426.62 "Анатолий Кулаков" Секция, которую больше всего я ждал, я любил и я хотел, это изменение в DataRow.
2426.62 2428.86 "Анатолий Кулаков" Что же это такое?
2428.86 2433.70 "Анатолий Кулаков" В версии 2 была такая прекрасная штука, как теория.
2433.70 2437.28 "Анатолий Кулаков" И не просто теория, а теория с какими-нибудь данными.
2437.28 2445.18 "Анатолий Кулаков" Это когда вы пишете тестовый метод, и в этот тестовый метод в качестве аргументов хотите принять какой-то набор.
2445.18 2450.62 "Анатолий Кулаков" И этот набор вам заранее не известен, а этот набор вам сгенерит кто-нибудь, какой-нибудь источник тестовых наборов.
2450.62 2460.94 "Анатолий Кулаков" Вы можете взять этот тестовый набор из атрибутов, которые напрямую прямо над этим тестовым методом висят, можете запросить его из какого-то другого класса, который сгенерит вам какой-то тестовый набор, который вы хотите тестировать.
2460.94 2462.46 "Анатолий Кулаков" Можете загрузить его из файла.
2462.46 2465.42 "Анатолий Кулаков" В общем, далее дело провайдера, откуда он это возьмет.
2465.42 2478.14 "Анатолий Кулаков" Ну и самым частым вариантом, естественно, было указание этого тестового набора именно в коде, потому что в коде можно было легко там нагенерить каких-нибудь сущностей, которые хочется проверить, каких-нибудь закомбинаторить, каких-нибудь вариантов, которые хочется было проверить.
2478.14 2481.66 "Анатолий Кулаков" В общем, в коде это понятный, интересный и хороший способ.
2481.66 2494.70 "Анатолий Кулаков" Так вот, чтобы раньше в этот тестовый набор загенерить вам какие-то данные, вам достаточно было указать какой-то ресурс, метод, класс, что-нибудь еще, который возвращал бы вам IEnumerable от массива объектов.
2494.70 2500.82 "Анатолий Кулаков" IEnumerable, понятно, это набор параметров, с которыми будет тестироваться ваш тест.
2500.82 2504.82 "Анатолий Кулаков" Массив объектов, понятно, потому что у вашего теста могут быть несколько аргументов.
2504.82 2508.14 "Анатолий Кулаков" Вот этот массив объектов, это был как раз массив ваших аргументов.
2508.14 2511.42 "Анатолий Кулаков" И XUnit их прекрасно раскладывал в эти аргументы и тестировался.
2511.42 2529.98 "Анатолий Кулаков" Казалось бы, все хорошо, но здесь есть много тонкостей и минусов, опять же, потому что, во-первых, массив объектов не очень красиво выражался, потому что вам нужно было сделать сигнатуру метода, которая возвращала IEnumerable от объекта, от массива объектов.
2529.98 2533.10 "Анатолий Кулаков" В общем, сложно было здесь ошибиться, то есть легко было бы ошибиться.
2533.10 2544.30 "Анатолий Кулаков" Поэтому массив объектов хотелось бы передавать в виде generic каких-то параметров, чтобы там были какие-то строго определенные понятные типы, которые одинаковые у всех тест-кейсов.
2544.30 2552.70 "Анатолий Кулаков" В общем, для этого появились там generic классы, которые были, но generic классы были сделаны тоже из рук вон плохо.
2552.70 2556.54 "Анатолий Кулаков" На этих generic классах нельзя было указать кроме этих параметров ничего.
2556.54 2560.82 "Анатолий Кулаков" Например, поменять displayName от теста нельзя было.
2560.82 2565.22 "Анатолий Кулаков" А когда вы запускаете много сгенерированных данных, то displayName иногда хочется поменять.
2565.22 2574.86 "Анатолий Кулаков" Это которые показывают вам нормальное человеческое название теста, а не выводят там список из 10 параметров и говорят, вот вам 10 разных параметров, посмотрите, какой интересный тест я поймал.
2574.86 2578.18 "Анатолий Кулаков" Это было очень неудобно.
2578.18 2581.62 "Анатолий Кулаков" Гораздо приятнее это было сделано как раз таки в nUnity.
2581.62 2588.18 "Анатолий Кулаков" Там эту проблему решили довольно давно, и вот эту концепцию как раз xUnit наконец-то в третьей версии к себе перенял.
2588.18 2589.42 "Анатолий Кулаков" Что же теперь может делать третья версия?
2589.42 2601.78 "Анатолий Кулаков" Ну, прежде всего, она точно так же может принимать массив объектов, она же сможет принимать именованные или неименованные туплы, но самое главное, она теперь может принимать интерфейс, который называется iTheoryDataRow.
2601.78 2605.18 "Анатолий Кулаков" Что же это за такой прекрасный интерфейс?
2605.18 2625.60 "Анатолий Кулаков" Этот интерфейс, от которого есть безусловно какой-нибудь базовый наследник, который может принимать набор вот этих вот значений, этот наследник, то есть наследник, который называется TheoryDataRow, генерик, у него есть перегрузки под 10 аргументов, он может их генериково, строго типизированно принимать.
2625.60 2630.10 "Анатолий Кулаков" То есть проблема с генериковой типизацией здесь более-менее решена.
2630.10 2631.88 "Анатолий Кулаков" Теперь проблема с метаданными.
2631.88 2640.74 "Анатолий Кулаков" Очень часто хочется к вот этому запуску тестов, то есть одна TheoryDataRow – это один запуск тестов.
2640.74 2645.94 "Анатолий Кулаков" Один запуск тестов, он кроме тестовых данных может обладать еще кучей полезных метаданных.
2645.94 2649.70 "Анатолий Кулаков" Одно из самых полезных применений – это как раз DisplayName.
2649.70 2656.78 "Анатолий Кулаков" То есть вы хотите вот этому набору из 10 непонятных аргументов дать какое-то человеческое понятное название, чтобы этот тест легко и быстро отображать.
2656.78 2662.70 "Анатолий Кулаков" Вот теперь, благодаря тому, что у нас есть класс TheoryDataRow, у него есть вот эти метаданные.
2662.70 2671.18 "Анатолий Кулаков" Кроме списка аргументов, которые он предоставляет, у него есть свойство DisplayName, которым мы можем указать и все тестовые провайдеры этот DisplayName отобразят в виде имени теста.
2671.18 2673.34 "Анатолий Кулаков" Еще, что у него еще есть полезного?
2673.34 2683.10 "Анатолий Кулаков" Ну также у него есть полезный атрибут – это Skipped, то есть мы можем теперь динамически точно даже скипать тесты, если мы решили, что именно вот этот тестовый набор нам не подходит.
2683.10 2687.62 "Анатолий Кулаков" У него есть флаг Explicit, который мы выше обсуждали, признак явного теста.
2687.62 2694.66 "Анатолий Кулаков" У него есть отдельный флаг Timeout, то есть вот это именно одна строчка, у него есть свой собственный Timeout, как у своего собственного теста, как и положено быть.
2694.66 2702.34 "Анатолий Кулаков" И также мы туда можем присвободчить трейты, то есть это специальные какие-то флаги, специальные атрибуты, специальные названия, по которым мы можем дифференцировать тесты.
2702.34 2709.54 "Анатолий Кулаков" В общем, я выше уже упоминал, что у нас появились некие сложные фильтры, по которым люди могут собирать тестовый набор и как-то фильтровать.
2709.54 2711.74 "Анатолий Кулаков" Ну, обычно на практике люди так не делают.
2711.74 2712.74 "Анатолий Кулаков" Как делают люди?
2712.74 2717.86 "Анатолий Кулаков" Люди помечают специальные тестовые наборы каким-нибудь обычным трет-атрибутом.
2717.86 2722.10 "Анатолий Кулаков" Ну, типичный атрибут, который вы сейчас встречали, это, допустим, интеграционные тесты.
2722.10 2724.74 "Анатолий Кулаков" Я хочу вот этот набор тестов пометить как интеграционный.
2724.74 2729.22 "Анатолий Кулаков" Я делаю thread integration test, вешаю его над тестовым классом и все.
2729.22 2731.86 "Анатолий Кулаков" Теперь у меня тестовый класс помечен вот этим своеобразным тегом.
2731.86 2740.38 "Анатолий Кулаков" И потом в качестве запуска я могу сказать вот интеграционные тесты мне запускай, а там какие-нибудь unit-тесты, smoke-тесты, end-to-end-тесты не запускай.
2740.38 2744.18 "Анатолий Кулаков" И вот таким вот образом я на разных средах могу запускать разный набор тестов.
2744.18 2747.42 "Анатолий Кулаков" Поэтому появление фильтра меня тоже не очень как-то впечатлило.
2747.42 2751.42 "Анатолий Кулаков" Все, что нужно намного явнее, красивее и понятнее, это развешивать thread.
2751.42 2757.90 "Анатолий Кулаков" Так вот, у этого TheoryData она теперь тоже может поддерживать вот эти трейды, что тоже отдельно прекрасно.
2757.90 2766.46 "Анатолий Кулаков" И теперь, я не помню, была ли возможность у предыдущих провайдеров асинхронно загружать эти данные.
2766.46 2769.66 "Анатолий Кулаков" Ну, наверное, была, если там была возможность из файлов.
2769.66 2770.66 "Анатолий Кулаков" Как-то ни разу не пользовался.
2770.66 2771.66 "Анатолий Кулаков" Ну, теперь это точно можно делать асинхронно.
2771.66 2776.26 "Анатолий Кулаков" Ну, и в принципе, наверное, про вот этот DataRow.
2776.26 2788.62 "Анатолий Кулаков" Я часто пользуюсь просто DataRow, но меня раньше безумно смущало и синтаксис, с помощью которого XUnit был, это делал, и его недостаток в вот этих мета-свойствах, которые были.
2788.62 2792.66 "Анатолий Кулаков" Особенно после того, как я перешел с NUnit и знал, как можно сделать красиво и правильно.
2792.66 2794.74 "Анатолий Кулаков" В общем, теперь здесь полный паритет.
2794.74 2798.66 "Анатолий Кулаков" Здесь мы догнали и начинаем обгонять, и это тоже радует.
2798.66 2802.42 "Анатолий Кулаков" Так, следующее интересное выведение, которое у нас есть, это Matrix Theory Data.
2802.42 2805.46 "Анатолий Кулаков" Ну, это опять относится к тем же теориям, про которые я сказал.
2805.46 2808.58 "Анатолий Кулаков" То есть, это некий набор, который динамически XUnit вам туда как-то подставляет.
2808.58 2811.58 "Анатолий Кулаков" Вообще, очень много есть расширений, которые этот набор генерят.
2811.58 2814.06 "Анатолий Кулаков" Мы даже парочку из этих расширений в нашем подкасте обсуждали.
2814.06 2821.22 "Анатолий Кулаков" И в частности, одно из расширений, которое мы обсуждали, оно как раз и делало то, что делает вот этот Matrix Data.
2821.22 2823.14 "Анатолий Кулаков" Что же делает Matrix Data?
2823.14 2824.14 "Анатолий Кулаков" Очень просто.
2824.14 2833.78 "Анатолий Кулаков" Как только вы цепляете New Matrix Theory Data, как только вы его объявляете, этот новый класс, он принимает в качестве параметров несколько наборов.
2833.78 2837.58 "Анатолий Кулаков" Ну, допустим, у вас есть набор из трех интов и набор из двух стрингов.
2837.58 2843.34 "Анатолий Кулаков" Как только вы засунете его в Matrix Theory Data, то в ваш тест придет 6 значений.
2843.34 2849.78 "Анатолий Кулаков" 6 значений – это перемножение всех интов, всех трех интов на все две стринги.
2849.78 2859.30 "Анатолий Кулаков" То есть, первый аргумент у вас будет интовый, второй аргумент у вас будет стринговый, и они все, каждый с каждым зайдет в ваш тестовый метод, то есть такая комбинаторика получится.
2859.30 2862.62 "Анатолий Кулаков" Да, довольно полезное расширение, почему бы и нет.
2862.62 2867.94 "Анатолий Кулаков" В общем, стосторонние расширения такие были, из коробки иметь такое вдвойне прекрасно.
2867.94 2868.94 "Анатолий Кулаков" Пойдемте дальше.
2868.94 2875.74 "Анатолий Кулаков" Так, еще из интересного у нас есть неявный захват, ой, наоборот, явный захват, явный захват вспомогательных аутпутов.
2875.74 2876.74 "Анатолий Кулаков" Что это значит?
2876.74 2882.82 "Анатолий Кулаков" В версии второй мы никак не могли захватить и контролировать, ну, по крайней мере, простыми способами, хаки, конечно, были.
2882.82 2891.74 "Анатолий Кулаков" Мы могли захватить консоль, вывод в консоль, вывод в дебаг и вывод в трейс, который у нас диагностик-дебаг, диагностик-трейс, вот это все, ну и консоль в отлайн обычный.
2891.74 2897.34 "Анатолий Кулаков" А это часто бывает полезным, особенно для консольных утилиток, для консольных приложений, очень полезная штука.
2897.34 2914.62 "Анатолий Кулаков" В третьей версии появилась такая возможность, вам нужно над сборкой навесить атрибут, который называется Capture Console или Capture Trace, соответственно, и все, что у вас выводится в консоль или в трейс, автоматически редиректится в ITestOutputHelper.
2914.62 2923.10 "Анатолий Кулаков" Обычно вот этот ITestOutputHelper, его как раз для этого инжектируют, для того, чтобы туда какие-то диагностические сообщения и методы выдать.
2923.10 2939.86 "Анатолий Кулаков" И очень часто бывало, что дублировали сообщение, выводят в консоль, а потом практически то же самое выводят в TestOutputHelper, ну, как-нибудь проксировали это, но не суть важна, важно, что теперь вам не нужно этой работой заниматься, вы это все можно сделать под капотом.
2939.86 2954.80 "Анатолий Кулаков" И вот как раз один из тех аспектов, когда я сказал, что авторы все-таки стараются держать backward compatibility для пользователей на максимальном градусе, ради обратной совместимости два этих атрибута выключены по дефолту.
2954.80 2963.18 "Анатолий Кулаков" Вот казалось бы, в нормальном приложении, особенно если мы говорим про новый продукт, с новым именем, вот эти два атрибута должны были быть включены.
2963.18 2984.78 "Анатолий Кулаков" Все, что я выложу в консоль, я, по идее, хотел бы введить в TestOutputHelper, ничего плохого от этого никогда не бывает, но, наверное, бывает все-таки приложение, которое спамят в консоль, там, какими-нибудь картинками или чем-нибудь в этом духе, вы не хотите их туда выводить, поэтому по умолчанию это все дело выключено ради обратной совместимости, чтобы ваши старые тесты ничего плохого вам на новом тестовом фреймворке не сделали.
2984.78 3013.22 "Анатолий Кулаков" Появилось гибкое управление тестовым пайплайном, то есть у нас есть различные, у нас, как у команды, которая пишет расширения для XUnit, как я уже сказал, что, наверное, версия третья, она больше всего зафиксировала тех людей, которые пишут расширения, интеграции, расширения и прочие какие-то нестандартные пайплайны для тестирования, в общем, третья версия больше всего про них.
3013.22 3036.86 "Анатолий Кулаков" Ну и здесь вот появилось специальное управлятье по пайплайну, которое позволяет вам, например, перехватить не только момент перед запуском, допустим, и после запуска вашего теста, или вашего класса, или вашей коллекции тестов, а еще на тот момент, когда вы исследуете предложение, когда вы дискаверите, а то какие тесты вообще есть у вас в этой сборке, вот в этот момент вы можете там перехватить и что-нибудь там сделать, что-нибудь подсунуть.
3036.86 3039.06 "Анатолий Кулаков" В общем, это тоже больше для расширятелей.
3039.06 3056.94 "Анатолий Кулаков" Что же для обычных пользователей заинтересно, у нас еще есть возможность переписать Current Culture, во второй версии Current Culture, то есть та культура, с помощью которой у вас запускаются все тесты, она всегда равнялась той культуре, которая по умолчанию установлена на вашем ПК, на вашем компьютере.
3056.94 3080.84 "Анатолий Кулаков" Иногда это было не всегда хорошо, допустим, если у вас криворукие программисты почему-то закладывались на культуру, допустим, русского языка, что вы там парсили децималы с запятой, или время в русском формате смотрели, или еще что-то, в общем, и у вас, опять же, куча легоси, то вам приходилось эту культуру каким-то образом подменять глобально.
3080.84 3090.26 "Анатолий Кулаков" Вот теперь в третьей версии XUnit у вас есть прямо камонлайновский аргумент, в котором вы можете задать любую культуру и весь XUnit запустится именно под этой культурой.
3090.26 3095.86 "Анатолий Кулаков" Ну, опять же, это надо заметить, что именно совместимость со старым криворуким кодом.
3095.86 3106.74 "Анатолий Кулаков" Нормальные разработчики всегда должны понимать, что если они запускают какой-то парс или какой-то формат, то явно нужно туда передавать культуру, потому что ваше приложение может запускаться на любом компьютере, вы не поверите.
3106.74 3114.66 "Анатолий Кулаков" Даже не только под виндой, на компьютере, на котором может стоять хоть китайская культура, но он должен уметь работать с тем форматом, который задекларировал.
3114.66 3119.62 "Анатолий Кулаков" Поэтому все парсы и форматы, и тустринги, и прочее должны явно презентоваться с какой-то культурой.
3119.62 3132.62 "Анатолий Кулаков" Еще интересная штука – это repeatable randomization, то есть теперь XUnit 3, я вот не понял, по умолчанию или нет, мне кажется, что все-таки по умолчанию, будет запускать ваши тесты в рандомном порядке.
3132.62 3136.90 "Анатолий Кулаков" Этот рандомный порядок, но он рандомный будет только в рамках билда.
3136.90 3143.54 "Анатолий Кулаков" То есть вы забилдили, начинаете запускать, и у вас какой-то рандомный порядок, но после первого запуска порядок у вас уже будет повторяться.
3143.54 3147.98 "Анатолий Кулаков" Потом вы перебилдили ваше приложение, и этот рандомный порядок поменялся, и опять он будет уже постоянный.
3147.98 3148.98 "Анатолий Кулаков" Ну хотя бы так.
3148.98 3156.94 "Анатолий Кулаков" Это очень хорошая штука, особенно для тех, опять же, криворуких разработчиков, которые почему-то рассчитывают на какой-то порядок тестов.
3156.94 3159.06 "Анатолий Кулаков" Как известно, на порядок тестов рассчитывать нельзя.
3159.06 3164.50 "Анатолий Кулаков" Если вам нужно каким-то образом синхронизировать пайпланы, то это должно делаться другими способами, а не с помощью порядка теста.
3164.50 3169.26 "Анатолий Кулаков" И вот такая рандомизация, она должна отучить плохих разработчиков писать плохие тесты.
3169.26 3171.26 "Анатолий Кулаков" Это хорошо, это мы одобряем.
3171.26 3177.34 "Анатолий Кулаков" Рандомизация, ну вот этот сид, с которым у нас будет рандомизация, он всегда в аутпуте выводится.
3177.34 3196.06 "Анатолий Кулаков" Поэтому если вдруг у вас тесты падают только при каком-то определенном порядке тестов, который зарандомизировался, можно взять этот сид из аутпута, запустить тесты с этим сидом, и вам XUnit повторит тот же самый рандом, который, на котором у вас тесты попадали, и вы можете таким образом одебажиться и починить то, что у вас есть.
3196.06 3199.22 "Анатолий Кулаков" Введена поддержка Microsoft Testing Platform.
3199.22 3207.14 "Анатолий Кулаков" Это специальная абстракция от Microsoft, которая позволяет легко интегрировать ваши юнит-тесты в различные места.
3207.14 3208.62 "Анатолий Кулаков" Сейчас таких мест в основном два.
3208.62 3220.90 "Анатолий Кулаков" Во-первых, это .NET Test, командная утилита, командные строки, которая может запускать любые тесты, ну и, соответственно, мы автоматически получаем поддержку XUnit 3 для программы .NET Test.
3220.90 3225.34 "Анатолий Кулаков" И второе место популярное - это Visual Studio Test Explorer, конечно же.
3225.34 3230.82 "Анатолий Кулаков" То есть мы автоматически получаем поддержку Visual Studio, потому что она уже этот Microsoft Testing Platform поддерживает.
3230.82 3233.14 "Анатолий Кулаков" Поэтому то, что мы туда зашли, это очень хорошо.
3233.14 3239.58 "Анатолий Кулаков" Этот Microsoft Testing Platform пришел на смену старому API, который назывался Base Test API.
3239.58 3242.34 "Анатолий Кулаков" Ну, я думаю, что с райдером такая же точная потеха.
3242.34 3249.94 "Анатолий Кулаков" Райдер, скорее всего, тоже поддерживает Microsoft Test Platform, поэтому туда XUnit 3 должен тоже вписаться без каких-то дополнительных танцев с бубнами.
3249.94 3252.06 "Анатолий Кулаков" Ну, вот такой получился анонс.
3252.06 3269.10 "Анатолий Кулаков" Ну, вроде не сильно ломающий, очень даже стабильный, и не сильно приносящий кучу всего полезного, но кучу полезного, я бы сказал, глобально, но очень много полезных мелких фишечек, которых часто не хватало, часто были на них потребности и очень часто от авторов их просили.
3269.10 3275.26 "Анатолий Кулаков" Наверное, их можно было бы внедрить и во второй XUnit, ничего страшного бы не случилось, ничего бы не сломалось.
3275.26 3283.50 "Анатолий Кулаков" Как видите, никаких больших брекничеств здесь для обычного пользователя, как я уже сказал, нет, но решили наконец зарелизить третью версию, что в принципе тоже хорошо.
3283.50 3292.14 "Анатолий Кулаков" Там очень много было желаний от других пользователей, довольно мелких таких, которые вносили вот мелкие хорошенькие рюшечки.
3292.14 3303.26 "Анатолий Кулаков" В общем, что можно сказать, релиз хороший, всем обновляться, всем использовать в новых проектах, и все переезжаем на XUnit 3, да это должно быть безболезненно, легко и красиво.
3303.26 3318.90 "Игорь Лабутин" Но я действительно подумываю о том, что может быть я в целом больше любителен юнита, исторически так сложилось, и может быть как раз из-за вот этих мелких фишечек, которых так как-то не хватало, может быть это повод попробовать таки снова XUnit, снова 3.
3318.90 3333.30 "Игорь Лабутин" Я так понимаю, что 3, потому что там довольно большая работа была проведена и внутри, над собственной внутренней архитектурой, чтобы это все переделать и поддержать все эти рюшечки, но поглядим-поглядим, я думаю, как-нибудь, когда будет.
3333.30 3340.30 "Анатолий Кулаков" Именно так, да, самое главное изменение, как я уже сказал, для всех вот этих плагин-писателей, которые внутренний интерфейс используют.
3340.30 3341.30 "Анатолий Кулаков" Для них там поменялась куча всего.
3341.30 3349.58 "Анатолий Кулаков" Но я думаю, они сами знают, что именно, поэтому мы не стали влезть в эти дебри, так архитектура там хорошо переделалась.
3349.58 3371.86 "Игорь Лабутин" Окей, приятно, здорово, хорошо, хорошо, когда выходят релизы продуктов, которые мы долго ждем, а мы пойдем дальше и заглянем в пару тем, которые, ну скажем так, довольно нечасто встречаются у нас в подкасте, а именно поговорим про совсем внутренности, и проговорим мы про внутренности гарбыч-коллектора.
3371.86 3376.18 "Игорь Лабутин" Точнее, не столько про гарбыч-коллектор, сколько про внутренности рентайма.
3376.18 3404.94 "Игорь Лабутин" Попалась статейка, она довольно давняя, она начала даже 24 года, но тут на нее ссылочку привели, про то, какие вообще говоря, бывает GC-handle, для того чтобы с этим разобраться, давайте, во-первых, запомним, что никакой практической пользы, скорее всего, вы из этой статьи извлечь вряд ли сможете, никакой пользы вам не будет, чисто для общего образования, а второе, давайте вспомним вообще, о чем речь и про что мы говорим.
3404.94 3417.34 "Игорь Лабутин" Первое, у нас есть гарбыч-коллектор, вот знаете, нужен он для того, чтобы мы, соответственно, не задумывались о том, в какой момент освобождать память, а он бы сам это делал.
3417.34 3454.62 "Игорь Лабутин" Для того, чтобы гарбыч-коллектор знал, в какой момент можно удалять тот или иной объект, он использует трейсинг, так называемый, то есть он берет так называемые рутовые объекты, то есть те объекты, которые он знает, что точно живы, то есть это, например, текущий call stack или статические переменные, потому что они живут все время в жизни программы, и начиная с этих объектов, обходит все дерево объектов по ссылочкам, помечает, если очень грубо говорить, что все объекты, до которых он смог дотянуться таким образом живыми, все остальные, значит, можно собирать.
3454.62 3470.56 "Игорь Лабутин" Конечно, там есть по пути куча оптимизаций, каждый раз он дерево не обходит, там есть много-много-много хаков, про которые мы когда-то, может быть, немножко говорили, про которые подробно описаны в книжке Конрада Кокоса про .NET memory internals, но тем не менее, общая идея ровно такая.
3470.56 3507.24 "Игорь Лабутин" И если вдруг вам зачем-то нужно для какого-то объекта продлить его жизнь, и при этом не сохранять ссылку в каком-то поле, например, потому что вы этот объект передаете в какой-нибудь нативный код, и дальше он там где-то в нативном коде используется, то для этого начинают использоваться GC-хендлы, то есть это некоторый специальный тип, который тоже считается в каком-то смысле GC-рутом, и иногда очень специальным типом, который Горобочий коллектор довольно специальным образом использует при обходе этого самого дерева.
3507.24 3527.30 "Игорь Лабутин" Если вы внимательно читали документацию, то вы знаете, что, наверное, знаете, что есть такая структура GC-хендл, и там есть enum, который называется GC-hendl type, и у него есть в принципе четыре значения, ну, было долгое время четыре значения.
3527.30 3559.28 "Игорь Лабутин" Normal — это считается просто обычной ссылкой, без каких-либо проблем, как будто бы вы создали обычную ссылку на обычный объект, там есть тип Pinned — это когда мы создаем ссылку на специальный запиненный, как правило, массив, это нужно для того, чтобы передать запиненный массив куда-нибудь натив-код, чтобы пока работает натив-код, Горобочий коллектор случайно не подвинул этот массив куда-нибудь в память, потому что ему вдруг потребовалось что-нибудь закомпактить, он запиненный и не двигается.
3559.28 3570.00 "Игорь Лабутин" Эти два типа хендлов, они называются strong-hendls, это значит, что пока из такого хендла есть ссылка на какой-то объект, такой объект точно не будет удален или собран.
3570.00 3609.28 "Игорь Лабутин" Дальше есть два типа слабых хендлов — weak-hendls, это weak или weak-track-resurrection, две штучки, смысл в том, что обычно вы их напрямую не используете, обычно вы используете класс под названием weak-reference, который работает таким образом, что по большому счету, несмотря на то, что он держит ссылку на какой-то объект, Горобочий коллектор считает, что такой объект можно-таки собрать, и если ему очень надо, грубо говоря, то есть если у него есть там какой-то memory-pressure или ему нужно что-то куда-то освободить дополнительно, он такой объект может собрать.
3609.28 3613.80 "Игорь Лабутин" А может решить, что не будет собирать, например, потому что в это поколение не смотрел на это сборки мусора.
3613.80 3633.68 "Игорь Лабутин" То есть это обычно используется для всяких там, ну не знаю, например, кэшей, допустим, то есть есть запись в кэше, пока память есть, хорошо, если нет, ну как бы кэш пустой, точнее референс указывает в никуда, мы пойдем и получим такие объекты нормальные, это одно из применений, есть другие.
3633.68 3711.12 "Игорь Лабутин" В шестом дотнете был добавлен еще один тип, пятый, это называется Dependent Handle, не будем сейчас углубляться, по-моему, мы даже про него как-то рассказывали, для каких-то внутренних хитро вывернутых коллекций используется, но на самом деле, помимо этих пяти типов, всего, если посмотреть в исходнике runtime, их там 10 штук, и большая часть из этих 10 штук, то есть получается 5 нам мы можем так или иначе использовать из обычного кода, но остальные нам нужно как-то, не то чтобы нужно, остальные используют код CLR внутри, но со временем все меньше, меньше и меньше, то есть там есть 4 типа, называемые Variable, AsyncPumpInt, SizeDref и VignativeComp, очевидно, для ком всякого интеропа, но все вот эти 4 штуки, они теперь не используются, потому что все больше и больше частей переписываются на C#, и используются уже напрямую из C#, и там тогда не нужны все вот эти вот странного вида GC Handle, используются просто обычная ссылка, либо вот те самые 5 известных, которые я привел выше.
3711.12 3745.36 "Игорь Лабутин" Это в восьмом дотмете в основном произошло, но тем не менее один вариант, один тип внутреннего GC Handle остался, и он используется для довольно интересного случая, а именно для ReferenceCounting, то есть, как я сказал, наш горбочеколлектор он Tracing, и вообще говоря, для сборки мусора есть несколько подходов, один из этих подходов это ReferenceCounting, то есть каждый раз, когда мы получаем ссылку на какой-то объект, мы увеличиваем счетчик ссылок на этот объект, когда мы говорим, что нам больше этот объект не нужен, мы уменьшаем счетчик ссылок, как только счетчик ссылок добрался до нуля, объект можно удалять.
3745.36 3754.20 "Игорь Лабутин" Есть языки, есть рантаймы с таким методом сборки мусора, и в частности, ровно такой метод сборки мусора использует COM.
3754.20 3765.60 "Игорь Лабутин" Не то, чтобы это язык или рантайм, но тем не менее, когда мы работаем с COM-объектами, и ObjectsFc, кстати, тоже это используют, то мы вынуждены использовать ReferenceCounting.
3765.60 3789.56 "Игорь Лабутин" Чтобы дотнетный мир подружить с вот такими двумя мирами, как раз используется этот GC Handle, соответственно, называется он внутри, в рантайме, если вы будете искать, называется он HND_TYPE_REF_COUNTED, и он может использоваться и в формате strong ссылки, и в формате слабой ссылки, в зависимости от того, какой там счетчик и как его используют.
3789.56 3807.32 "Игорь Лабутин" Используется это для интеропа, соответственно, с COM, как я и сказал, и с ObjectsFc, напомню, что ObjectsFc — это в основном язык для депло и платформы, но дотнет у нас там работает, и поэтому, если вы хотите вызывать нативно ObjectsFc, то вам нужно с ним нормально интеропиться.
3807.32 3874.24 "Игорь Лабутин" Реализовано это все через штуку под названием RefCountedHandleCallbacks или ObjectiveCMarshall.CreateReferenceTracking методы, и в статье, я сейчас не буду углубляться в код, в статье прямо показано, как можно в обычном, ну, таком, может быть, не совсем обычном, но довольно-таки нормально выглядящем C#, получить таки GCHandle, естественно, вы объявляете просто обычный тип GCHandle, но для того, чтобы получить его правильного типа, нужно его создать специальным способом, после чего подписать его на оповещение от garbage-коллектора, и в статье прямо показано, что вот можно в ваш юзерный код, написанный на C#, получить callback из garbage-коллектора прямо, т.е. в момент garbage-коллектора будет определять вообще, можно ли удалять этот объект или нельзя, он будет дергать ваш callback, который должен, соответственно, сказать, счетчик ссылок равен нулю или не равен, если равен, то удалять можно, если не равен, то удалять нельзя, грубо говоря.
3874.24 3923.64 "Игорь Лабутин" Вот такая вот штука, для этого используются патчика структур, ну вот в исходном коде можете посмотреть, managedObjectWrapper, managedObjectWrapperHolder, короче, редирект на редиректе и класс на классе со всякими unsave и прочим кодом, но тем не менее, это выглядит все-таки как нормальный C#, который интересно посмотреть, если вы хотите понять, как вообще вся эта конструкция работает изнутри, т.е. не то чтобы это вам было нужно в каком-то практическом смысле, вряд ли вы это будете использовать в реальном коде, если только вы не пишете тот самый interop с com или с object-fc, ну а если вдруг пишете, то точно рекомендую глянуть в эту штуку, чтобы еще чуть-чуть лучше узнать, как же у нас работает garbage collector.
3923.64 3935.56 "Игорь Лабутин" Ну и вообще, в принципе, прикольно получать callback из garbage collector к себе в код, правда в нем надо быть очень аккуратным, потому что это callback из garbage collector, поэтому там нельзя делать ничего, что может вызвать garbage collector, иначе будет рекурсия.
3935.56 3938.68 "Анатолий Кулаков" Ну, т.е. нельзя делать вообще ничего?
3938.68 3949.64 "Игорь Лабутин" Не, ну проверять property можно, там как раз так и делается в этом примере, т.е. ты, грубо говоря, смотришь на reference count, сверяешь его с нулем и возвращаешь true или false.
3949.64 3955.00 "Анатолий Кулаков" Ну ладно, ну сильно не поверяешься, короче, в консольке не выведешь картинку, не нарисуешь.
3955.00 3962.56 "Игорь Лабутин" Ну да, было бы прикольно, конечно, таким образом как-то изнутри garbage collector что-нибудь поделать, но к сожалению, нельзя, может привести к непредсказуемым последствиям.
3962.56 3970.68 "Игорь Лабутин" Опять же, зависит от того, какую часть вы тронете памяти, и что это спровоцирует, и может ли это спровоцировать garbage collection, не знаю.
3970.68 3988.80 "Анатолий Кулаков" Интересно, можно для тестов как раз такую фигню использовать, в этом методе бросать какое-нибудь исключение или выделять какую-то память, и смотреть, насколько твой код хорошо приготовлен к неожиданным исключениям, посреди любой строчки практически в коде, которая вызывает аллокацию может случиться.
3988.80 3994.52 "Игорь Лабутин" Я боюсь, если исключения случатся внутри кода garbage коллектора, то там может весь executioner нафиг упасть,
3994.52 3995.52 "Анатолий Кулаков" а не твое приложение.
3995.52 3998.36 "Анатолий Кулаков" Насколько твое приложение готово к тому, что упадет весь executioner.
3998.36 4006.08 "Игорь Лабутин" Насколько Microsoft готов к тому, что ты из каких-то клубек будешь кидать исключения изнутри garbage коллектора, ну не знаю, не знаю, я не пробовал, без понятия.
4006.08 4026.74 "Игорь Лабутин" Давайте, да, еще, не то чтобы связанная статья, но я их читал вместе, и рассказать их тоже решил вместе, потому что это тоже довольно тонкая штука, которая не факт, что потребуется в реальной жизни, хотя автора, это Сергей Тепляков, встретился с ней на самом деле в реальной жизни.
4026.74 4030.60 "Игорь Лабутин" Вот скажи мне, как часто ты получал stack overflow exception?
4030.60 4040.50 "Анатолий Кулаков" Вообще давно не видел, ну только на каких-то рекурсиях, когда был молодой, зеленый, писал какие-то методы с рекурсией самого себя, а в последнее время нет, не видел.
4040.50 4041.50 "Игорь Лабутин" Не видел.
4041.50 4076.76 "Игорь Лабутин" А вот Сергей, собственно, столкнулся с проблемой, что он получил с прода, ну dump, соответственно, дотентный процесс упал, у него получилось собрать dump, и в дампе было написано, ну точнее, в логах было написано, что это stock overflow, вот смотрим в дамп, ну все хорошо, вроде, все потоки живы, на всех потоках стэк вполне короткий, никакой бесконечной рекурсии судя по call stack нету, ну как бы, а как такая проблема возникла?
4076.76 4085.76 "Игорь Лабутин" Вот он стал изучать и выяснилось, что на самом деле в современном мире в теории вы можете получить такой overflow чуть более часто, чем вы ожидаете.
4085.76 4091.24 "Игорь Лабутин" Значит, напомню, что вообще у нас происходит.
4091.24 4108.96 "Игорь Лабутин" Напомню, что когда у вас рождается поток, у потока по умолчанию есть некоторое количество памяти для стэка, и это по умолчанию, ну оно может зависеть от операционной системы, от разрядности процессора и так далее, но это будет не менее одного мегабайта данных.
4108.96 4122.92 "Игорь Лабутин" И если у вас нет какой-то бешеной рекурсии, или вы не передаете какие-то линейные отсылки на стэки, какие-то огромные массивы, то в целом одного мегабайта обычно хватает среднестатистической программе вообще без проблем.
4122.92 4132.96 "Игорь Лабутин" Но по большому счету у вас проблема в том, что вот этот один мегабайт не выделяется сразу.
4132.96 4146.72 "Игорь Лабутин" Значит, на самом деле он резервируется в адресном пространстве процесса, но лоцируется по дефолту там я не помню, то ли 64 килобайта, то ли сколько-то, то есть несколько страничек стэка и все.
4146.72 4148.96 "Игорь Лабутин" А дальше механизм работает следующим образом.
4148.96 4164.52 "Игорь Лабутин" Вот, допустим, у вас первые 4 страницы отданы под стэк закоммичены, то есть под них выделена реальная память, а пятая страница, то есть следующая, она помечается специальным флагом на уровне операционной системы.
4164.52 4193.40 "Игорь Лабутин" Называется это в винте по крайней мере GuardPage, я подозреваю, что в остальных как-то таким же образом это делается в операционках, и если происходит попытка доступа к этой GuardPage, то внутри операционки срабатывает прерывание, обработчик этого прерывания внутри тотального процесса понимает, что кто-то попытался к этой страничке доступиться, коммитим под нее память, а следующую страничку помечаем как GuardPage, ну чтобы в следующий раз это сделать.
4193.40 4199.56 "Игорь Лабутин" Таким образом стэк у нас растет по мере того, как мы трогаем все больше и больше страниц памяти.
4199.56 4214.96 "Игорь Лабутин" Значит, если мы дошли до одного мегабайтной границы, и у нас нет уже следующей странички, чтобы ее пометить как GuardPage, это собственно и приводит к тому, что мы видим StackOverflowException, то есть это значит, что место в стэке кончилось.
4214.96 4225.80 "Игорь Лабутин" А теперь, соответственно, вопрос, а что же может привести к StackOverflow при условии, что у вас все стэки меньше одного мегабайта?
4225.80 4247.96 "Игорь Лабутин" И тут интересный момент, смотрите, когда мы трогаем вот эту GuardPage, системе нужно закоммитить память, и если система не может закоммитить память под ту страницу, которая была GuardPage, но теперь она должна стать нормальной страницей, кидается не OutOfMemory, а кидается StackOverflow.
4247.96 4261.16 "Игорь Лабутин" Ну типа мы переполнили стэк, в стэке места больше нет, память под него выделить невозможно, несмотря на то, что до лимита мегабайт мы не добрались, но поскольку память в стэке мы выделить не можем, то это ну, типа StackOverflowException.
4261.16 4266.96 "Игорь Лабутин" Как же такое может произойти в реальной жизни, в реальном процессе?
4266.96 4284.00 "Игорь Лабутин" Это может быть вполне нормально, потому что надо не забывать, что у нас сейчас довольно многие процессы и вообще современные там сервисы и не сервисы запускаются иногда с довольно жесткими ограничениями по памяти или по CPU.
4284.00 4291.40 "Игорь Лабутин" Все наверняка видели в каком-нибудь кубернете с конфигурацией, типа выдайте этому поду четверть CPU, что-нибудь в таком духе.
4291.40 4307.44 "Игорь Лабутин" Соответственно, а в винде, например, если мы говорим про винду, есть еще понятие, давно-давно, кстати, есть понятие Джобов, которые умеют ограничивать объем памяти, например, который выделяется заданному процессу.
4307.44 4327.12 "Игорь Лабутин" И для того, чтобы воспроизвести эту проблему, ну и на броде на самом деле у них тоже было примерно такое же, нам нужно два процесса, один процесс, который собственно пытается покушать много памяти, то есть он создает потоки и что-то в них холоцирует, а другой процесс, который стартует первый и делает это не просто так, а внутри Джобобжекта.
4327.12 4353.96 "Игорь Лабутин" При этом вы можете сказать, что но ведь у нас же есть настройка, я про нее, кстати, не знал, ну или знал, но я забыл, которая называется system.gc.hiphardlimit, которая видимо задает, насколько большой хип у нас может вырасти с точки зрения garbage-коллектора, и видимо, как только garbage-коллектор поймет, что объем памяти, занимаемый хипом, достигает этого значения, он будет довольно агрессивно собирать мусор.
4353.96 4357.60 "Игорь Лабутин" Но проблема в том, что адресное пространство потоков не входит в хип.
4357.60 4364.88 "Игорь Лабутин" Это именно адресное пространство потоков, а хип это вот все наши знакомые нулевое, первое и прочее поколение.
4364.88 4376.36 "Игорь Лабутин" Large object heap — вот это все, поэтому эта настройка никак не влияет на вот этот объем памяти, но зато влияют job objects и внешние ограничения, которые вы можете наложить.
4376.36 4392.84 "Игорь Лабутин" Соответственно, Сергей попробовал это воспроизвести, у него все прекрасно получилось, берем одно приложение, оно создает 512 потоков, которые сидят и ничего не делают, ждут сигнала, и в момент, когда этот сигнал приходит, они, каждый из них, аллоцируют просто 64 килобайта на своем стеке.
4392.84 4402.04 "Игорь Лабутин" При этом, дополнительно, перед тем, как стартовать эти потоки, приложение аллоцирует еще там 50 мегабайтиков, чисто чтобы занять побольше памяти.
4402.04 4403.04 "Игорь Лабутин" Массивчик такой.
4403.04 4429.66 "Игорь Лабутин" А дальше берем другое приложение, которое создает job object, причем использует для этого библиотечку Misento Framework win32jobs, которая позволяет, ну не библиотечку, а класс, которая позволяет как раз работать нормально с job objects, там есть еще в этой библиотечке куча всяких других полезных примитивов, которые обычно недоступны и идут на это легко и просто, а только через какие-то странные API.
4429.66 4434.76 "Игорь Лабутин" Создает job object, ставит его процесс memory limit в 100 мегабайт всего-то.
4434.76 4441.24 "Игорь Лабутин" А напомню, что он проаллоцировал один массив на 50 мегабайт, и еще хочет 512 потоков, каждый из них по 64 килобайта забрать.
4441.24 4444.60 "Игорь Лабутин" И все это дело запускает.
4444.60 4493.72 "Игорь Лабутин" В результате, да, мы получаем такой overflow exception, и по сути это может произойти, если у вас, например, ваш процесс так или иначе сильно как-то ограничен по памяти, чем-то сверху, лимитами какими-то, через job object и, возможно, через кубер вы его настолько зажмете, что он просто при попытке нарастить немножко стэк поймет, что он уперся в объем памяти и не сможет закоммитить гард в страничку, хотя в операционке будет еще памяти много и потоки еще не достигнут мегабайта, вы получите стэк overflow и долго будете думать, а почему же у меня столько overflow, где же у меня такая рекурсия, или где я сажал столько мест в стэке, хотя все стэки маленькие, короткие, и все работает вроде как и должно, а это виноват общий лимит на память, это будет не out of memory, из-за особенности того, как работает локация на стэке.
4493.72 4494.72 "Игорь Лабутин" Такие дела.
4494.72 4512.84 "Анатолий Кулаков" Действительно интересная ситуация, я думал, что я уже давно перерос стэк overflow в свои юношеские годы, но оказывается, что наоборот, мы пришли в историю по спирали, оказывается, что стэк overflow у нас теперь может быть из-за наших искусственных докер-контейнеров, кубернетов, совограничений и прочих вот этих песочниц, забавно-забавно.
4512.84 4513.84 "Игорь Лабутин" Такие дела.
4513.84 4517.44 "Игорь Лабутин" Может быть, кому-то это действительно пригодится на практике.
4517.44 4521.36 "Игорь Лабутин" Хотя я тоже очень давно не видел стэк overflow, ну кроме
4521.36 4522.36 "Анатолий Кулаков" рекурсии.
4522.36 4525.48 "Анатолий Кулаков" Ну как минимум блеснуть на собеседованиях-то, да?
4525.48 4530.40 "Игорь Лабутин" Оооо, да, еще одна идея про вопрос на собеседования, да, блин.
4530.40 4533.12 "Анатолий Кулаков" Зря, зря подал, зря подал.
4533.12 4534.12 "Анатолий Кулаков" Да-да-да.
4534.12 4539.00 "Анатолий Кулаков" Давай перейдем к собеседованию, у меня тут как раз следующая темка есть про зарплаты, собеседования и все такое.
4539.00 4546.52 "Анатолий Кулаков" Ну потому что как-то новогодний выпуск останавливает на твоих хардкорах, это людям потом будут сниться как бы страшные сны до следующего года.
4546.52 4554.36 "Анатолий Кулаков" Давай вот что-нибудь такое расслабительное, болтательное, хорошенькое и вот на этом на добром попробуем завершить наш сегодняшний выпуск.
4554.36 4557.88 "Анатолий Кулаков" Тема, которая называется "Исследование рынка дотнет-разработки.
4557.88 4560.36 "Анатолий Кулаков" Анализ текущих тенденций и прогнозы".
4560.36 4561.56 "Анатолий Кулаков" Как тебе?
4561.56 4562.56 "Анатолий Кулаков" Нормально?
4562.56 4564.20 "Игорь Лабутин" Надеюсь, оно будет доброе.
4564.20 4567.68 "Анатолий Кулаков" Вот это мы сейчас и выясним.
4567.68 4606.78 "Анатолий Кулаков" Это анализ, который вышел на хабрик, который собирала компания Fuse8, вообще-таки анализы выходят довольно часто, ну то есть ежегодно, ежегодно для дотнет-разработчиков мы их собираем, там в прошлом году контур, например, делал и мы всегда стараемся распространять такие анализы и этот в том числе мы их расбросывали в dotnext, dotnet.ru, комьюнити, в наших чатах, во всех соцсетях, потому что действительно интересно узнавать, а как дышат именно российские разработчики, потому что подобных анализов в мире или в других странах, они есть, их полно, но вот русской специфики не хватает, поэтому всегда было бы интересно в таких отчетах поучаствовать, я тоже принимал непосредственное участие.
4606.78 4607.78 "Анатолий Кулаков" Игорь, ты заполнял его, нет?
4607.78 4616.14 "Игорь Лабутин" Потому что по-моему, да, мне казалось, но это было, по-моему, довольно давно, и не, вроде заполнял, да, заполнял.
4616.14 4626.90 "Игорь Лабутин" Потому что я вот сейчас читаю заметки наши к вопросу, я что-то не помню часть вопросов, но, наверное, я просто слишком много всего пишу, заполняю и так далее, что просто выветрилось уже из памяти.
4626.90 4633.38 "Анатолий Кулаков" Ну, это не мешает нам сейчас в рантаме все прокомментировать, поэтому практически сейчас заполним с тобой вместе.
4633.38 4634.38 "Анатолий Кулаков" Погнали.
4634.38 4652.58 "Анатолий Кулаков" В общем, для начала статистика, да, то есть у нас принимало в отчете 300 российских дотнет-разработчиков, и не только разработчиков, но среди них встречались руководители, ну то есть, но связанные с дотнет, это только дотнет-разработчики, да, но тут важно уточнить, то есть 300 релевантных дотнет-разработчиков и дотнет-руководителей.
4652.58 4655.26 "Анатолий Кулаков" Ну, в принципе, им нормально, почему бы и нет.
4655.26 4662.78 "Анатолий Кулаков" Так, и авторы прямо в самом заголовке говорят, что один из участников нашего исследования выдал следующую фразу.
4662.78 4667.06 "Анатолий Кулаков" Вопрос ему показался, опрос, опрос показался ему слишком предвзятым.
4667.06 4668.06 "Анатолий Кулаков" Цитирую.
4668.06 4672.58 "Анатолий Кулаков" "Авторы четко пытались навязать мнение, что с дотнет что-то не так.
4672.58 4673.58 "Анатолий Кулаков" Это довольно странно.
4673.58 4679.78 "Анатолий Кулаков" Наверное, авторы одни из тех, кто до сих пор считает, что все закрыто Микрософтом, а дотнет работает только в Виндовсе.
4679.78 4686.06 "Анатолий Кулаков" И так уж случайно совпало, что этот комментарий оставил я.
4686.06 4689.46 "Анатолий Кулаков" Поэтому, мама, я на хабре.
4689.46 4698.94 "Анатолий Кулаков" Я немножко поясню, да, свою позицию, раз уж тут меня процитировали, привели, что какие вопросы меня смутили.
4698.94 4711.62 "Анатолий Кулаков" Опять же, среди вопросов было, насколько быстро дотнет подыхает в вашей компании, как часто вы переписываете дотнет-проекты на другие языки, насколько у вас понизились зарплаты дотнет-разработчиков, насколько из ваших дотнет-команд уходят разработчики.
4711.62 4723.54 "Анатолий Кулаков" Вот подобные вопросы, и от подобных вопросов у меня действительно как бы мурашки по коже пошли, потому что вокруг меня дотнет-проекты появляются, новые команды формируются, новые джуны приходят, как бы новые сеньоры растут.
4723.54 4726.30 "Анатолий Кулаков" Я не понимаю, откуда у людей в головах вот это все берется.
4726.30 4736.74 "Анатолий Кулаков" Но тут же автор как бы поправляется, он уже говорит, что это мнение абсолютно неверное, то есть ничего такого мы в наших опросах не имели в виду, но провокационные вопросы вставили.
4736.74 4747.82 "Анатолий Кулаков" И я думаю, что на вот эти провокационные вопросы как раз я и среагировал, потому что, опять же, если вы хотите какой-нибудь нейтральный отчет собирать, то нельзя так формулировать вопросы.
4747.82 4755.54 "Анатолий Кулаков" Куча как бы иностранных опросов по дотнет-разработке и вообще по другим разработкам, которые сформулированы правильно.
4755.54 4762.50 "Анатолий Кулаков" Они не давят в какую-то сторону, как все хорошо, допустим, у джава, и куда уходят разработчики из дотнета.
4762.50 4763.50 "Анатолий Кулаков" В общем, там таких вопросов нет.
4763.50 4771.42 "Анатолий Кулаков" Если вы хотите как бы более предвзятых, то есть более таких нейтральных ответов, то учитесь задавать менее набрасывающиеся вопросы.
4771.42 4775.14 "Анатолий Кулаков" Но на самом деле, как бы это все лирика и хаханьки.
4775.14 4789.58 "Анатолий Кулаков" Опрос действительно получился довольно интересный, довольно познавательный и поэтому, безусловно, стоит того, чтобы как бы в конце года на него посмотреть и подвести какие-то итоги нашим, здесь в опросе 2 года, нашим 2 годам роста дотнета.
4789.58 4791.18 "Анатолий Кулаков" Давайте посмотрим, что у нас получилось.
4791.18 4798.70 "Анатолий Кулаков" Как я уже сказал, это 300 дотнет-разработчиков и среди них 48% с опытом более 7 лет.
4798.70 4802.14 "Анатолий Кулаков" Ну, это достаточно много, в принципе, 7 лет для индустрии - это хорошо.
4802.14 4806.86 "Анатолий Кулаков" Остальные все, кроме этих 48%, довольно ровным слоем размазались.
4806.86 4818.82 "Анатолий Кулаков" То есть там есть от 1 года до 7 лет, там 5 и так далее, там все довольно ровно размазано, поэтому основная часть составляет опытные разработчики и, в принципе, еще половинка молодежи, которые, в принципе, подтягиваются к нам к старичкам.
4818.82 4828.54 "Анатолий Кулаков" И где у нас вообще применяется дотнет, потому что очень часто существует такой комментарий, что дотнета вообще в мире не видно, где он весь есть, откуда он берется.
4828.54 4833.22 "Анатолий Кулаков" Вся проблема в том, что очень часто он применяется именно в закрытых организациях, и опрос это подтверждает.
4833.22 4843.94 "Анатолий Кулаков" 43% трудятся на финтехе, большой корпорации, большой и малый, средний бизнес, и 17% работают в госсекторе или малом бизнесе.
4843.94 4848.54 "Анатолий Кулаков" 43% финтехе - большой бизнес, корпорации - 17%, это госсектор и малый бизнес.
4848.54 4861.18 "Анатолий Кулаков" То есть видим, что основной объем разработчиков как раз трудится в тех компаниях, которые не привыкли на публику или выносить open source, или кричать на конференциях "смотрите, у нас везде дотнет", вот почему мало его видно.
4861.18 4871.58 "Анатолий Кулаков" Но среди опрошантов были зафиксированы такие большие компании, как Тбанк, Озон, Дода, Акбарс, Контур, РТК, БКС, МТС.
4871.58 4879.34 "Анатолий Кулаков" Ну, в общем, такие явные воротилы, большие банки и много всяких коммуникационных компаний используют дотнет.
4879.34 4882.26 "Анатолий Кулаков" То есть здесь с компаниями, в принципе, все в порядке.
4882.26 4885.26 "Анатолий Кулаков" Ну и такие большие компании, естественно, не стесняются от них.
4885.26 4888.22 "Анатолий Кулаков" И спикеры на конференциях есть, и они сами там митапы делают.
4888.22 4894.26 "Анатолий Кулаков" В общем, обычно они не стесняются дотнет, а здесь легко можно выловить, что он используется.
4894.26 4899.14 "Анатолий Кулаков" Размеры компаний, в которых пишут на дотнет, довольно хорошо так размазаны, распределены.
4899.14 4903.70 "Анатолий Кулаков" Это опрос был от одного там до 500 человек.
4903.70 4910.74 "Анатолий Кулаков" В общем, здесь нельзя выделить, что настолько дотнет используется в больших компаниях или, наоборот, только в маленьких компаниях.
4910.74 4911.74 "Анатолий Кулаков" В принципе, здесь все ровно.
4911.74 4912.74 "Анатолий Кулаков" Распределено довольно четенько.
4912.74 4919.02 "Анатолий Кулаков" То есть даже если вы один пишете на фрилансе какой-нибудь в дотнет-проекте, то вы честно попадаете в эту группу.
4919.02 4924.02 "Анатолий Кулаков" Или если у вас компания на 500 и более человек, то тоже здесь полно разработчиков.
4924.02 4929.42 "Анатолий Кулаков" Нельзя выделить дотнет только для интерпрайз или только для каких-то фрилансеров, только для каких-то соло-программистов.
4929.42 4932.90 "Анатолий Кулаков" Нет, хорошо размазывается, решает огромный спектр проблем.
4932.90 4934.58 "Анатолий Кулаков" Про образование.
4934.58 4941.86 "Анатолий Кулаков" Довольно высокий уровень, почти 74% имеют высшее образование в компьютерных науках или программной инженерии.
4941.86 4949.46 "Анатолий Кулаков" Ну, то есть прямо у нас сплошные ученые сидят и говорят, у тебя есть образование на компьютерных науках?
4949.46 4954.94 "Игорь Лабутин" Ну, на тот момент у нас кафедра не называлась прям компьютерных наук.
4954.94 4961.26 "Игорь Лабутин" Типа у меня математика что-то там, но фактически, да, у меня высшее образование в ИТ.
4961.26 4963.94 "Анатолий Кулаков" Ну, мне кажется, да, математика вполне может считаться.
4963.94 4974.50 "Анатолий Кулаков" У меня высшее образование в секьюрити, в специалистах информационной безопасности, но тоже там плотно с техникой связаны, то есть примерно тоже можно считать с ИТ.
4974.50 4983.22 "Анатолий Кулаков" И 26% не через высшее образование пришли, а пришли через самообучение, онлайн-курсы, книги и так далее и тому подобное.
4983.22 4985.30 "Анатолий Кулаков" И что здесь интересное?
4985.30 5000.46 "Анатолий Кулаков" Когда был список того, какие там курсы, образование и все такое, вы смотрите, на каких вы учились, там было много хороших интересных курсов, там в числе конференций .next мелькало, но что самое интересное, нигде не упоминался наш подкаст.
5000.46 5003.38 "Анатолий Кулаков" Ну, да ладно этот подкаст, нигде не упоминался .net.ru.
5003.38 5007.38 "Анатолий Кулаков" Слушай, ну мы сделали уже метапов, наверное, больше, чем .next.
5007.38 5011.22 "Анатолий Кулаков" Ну, если считать с подкастами, то точно уже больше, чем .next.
5011.22 5012.22 "Анатолий Кулаков" Почему никто не учится на наших материалах?
5012.22 5013.22 "Игорь Лабутин" Я не пойму.
5013.22 5015.86 "Игорь Лабутин" Ну, может, и учатся, просто не спрашивают про нас.
5015.86 5019.02 "Анатолий Кулаков" Ну, там не спрашивают, там люди говорят, где учились.
5019.02 5021.02 "Игорь Лабутин" А, в этом смысле?
5021.02 5032.74 "Игорь Лабутин" Ну, непонятно, непонятно, видимо, у нас пока не воспринимают именно как обучающую часть, то есть как подкрепляющую, может быть, а как обучающую, ну просто еще один видосик в интернете.
5032.74 5034.62 "Анатолий Кулаков" Ну, мы, блин, для кого-то распинаемся.
5034.62 5041.38 "Анатолий Кулаков" Так, товарищи слушатели, вот в следующий раз, когда вас будут спрашивать, вы как учитесь, указывайте там хотя бы .net.ru или хотя бы там радио.
5041.38 5053.30 "Анатолий Кулаков" Ну, радио, ладно, у нас довольно узко специализировано, но .net.ru, в рамках которого мы все это вещаем, ну, надо бы, надо бы хоть немножко себя в отчетах-то видеть, а то как-то стараемся, стараемся, а на нас даже не учатся.
5053.30 5055.70 "Анатолий Кулаков" Ну, ладно, пойдем дальше, все это лирика.
5055.70 5061.34 "Анатолий Кулаков" Востребованные технологии, то есть что ищут работодатели, когда хотят нанять себе .net разработчика?
5061.34 5068.46 "Анатолий Кулаков" Там большущий список, если вы хотите, там полный список, посмотрите оригинальную статью, я лишь там топ какой-то скажу сверху.
5068.46 5073.38 "Анатолий Кулаков" Ну, во-первых, как ни странно, почему-то работодатели, которые ищут .net разработчиков, хотят знания C#.
5073.38 5077.34 "Анатолий Кулаков" Не, ну, F# там тоже есть, но там где-то далеко и все такое, ну, C#.
5077.34 5079.74 "Анатолий Кулаков" На втором месте меня поудивило, это Docker.
5079.74 5083.58 "Анатолий Кулаков" Как тебе кажется, Docker, это прям достойно второго места в C#?
5083.58 5090.02 "Игорь Лабутин" Ну, Docker, как и там базы данных, как и все остальное, там базы данных тоже наверняка где-то рядышком.
5090.02 5094.10 "Анатолий Кулаков" Ну, где-то рядышком, но на втором это Docker, ну, то есть выше, чем базы данных.
5094.10 5100.86 "Игорь Лабутин" Ну, надо же куда-то приложение деть, а куда ты его сейчас денешь в современном мире, кроме как в Docker?
5100.86 5102.10 "Игорь Лабутин" В ИС отправишь.
5102.10 5106.02 "Анатолий Кулаков" Нет, ну, просто чтобы у тебя было приложение, тебе C# недостаточно.
5106.02 5109.50 "Анатолий Кулаков" Тебе достаточно какой-нибудь хотя бы REST API, который на третьем месте.
5109.50 5119.10 "Игорь Лабутин" Ну, не обязательно, может быть, у меня асинхронная обработка искавки и посылка дальше, и мне вообще не нужен API.
5119.10 5125.54 "Анатолий Кулаков" Ну, может быть, но кажется, что асинхронных обработок искавки намного меньше, чем REST API, он у нас должен быть в индустрии.
5125.54 5139.00 "Игорь Лабутин" Нет, ну смотри, каждый, кто занимается REST API отметил Docker, поэтому они должны быть поровну, но еще кто-то, кто не занимается REST API, но тоже отметил Docker, и вот тебе как бы Docker чуть-чуть победил.
5139.00 5143.66 "Анатолий Кулаков" Ну, ладно, ладно, окей, такой подходит, такой аргумент защиты.
5143.66 5153.10 "Анатолий Кулаков" В общем, если вы дотнет-разработчик и не знаете Docker, то задумайтесь, это та технология, которую очень много работодателей требуют, хотят, и надо выучить, надо выучить.
5153.10 5159.02 "Анатолий Кулаков" Типа там ничего сложного нет, опять же, вас никто не заставляет во внутрянке копаться, вам нужно там сбилдить имидж, запустить и все такое.
5159.02 5167.64 "Анатолий Кулаков" Если сами не можете, опять же, пишите, у нас теперь оказывается образовательный подкаст, поэтому пишите, раскопаем вам статейку про Докера для дотнет-разработчика, все объясним на пальцах.
5167.64 5169.38 "Анатолий Кулаков" Как я уже сказал, ответим REST API.
5169.38 5173.14 "Игорь Лабутин" И будем диктовать команды Докера вот так вот голосом.
5173.14 5177.14 "Игорь Лабутин" Docker run, минус, минус, вот это все.
5177.14 5180.42 "Анатолий Кулаков" Еще читать, а output тоже будем читать вслух.
5180.42 5190.74 "Игорь Лабутин" Обязательно, с этими гуидами, не гуидами, как там эти, хэшами образов, без них никак, 3F4C.
5190.74 5203.38 "Анатолий Кулаков" REST API на третьем и ASP на четвертом, да, опять же, по твоей же логике, наверно, те, кто делает ASP, он всегда указывает REST API, плюс кто-то еще пишет REST API без знания ASP.
5203.38 5205.22 "Игорь Лабутин" Ну смотри, пока все укладывается.
5205.22 5217.26 "Анатолий Кулаков" Ну хорошо, следующий из ASP у нас идет знание Postgre, Postgre SQL, после Postgre у нас Entity Framework, Swagger OpenAPI, ну и дальше по мелочи пошли.
5217.26 5220.26 "Анатолий Кулаков" Ну то есть вот основные технологии, в принципе, довольно предсказуемо.
5220.26 5226.14 "Игорь Лабутин" Ну я бы сказал обычный стандартный .NET стек, наверное, максимально популярный.
5226.14 5230.74 "Игорь Лабутин" EF, Postgre, REST API, ASP.NET, C#.
5230.74 5235.58 "Игорь Лабутин" Запаковать в Docker, выставить наружу OpenAPI и в общем все.
5235.58 5237.54 "Игорь Лабутин" И заметь, можно не тестировать.
5237.54 5246.58 "Анатолий Кулаков" Ну да, требования тестирования здесь не входят в топ, опять же, где-то может быть далеко, но в топ его нет.
5246.58 5255.10 "Анатолий Кулаков" Но опять же, если вы начинающие .NET разработчики и думаете, чтобы такое подтянуть, чтобы такое подучить, то хороший список, посмотрите на него.
5255.10 5256.10 "Анатолий Кулаков" Поехали дальше.
5256.10 5272.66 "Анатолий Кулаков" У нас в российском интернете победил .NET Core, 27% говорят, что им необходимы знания .NET Framework, то есть эти знания все еще востребованы, а все остальные полностью говорят, что .NET Core рулит и бибикает, им больше ничего в этой жизни не надо.
5272.66 5275.70 "Анатолий Кулаков" В принципе, довольно высокий показатель, особенно если мы сравним с мировым.
5275.70 5281.50 "Анатолий Кулаков" В прошлом году мы разбирали отчет, в котором там .NET Framework было еще ого-го, ого-го.
5281.50 5289.50 "Анатолий Кулаков" Мы, наверное, разберем мировой отчет уже в январе к какому-то следующему выпуску, но пока тенденция довольно хорошая.
5289.50 5290.50 "Анатолий Кулаков" Секция зарплата.
5290.50 5291.50 "Анатолий Кулаков" Что же может быть?
5291.50 5292.50 "Анатолий Кулаков" Какой отчет без зарплаты?
5292.50 5293.50 "Анатолий Кулаков" Он совсем не полный.
5293.50 5295.22 "Анатолий Кулаков" Давайте поговорим про чужие деньги.
5295.22 5302.38 "Анатолий Кулаков" 78% всех опрошенных сказали, что их зарплата выросла за последние два года.
5302.38 5306.26 "Анатолий Кулаков" То есть тут никакой стагнации, никакой речи идти не можно.
5306.26 5309.14 "Игорь Лабутин" Но было бы странно, если бы она вообще не выросла.
5309.14 5313.46 "Игорь Лабутин" Хоть как-то-то она выросла, но вопрос на сколько?
5313.46 5316.46 "Анатолий Кулаков" Ну, в принципе, вырастала она тоже неплохо.
5316.46 5321.02 "Анатолий Кулаков" На 25% всех опрошенных заявили, что у них зарплата выросла на 60%.
5321.02 5324.22 "Анатолий Кулаков" То есть в полтора раза подогнало, неплохо.
5324.22 5330.06 "Анатолий Кулаков" Ещё 20% заявили о росте в 20-30%, ну тоже неплохо.
5330.06 5335.06 "Анатолий Кулаков" Ну то есть растёт, растёт на ощутимые процентики, на ощутимые цифры.
5335.06 5337.06 "Анатолий Кулаков" Почему бы и нет, хорошо растёт.
5337.06 5338.06 "Игорь Лабутин" Неплохо, неплохо.
5338.06 5343.74 "Игорь Лабутин" Вопрос, опять же, базового уровня, ну как обычно проценты – это хорошо.
5343.74 5348.86 "Игорь Лабутин" Вопрос откуда начинаем, но верю, что всё-таки нормально.
5348.86 5353.82 "Анатолий Кулаков" Ну, в целом кажется, что она по рынку примерно соответствует, как и у остальных людей.
5353.82 5356.14 "Анатолий Кулаков" Остальных я имею в виду бэкендеров.
5356.14 5365.42 "Анатолий Кулаков" Кстати, 60% заявили, что считают, что их зарплаты примерно равны другим бэкендерам с других стэков, которые есть на рынке.
5365.42 5369.66 "Анатолий Кулаков" Ну, 40% считают, что да, где-то не равны, где-то нас поджимают или, может, даже платят больше.
5369.66 5379.26 "Анатолий Кулаков" Так, погнали, из интересного, с фулл стэк разработчиками себя считают 31%, притом фулл стэк они включали в том числе и Блейзер.
5379.26 5400.98 "Анатолий Кулаков" То есть это не только какой-то там джаваскриптовский ангуляр, а Блейзер это вполне себе платформа, которая позволяет вам теперь называться фулл стэком, потому что пишите на полк на джаваскрипте, не зная джаваскрипта, пишите UI, которая вполне интерактивная, вполне красивая, отлично запускается на ВВС, блин, то есть почему нет, нормуль, Блейзер бибикает.
5400.98 5408.42 "Анатолий Кулаков" И, наверное, один из самых интересных вопросов – это посоветовали бы вы начинающим новичкам начинать с дотнета.
5408.42 5416.06 "Анатолий Кулаков" То есть подходит ли дотнет-платформа, дотнет-язык, экосистема, комьюнити и все вот это окружение, с которым вы сейчас обращаетесь, для выбора новичков.
5416.06 5432.94 "Анатолий Кулаков" И таки да, 84% ответили, что дотнет – это отличный выбор для новичков, ну то есть это простой язык, прокачанная платформа, хорошая комьюнити, довольно приятные программы получаются.
5432.94 5440.22 "Анатолий Кулаков" В общем, я полностью согласен, самый, мне кажется, прекрасный язык, который существует на данный момент – это вот дотнет.
5440.22 5444.54 "Анатолий Кулаков" Он стабильный, подержимый, красивый, в общем, мне нет к чему придаться практически.
5444.54 5446.54 "Анатолий Кулаков" Игорь, ты как считаешь?
5446.54 5469.54 "Игорь Лабутин" Да, мне кажется, прекрасно подходит, особенно с учетом того, что сейчас происходит с C#, нам хоть и не нравятся в каком-то смысле некоторые изменения, но он действительно, ну не то, что приближается к каким-то языкам типа питона, но выбирает в себя некоторые полезные штуки типа Collection Expressions, Ren'J там еще что-нибудь в таком духе.
5469.54 5481.30 "Игорь Лабутин" И если не иметь вот всего того багажа C#, который знаем мы, те, кто пишет на нем с древних версий, и учить его с нуля только по каким-нибудь современным гайдам, мне кажется, вполне легко вкатиться.
5481.30 5496.70 "Игорь Лабутин" Второй момент, который полезен и удобен в дотнете, это, ну я бы сказал, не то что единство экосистемы, но то, что у тебя практически сразу все есть из коробки и более-менее понятный дефолт.
5496.70 5507.66 "Игорь Лабутин" То есть вот то, как я сказал, да, там ASP.NET, REST API, PASSGRIP, C#, то есть EF опять же, у тебя нет там посиделок, задумчивости.
5507.66 5510.22 "Игорь Лабутин" Какой бы мне ORM выбрать?
5510.22 5513.90 "Игорь Лабутин" Ну, можно повыбирать, у нас есть там и другие ORM'ы.
5513.90 5522.58 "Игорь Лабутин" NHibernate, не знаю, жив он сейчас или не жив, link2db, но это все-таки такие более нишевые штуки, когда ты уже понимаешь, что происходит.
5522.58 5526.90 "Игорь Лабутин" Это так, бери EF, бери ASP.NET, бери C#, и все у тебя получится по большому счету.
5526.90 5530.26 "Игорь Лабутин" 95% работы можно сделать на них, наверное.
5530.26 5541.62 "Анатолий Кулаков" Да, полностью с собой согласен, как раз вот тот список, который есть, это обычный дефолт, вам нужно его знать, и если вы его знаете, то 95% всех работодателей вас примут с распространенными объятиями.
5541.62 5549.50 "Анатолий Кулаков" То есть нет такого, что там каждый месяц выходит новый фреймворк, вам нужно в голове держать 10 заменителей, 30 реплейсеров, нет, вот понятный, хороший дефолт.
5549.50 5552.78 "Анатолий Кулаков" При том, если вам нужно шаг влево, шаг вправо, тоже есть альтернативы.
5552.78 5558.38 "Анатолий Кулаков" И это большой плюс платформы, тут никуда не денешься.
5558.38 5559.38 "Анатолий Кулаков" Пойдем дальше.
5559.38 5562.46 "Анатолий Кулаков" Итак, перспективы .NET в российских компаниях.
5562.46 5564.66 "Анатолий Кулаков" Что же у нас происходит с командами?
5564.66 5573.06 "Анатолий Кулаков" Зарплату мы уже обсудили, насчет команд, и здесь тоже, что вопрос показал, что команды или остаются прежних размеров, или растут.
5573.06 5577.26 "Анатолий Кулаков" Больше у половины респондентов команды за последние 2 года расширились и выросли.
5577.26 5582.42 "Анатолий Кулаков" То есть видно не стагнация, даже не деградация, не стабильность, а рост.
5582.42 5583.42 "Анатолий Кулаков" Альтернативный рост.
5583.42 5596.42 "Анатолий Кулаков" И ограничения на продажи от Microsoft, которые тут у нас случились внезапно, разработчики сказали, что они им абсолютно не мешают, никак не затронут, в принципе, они сильно не ощущают никаких ограничений от Microsoft.
5596.42 5605.62 "Анатолий Кулаков" Примерно одинаковое количество .NET проектов сейчас находится на поддержке и пишется с нуля, с точки зрения испытуемых, то есть новые проекты появляются на .NET, новые проекты пишутся, их половина.
5605.62 5610.34 "Анатолий Кулаков" Это хорошая тенденция, в принципе, старое не забрасывается, новое пишется, все прекрасно.
5610.34 5621.06 "Анатолий Кулаков" Четыре процента, вот эти вот маленькие небольшие четыре процента рассказали, что сталкивались с необходимостью перевода существующих .NET проектов на какой-то другой стэк.
5621.06 5625.02 "Анатолий Кулаков" То есть их по какой-то причине заставали переводить существующие проекты на другой стэк.
5625.02 5629.50 "Анатолий Кулаков" В основном это были стэки Go, Java и JavaScript.
5629.50 5635.34 "Анатолий Кулаков" Игорь, у тебя есть предположение, зачем переводить .NET на другой стэк, если у тебя уже это написано?
5635.34 5636.34 "Анатолий Кулаков" Какая причина?
5637.34 5650.90 "Игорь Лабутин" Ну унификация, возможно, если, например, у тебя был комплекс из сотни продуктов, написанных на Java и один на .NET, то, может быть, проще все переписать на Java и держать только Java разработчиков.
5650.90 5659.94 "Игорь Лабутин" И если у тебя особенно ребята, которые не хотят переключаться между стэками, потому что есть те, кому все равно на чем писать.
5659.94 5663.90 "Игорь Лабутин" Окей, сегодня пишем на Java, завтра на .NET, потом опять на Java, почему нет.
5663.90 5670.66 "Игорь Лабутин" То есть я думаю, что скорее из таких соображений, просто некая унификация.
5670.66 5676.98 "Анатолий Кулаков" Ну, окей, почему нет, в принципе, в статистическую погрешность укладываемся.
5676.98 5682.50 "Анатолий Кулаков" Еще интересный вопрос, язык на котором бы вы стали писать, если бы не .NET.
5682.50 5691.02 "Анатолий Кулаков" .NETчики, скорее всего, перешли бы на Java, ну, наверное, да, понятный выбор, в принципе, две самых близких экосистемы у нас.
5691.02 5694.58 "Анатолий Кулаков" Но, мне кажется, это те люди, которые ни разу не писали на Java.
5694.58 5699.62 "Анатолий Кулаков" То есть, если бы они пописали хотя бы немножко после того, как перешли, и сбежали бы оттуда как от огня.
5699.62 5705.10 "Анатолий Кулаков" Ну, там же есть Kotlin, подожди, в этой экосистеме есть
5705.10 5706.10 "Игорь Лабутин" Kotlin.
5706.10 5710.74 "Анатолий Кулаков" Ну, опять же, на Kotlin почему-то стремятся не так много, как на Java.
5710.74 5714.62 "Анатолий Кулаков" Может потому, что люди не знают про Kotlin или еще что-то.
5714.62 5736.66 "Игорь Лабутин" Ну, мне кажется, что это просто возможно те, кто не пробовал и просто слышали, знают, что есть экосистема JVM, да, там есть как бы Java, Kotlin, ну, типа Kotlin получше, там выбрал всякие-то новые идеи, но, возможно, типа там менее раскручены, не знаю, не везде применяется и так далее, а Java как бы, она шире, ну, в смысле, больше применяется по разным местам, по разным обработодателям.
5736.66 5746.42 "Анатолий Кулаков" Ну, да, типа того, ну, я думаю, на Java, если вы хотите писать на .NET втором, просто втором, вот, например, вам хочется на Java тогда идти.
5746.42 5766.74 "Анатолий Кулаков" На следующий после Java, да, это Go, мне кажется, здесь тоже люди больше наслышаны на хайпе, чем нас по-настоящему пробовали на нем писать, потому что концепции от .NET безумно сильно отличаются и безумно не в ту сторону, куда привыкли .NETчики, то есть, кажется, что тоже мало кто писал на Go из тех, кто хочет.
5766.74 5789.78 "Анатолий Кулаков" Третьим по упоминанию идет у нас Python, опять же, динамический язык, наверное, на динамический язык тоже с хорошей строгой типизацией будет переходить сложно, несмотря на то, что Python сейчас движется в сторону более строгой типизации, но она там сделана настолько из-за того, что люди, которые привыкли к нормальной типизации, на этом жить будет больно.
5789.78 5818.38 "Анатолий Кулаков" На четвертом месте это Kotlin, это, наверное, самый близкий язык, который сейчас есть к .NET, недаром он в себя впитывал очень много всего из C#, то есть, Kotlin сильно вдохновлен C#, и, наверное, на него легче всего будет перейти .NET разработчикам, и там они будут чувствовать более-менее комфортно, более-менее потому, что в любом случае в Kotlin из-за всех щелей торчат легоси Java, смотрите пункт первый, поэтому сильно вам комфортно там не будет.
5818.38 5842.22 "Анатолий Кулаков" Ну и JavaScript на последнем месте, опять же, строго типизированный там только TypeScript, в общем, если на TypeScript то более-менее жить можно, но опять же, это строго типизированный только в момент дизайна, только в момент разработки, как только у вас появляется там рантайм, там же опять все еще хуже, чем у Java и Python вместе взятых, поэтому тоже сомнительная такая характеристика.
5842.22 5850.58 "Анатолий Кулаков" Вообще, смотри, Игорь, если мы сейчас задумаемся с тобой, а куда идти с .NET, чтобы было вот не больно, так же прекрасно и так же хорошо, некуда пойти?
5850.58 5880.58 "Игорь Лабутин" Ну, да, наверное, прям вот так вот совсем некуда, но идти на Kotlin, наверное, это максимально близкое, если вам не надо углубляться совсем вглубь, ну а дальше зависит от того, что вам нужно, вот там кому-то и на Python будет нормально, я вот тут программировал на Python, ну, жить можно, в принципе, другое дело, что как бы проект был небольшой, да, если бы писать проект размера, как у нас на .NET, то, конечно, сложнее было бы.
5880.58 5887.38 "Анатолий Кулаков" Ну, да, на Python я тоже там скриптики ваяю, но как представлю, какой-нибудь свой рабочий проект переписать, да, ну, никогда бы в жизни.
5887.38 5900.22 "Игорь Лабутин" Не-не, у нас был нормальный именно REST-сервер вполне себе, endpoints 15, наверное, если ты о чем-то говоришь, да, это же ни о чем не говорит, потому что бизнес-логика, понятно, что она не зависит от количества endpoints.
5900.22 5926.70 "Игорь Лабутин" Да не, ну, жить можно, просто вопрос в том, что может быть в, ну, в современном мире микросервисов, когда действительно микро, ну, просто будешь писать более микрокусочки и ловить проблему просто в других местах, там, где ты взаимодействуешь, сеть, вот это все, eventual consistency, ну, как бы, а там внутри одного проекта можно и потерпеть без типов маленького, поэтому не знаю, не знаю.
5926.70 5927.70 "Игорь Лабутин" Ну, может быть, да.
5927.70 5944.06 "Игорь Лабутин" Понятно, что по дефолту, наверное, я бы выбрал там, если нужно было бы прямо именно выбрать, куда уйти из дот-нета, я бы, наверное, выбрал Kotlin, но так сложилось, что там по работе я пишу на дот-нете Java и Python, ну, и в принципе, как бы, пока не умер, как видите.
5944.06 5945.06 "Игорь Лабутин" Ага, вот.
5945.06 5948.14 "Анатолий Кулаков" Ну, да, только об этом, про garbage collector нам рассказываешь.
5948.14 5949.14 "Анатолий Кулаков" Наверное, скучаешь.
5949.14 5950.14 "Анатолий Кулаков" Скучаю.
5950.14 5951.14 "Анатолий Кулаков" Скучаешь.
5951.14 5952.14 "Анатолий Кулаков" Это, да.
5952.14 5971.38 "Игорь Лабутин" Нет, ну, в смысле, скучаю, я на дот-нете тоже пишу, то есть, как бы, не то, что я совсем уже забросил дот-нет, нет, было бы странно, но да, писать на других языках тоже можно, и в принципе, это иногда, как сказать, это полезно иногда делать, чтобы понимать вообще, что происходит с языками, с индустрией, и вообще, какие подходы есть.
5971.38 5973.30 "Игорь Лабутин" Может, что новенького и узнаете.
5973.30 5982.18 "Анатолий Кулаков" Да, я тебя полностью поддержу, как бы, никогда не замыкайтесь в своей экосистеме, всегда пробуйте, хоть немножко, хоть чуть-чуть, но на различных языках пописать.
5982.18 5988.26 "Анатолий Кулаков" Опять же, если бы люди пробовали, они бы никогда первую строчку не поставили в Java, я больше, чем уверен, как бы.
5988.26 6005.62 "Анатолий Кулаков" Пробуйте писать, смотрите, особенно вот скриптовые языки, типа Kotlin, TypeScript, на них можно просто писать какие-нибудь бытийские, обычные сценарии, которые вы выполняете каждый день, автоматизировать, ничего плохого от этого не будет, потеряете совсем немножко времени, но зато проникнетесь альтернативной системой.
6005.62 6012.10 "Анатолий Кулаков" Особенно, если вы проникнетесь с JavaScript environment, опять же, вы бы его тогда в этот список и близко не внесли.
6012.10 6013.94 "Анатолий Кулаков" Ну что ж, давай подводить итоги.
6013.94 6018.90 "Анатолий Кулаков" Цитата, цитата автора статьи, "Направление, конечно же, не умирает".
6018.90 6022.10 "Анатолий Кулаков" Это, опять же, возвращаясь к моему предыдущему пассажу.
6022.10 6035.38 "Анатолий Кулаков" Если составлять все вопросы с термином "не умирает", "не уходит", "не разоряется", "зарплаты не пропадают", то волей-неволей будешь думать, что автор немножко вне Дотнета живет.
6035.38 6038.22 "Анатолий Кулаков" Конечно же, направление не умирает.
6038.22 6042.50 "Игорь Лабутин" К сожалению, Дотнет все еще не умирает, пишет автор статьи.
6042.50 6046.46 "Анатолий Кулаков" Ну, практически, практически, поэтому можно переформулировать.
6046.46 6069.22 "Анатолий Кулаков" Направление цветет, пахнет, зарплаты растут, проекты развиваются, новые проекты пишутся, разработчики абсолютно довольны тем, что творится вокруг, сообщество живет, например, наш великолепный подкаст, который как раз таки и является продуктом сообщества, по сути, да, то есть два человека собрались, как бы ни от кого независимо, несут какую-то чушь про Дотнет, сообщество живет, радуется и прекрасно себя чувствует.
6069.22 6090.14 "Анатолий Кулаков" Поэтому огромное спасибо FUSE8, отличный получился рейтинг, опрос, история, статистика, в общем, хорошая статья, мне понравилось, собирайте такие анонсы и в следующем году будем сравнивать, будем смотреть, ну, всем Дотнет-разработчикам только порадоваться, потому что в принципе все хорошо, все путем, развиваемся, делаем дальше свою работу.
6090.14 6100.26 "Игорь Лабутин" Это все верно, Дотнет никуда не девается, и мы тоже продолжаем выходить, рассказывать новости, раз новости есть, значит, все живет и все прекрасно.
6100.26 6115.78 "Игорь Лабутин" Давайте потихонечку будем закругляться, расскажем немножко коротеньких новостей, значит, важная новость, как мне кажется, интересная, я ее довольно давно ждал, потому что были намеки, что так оно и будет, и вот оно случилось.
6115.78 6219.98 "Игорь Лабутин" Если вы пользовались линкпадом на винде, как я это делал, и почему-то пересели на макос, как я это сделал, то вы наверное, может быть, страдали от того, что линкпада нет, так вот теперь он есть, сейчас вышла пока бета-версия, линкпад 8 для макоси, благодаря тому, что есть продукт под названием Avalonia XPF, который по сути берет, ну, практически любое WPF-приложение и подменяя всю внутрянку WPF, то есть backend, так сказать, WPF, позволяет работать не на винде, а на любой операционке, на линкосе, либо на макоси, это потребовало довольно серьезных переписываний линкпада, то есть там довольно много UI поменялось, сейчас еще много чего не работает, то есть не работает отладчик, не работает синтекс 3 визуалайзер, если вам это надо, вдруг если вы росландские деревья рассматриваете, графики нельзя строить, или спай нельзя смотреть, f# не поддерживается, это все еще in progress, на сайте есть прям списочек, что еще не работает, но при этом в том режиме, в котором я его обычно использую, то есть написать какие-то простейшие сниппеты, посмотреть, как они исполняются, какие там, не знаю, во что чел конвертируется, я его, например, довольно часто использую, там, не знаю, поэкспериментировать с какими-то там форматами даты, да, вот, или что-нибудь такое, когда можно передавать много-много разных опций, и просто хочется посмотреть, во что это превратится, вот, для таких экспериментов это все уже работает, я посмотрел, нормально, прекрасно, замечательно работает, и очень я доволен, что он вышел, вероятно, Джо Бахари, который автор, довольно быстро его допилит до полного состояния, и будет совершенно шикарно.
6219.98 6229.22 "Анатолий Кулаков" Я тоже являюсь активным пользователем Linkupad, поэтому тоже рад, и у меня тоже есть ноутбук на Mac оси, поэтому обязательно попробую, спасибо.
6229.22 6278.30 "Анатолий Кулаков" Так, у меня из новостей довольно разрозненный, давайте начнем с анонса того, что GitHub объявил, что Copilot теперь свободен для всех, то есть, я напомню, раньше он был закрыт довольно дорогим тарифом, ну, как дорогим, это был закрыт деньгами, короче, сейчас у вас, у каждого есть возможность бесплатно его попробовать, здесь есть тонкости, ну, естественно, бесплатный тариф и все такое, был анонсирован Copilot для Visual Studio Code и GitHub, не очень понятно, почему Copilot ограничен только Visual Studio Code, потому что Visual Studio ходит через обычный API, и, наверное, любому плагину ничего не мешает ходить через этот API, в общем, я пока тонкости не проверил, действительно ли они как-то только для Visual Studio Code ограничивают, или, в принципе, всем, кто может доступиться по API через Copilot и через их API, это все будет доступно.
6278.30 6282.58 "Анатолий Кулаков" Ну, в общем, анонсировался только Visual Studio Code, и посмотрим, что будет дальше.
6282.58 6299.78 "Анатолий Кулаков" В бесплатный план входят 2000 Code Completions и 50 сообщений в чате на месяц, тоже не знаю на практике, насколько это разумные цифры, потому что, конечно, 50 сообщений в чате, это вообще ни о чем, за пару дней, я думаю, их можно легко вообще исчерпать.
6299.78 6313.50 "Анатолий Кулаков" Ну, нам нужно больше, наверное, мнений по этому поводу, если вы вдруг пользуетесь Copilot, то придите, расскажите, насколько вам этих лимитов, насколько вам их хватает, насколько можно жить на этом фриплане, если совсем ничего не платить.
6313.50 6323.06 "Анатолий Кулаков" Еще одна интересная новость, это я послушал подлодку выпуск 395, который называется «Дизайн API библиотек».
6323.06 6334.98 "Анатолий Кулаков" Мне очень понравился, потому что многие люди действительно не задумываются, когда пишут код, не задумываются именно о дизайне того контракта, того API, который они предоставляют наружу.
6334.98 6360.42 "Анатолий Кулаков" А на самом деле автор выдал довольно интересную мысль, что действительно тот API, который мы пишем, он гораздо важнее имплементации, потому что имплементацию вы можете переписать потом, подставить другую, не знаю, показать коллегам и они ее как-то починят, а вот API, который вы сделаете, он практически на века, и как только вы его отдаете в паблик, его начинают использовать и все.
6360.42 6367.06 "Анатолий Кулаков" После этого поменять, удалить, переговорить, передиректить – практически бесполезно.
6367.06 6386.90 "Анатолий Кулаков" Мы не раз упоминали в наших выпусках, как Microsoft пытается и задеприкейтить, и вводить экспериментальные атрибуты, и писать какие-то сообщения, выдавать какие-то анонсы, но в общем случае нужно смириться, что публичный API, если у вас есть, и вашу библиотеку или ваше приложение заиспользовали, то это практически навсегда, вы обязаны будете его использовать.
6386.90 6390.90 "Анатолий Кулаков" Поэтому к проектированию API нужно подходить очень тщательно.
6390.90 6408.02 "Анатолий Кулаков" И, например, самая банальная проблема, которая приходит на ум – это придумывание названия переменных, она здесь увеличивается стократно, потому что вам нужно не только название переменных придумать, вам нужно придумать там название методов, название параметров, название классов, в общем это название, их там фигурирует абсолютно везде.
6408.02 6432.86 "Анатолий Кулаков" А потом еще нужно правильно структуру продумать, а потом нужно еще удобство продумать, API по возвращению ошибок, и в общем очень много всего интересного упоминается, там уровни абстракции, как поступать с историческим наследованием, как держать обратную совместимость, как бороться с незназначностью естественного языка, особенно если языков много, то есть в мире существует много языков, что с этим делать, чтобы вас понимали, ваш API.
6432.86 6450.38 "Анатолий Кулаков" Очень много интересных вещей затрагивается в этом выпуске, поэтому посмотрите, мне кажется, каждому разработчику будет интересно, даже если вы напрямую не занимаетесь каким-то дизайном общего API, который торчит в интернет через какой-нибудь REST API, а просто проектируете классы и методы этих классов, это тоже API.
6450.38 6458.58 "Анатолий Кулаков" Когда вы думаете, а как класс написать, какой класс нужен, как назвать этот метод, какие параметры метод должен принимать, а с этим сталкиваются абсолютно все разработчики.
6458.58 6462.54 "Анатолий Кулаков" Поэтому послушайте, может и интересные-интересные мысли автора тоже вас достанут.
6462.54 6469.50 "Анатолий Кулаков" Далее, продолжим знакомство с деятельностью SPB.net сообщества.
6469.50 6473.82 "Анатолий Кулаков" За это время в Питере прошел еще один митап, на котором было два доклада.
6473.82 6480.42 "Анатолий Кулаков" Антон Черняев рассказал, как подружить .NET и пост VSQL Serializable с параллельностью.
6480.42 6494.18 "Анатолий Кулаков" У Антона на работе возникала ситуация, когда они начали использовать Serializable с транзакцией, и с этим уровнем транзакции связано очень много интересных подводных камней, которые просто так в голову не придут.
6494.18 6499.54 "Анатолий Кулаков" Казалось бы, это самый надежный уровень транзакции, вы его включаете и все ваши проблемы сразу решены.
6499.54 6507.26 "Анатолий Кулаков" На самом деле это не так, вы его включаете и у вас проблемы только начинают появляться, и это абсолютно не перформанс, как вам сначала могло бы показаться.
6507.26 6509.38 "Анатолий Кулаков" Это абсолютно много других неочевидных вещей.
6509.38 6517.74 "Анатолий Кулаков" Мы немножко в прошлом выпуске затрагивали, я рассказывал там и про оптимистик конкуренции, про пессимистик конкуренции, вот там мы немножко эту тему затрагивали.
6517.74 6529.38 "Анатолий Кулаков" Если вам хочется более интересных детальных подробностей про всякие конкуренции, Serializable level, какие есть спецэффекты в .NET от этого, обязательно посмотрите доклад, доклад очень практичный.
6529.38 6534.92 "Анатолий Кулаков" Команда Антона сталкивалась с довольно интересными кейсами, поэтому гляньте, классно получилось.
6534.92 6542.26 "Анатолий Кулаков" Не менее захватывающие истории были у Георгия Круглова, который рассказал про ROSLIN и плагины для компилятора C#.
6542.26 6554.90 "Анатолий Кулаков" Тема ROSLIN поднимается довольно часто, кстати, в этом году я не припомню какой-нибудь доклад, вот свеженький, да, у нас были хорошие доклады года два назад про ROSLIN, но естественно компилятор не стоит на месте, развивается, летит, бибикает.
6554.90 6564.42 "Анатолий Кулаков" И вот, наверное, самый свежий, самый актуальный доклад про ROSLIN, если вы захотите писать плагины, вот, наверное, именно Георгий Круглов, больше нечего посоветовать.
6564.42 6579.06 "Анатолий Кулаков" Поэтому, если вы захотели взяться, узнать какие-нибудь практические тонкости, которые на данный момент стоят перед C# разработчиком, решившимся заняться этим делом, какие там есть интересные библиотеки, кстати, у Георгия они выложены некоторые в Open Source, там наработки по ROSLIN.
6579.06 6581.02 "Анатолий Кулаков" В общем, тоже рекомендую посмотреть.
6581.02 6595.38 "Анатолий Кулаков" И сам доклад, очень интересный, практический опыт полностью с нуля, что это такое, зачем нужно, и до уже практической реализации каких-то программ, анализаторов, которые он реально применяет, например, для обучения своих студентов.
6595.38 6604.58 "Анатолий Кулаков" Георгий преподает в ETMO, и для обучения студентов там тоже использует ROSLIN анализаторы, как, зачем, почему, все это в докладе.
6604.58 6608.22 "Анатолий Кулаков" Тоже очень хороший, интересный доклад, гляньте, если тема ROSLIN вам интересна.
6608.22 6642.50 "Игорь Лабутин" Ну и на этом у нас все для вас на сегодня, мы сегодня успели поговорить про NBGS QLF 9 релиз, и что в нем сломалось, и что в нем улучшилось, MongoDB EF Core Provider вспомнили, подробно обсудили XUnit релиз V3 долгожданный, узнали совершенно бесполезную информацию про GC Handle, возможно чуть более полезную информацию про то, когда может происходить стекловерфло в современном мире, поговорили про рынок дотнета, и кратенько тут пробежались по всяким разным новостям.
6642.50 6646.38 "Игорь Лабутин" На этом, наверное, все на сегодня.
6646.38 6669.10 "Анатолий Кулаков" Ну, кажется, да, я думаю в этом году отработали мы прекрасно, поэтому всех с наступающим Новым Годом, и дальше увидимся в Новом Году, продолжим вас радовать другими новостями дотнета, хорошими статейками, знакомить с интересными авторами, докладами, и мы счастливы, что у нас есть такие прекрасные слушатели, которые растут и размножаются, и все больше и больше продолжают оставаться с нами.
6669.10 6673.54 "Игорь Лабутин" С наступающим Новым Годом, и всем пока до Нового Года.
6673.54 6673.70 "Игорь Лабутин" Пока.
