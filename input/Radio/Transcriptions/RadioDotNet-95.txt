0.00 11.64 "Анатолий Кулаков" Здравствуйте, дорогие слушатели, в эфире Радио.нет выпуск номер 95.
11.64 16.76 "Анатолий Кулаков" Сегодня с вами, как всегда, и его постоянный ведущий Анатолий Кулаков.
16.76 19.28 "Игорь Лабутин" И Игорь Лабутин, всем привет.
19.28 42.96 "Анатолий Кулаков" А также бравая команда помогаторов, среди которых наши хорошие друзья Александр, Сергей, Владислав, Шевченко Антон, Лазарев Илья, Гурий Самарин, Виктор, Руслан Артамонов, Александр Ерыгин, Сергей Бензенко, Александр Лапердин, Ольга Бондаренко, Дмитрий Сорокин, Сергей Краснов, Константин Ушаков, Андрей Фазлеев и Басим Альджавахири.
42.96 48.60 "Анатолий Кулаков" Друзья, всем спасибо, кто нас помогает, а кто не помогает, задумайтесь, может уже пора, стоит начать.
48.60 67.32 "Анатолий Кулаков" Ну, опять же, если нет возможности помочь подкасту, то вы всегда можете нас посмотреть, рассказать друзьям, расшарить и всячески по-другому увеличить нашу аудиторию, мы как раз перед выпуском смотрели статистику, как-то слабо растёт аудитория, давайте там, в социальные сети используйте, что вы там ещё умеете.
67.32 70.12 "Анатолий Кулаков" Разбрасывайте всем наш подкаст, срочно, надо расти.
70.12 78.84 "Анатолий Кулаков" А для тех, кто хочет посмотреть, какая у нас статистика, ну вот как раз подписывайтесь, заходите в наш приватный чатик и там мы с вами во всём поделимся.
78.84 83.28 "Анатолий Кулаков" Так, замануха закончилась, можно приступать к новостям.
83.28 99.40 "Игорь Лабутин" Да, новостей у нас немножко есть, Microsoft что-то внезапно разродился и не только выпустил дотнет 9 превью 4 пару-тройку недель назад перед записью прошлого выпуска, но и выпустил дотнет 9 превью 5 перед записью этого выпуска.
99.40 104.48 "Игорь Лабутин" И поэтому давай разберёмся, что же они за 2-3 недели успели сделать.
104.48 108.20 "Анатолий Кулаков" Ну да, удивительно, то как бы месяцами ничего нет, а то начинает как-то клепать.
108.20 113.64 "Игорь Лабутин" Ну у них там может кипяй там на количество превью до релиза, теперь надо быстренько-быстренько уместить.
113.64 120.76 "Анатолий Кулаков" Ну или знаешь, как всегда, там полгода планируют, чертят, квадратики рисуют, а потом перед релизом за 2 месяца всё делают.
120.76 128.64 "Игорь Лабутин" Может быть и так, ну там не знаю, бранчи долго мариновались, а теперь всё, вмёрзли, давай это зарелизим, давай, что бы не зарелизить.
128.64 129.64 "Игорь Лабутин" Ну давайте.
129.64 130.64 "Игорь Лабутин" Вполне, вполне.
130.64 131.64 "Игорь Лабутин" Давай-давай, рассказывай.
131.64 132.64 "Игорь Лабутин" Посмотрим.
132.64 137.86 "Игорь Лабутин" В этот раз почему-то нету секции рантайм, в рантайме видимо либо ничего не происходит, либо нечего релизить.
137.86 142.50 "Игорь Лабутин" И секция, хоть она и называется library and runtime, там только про библиотеки.
142.50 188.06 "Игорь Лабутин" Ну и начинается всё, конечно же, с AI, про то, что добавили tensor primitives и тип tensor_t, по-моему, мы про это уже рассказывали, и вроде бы его уже добавляли, и на самом деле он существовал уже в dotnet 8, но добавили немножко всяких разных методов, типов и так далее, и как они пишут, 40 оверлодов в dotnet 8, теперь там попалька 200 оверлодов, то есть это всё методы, которые позволяют работать над спанами, всякие математические операции, быстрые проворачивать, потому что это всё супер симдооптимизировано, то есть векторная арифметика, вот это всё, и понятно, что главным потребителем этого добра является искусственный интеллект, точнее, любое программирование вокруг него.
188.06 195.74 "Игорь Лабутин" А для чего это по факту там, вам это может потребоваться в вашем коте, ну надо посмотреть на конкретные юзкейсы.
195.74 199.18 "Игорь Лабутин" Скорее всего, если вы работаете как с какой-нибудь тяжёлой математикой, ну может быть полезно.
199.18 208.80 "Игорь Лабутин" Всё это живёт в пэкедже под названием System Numeric Stanzers, ну и смотрите в него, в класс Stanzer Primitives, конкретно вокруг этой новости.
208.80 253.32 "Игорь Лабутин" Дальше, мы уже рассказывали, что в C# показали ключевое слово params, в котором теперь можно не только передавать массив, но и любую коллекцию, там типа Redundant Span или ещё что-нибудь в таком духе, dash-интерфейсы, так вот теперь в этом превью это всё официально въехало уже в репозиторий, и как они пишут, в DotNet 9 теперь порядка 60 методов, у которых уже используется params Redundant Span, в частности например это какой-нибудь String Join, и как Толя говорил в прошлом выпуске, магическим образом перекомпилировав, просто перекомпилировав вашу программу под новый DotNet 9, вы получите бесплатный буст производительности, ну потому что вот оно теперь так работает, удобно и быстро.
253.32 276.96 "Игорь Лабутин" Search Values — это конструкция, которая позволяет искать подстроки в строке, в 8 DotNet она появилась, и она интересна тем, что она не просто ищет, а она знает, поскольку она знает, какие конструкции надо искать, какие подстроки, то она может выбрать оптимальный алгоритм в зависимости от длины строк, содержания строк, ну и чего-нибудь в таком духе.
276.96 300.20 "Игорь Лабутин" В 9 DotNet теперь появилась возможность искать в более большой строке, ну и соответственно несколько подстрок одновременно, там какая-то такая кухня, в общем если в Search Values конструкция вам интересна, посмотрите, там прям конкретные примеры, я так понимаю, что там довольно нишевые изменения, но почему-то они его довольно сильно пиарят.
300.20 321.40 "Игорь Лабутин" А вот следующий метод может быть действительно полезен, называется он task.when_each, у нас есть when_any, у нас есть when_all, они соответственно комплитятся, они возвращают таск, который комплитится, соответственно, в when_any, когда хотя бы один из тасков, который вы передали туда, закомплитился, а when_all, соответственно, когда все таски закомплитились.
321.40 355.52 "Игорь Лабутин" when_each возвращает не таск, when_each возвращает IAsyncNumerable, что позволяет его запихнуть в AsyncForEach или onEvadeForEach, я не знаю, как его называть правильно, и по сути это позволяет вам сделать следующую конструкцию, вы создаёте пачку тасков, запускаете их на исполнение, а дальше пишете waitForEach, там не знаю, ваш там, t, в task.when_each и передаете туда массив тасков, и соответственно, этот цикл будет выполняться для каждого завершающегося таска в том порядке, в котором они завершатся.
355.52 356.52 "Анатолий Кулаков" Очень удобная конструкция.
356.52 365.08 "Анатолий Кулаков" Да, кстати, очень часто ситуация была, когда у тебя есть какая-то пачка тасков, и ты хочешь просто обработать первый, который завершился, ну как бы такая банальная задача.
365.08 379.76 "Анатолий Кулаков" В интернете было очень много её решений, ну естественно не простых, а там через какие-то костыли, очереди, там какие-нибудь ожидания кастомные, cancellation токены, ну в общем, не то чтобы совсем сложно, но казалось, для такой примитивной вещи должно быть какое-то примитивное
379.76 380.76 "Игорь Лабутин" решение.
380.76 386.04 "Игорь Лабутин" Не, ну подожди, для первого завершившегося ты просто берёшь when_any, нет?
386.04 403.20 "Игорь Лабутин" Когда любой завершился, тебе как бы и окей, он первый, а вот если тебе нужно все, то ты делал в цикле, ты берёшь when_any, тебе завершался какой-то один, ты говорил «хорошо», и обрабатывал его результат, брал массив или там список на единичку меньшего размера без этого завершившегося, говорил снова when_any и снова ждал.
403.20 405.44 "Игорь Лабутин" И так в цикле ждал аккуратненько, пока не все не закончатся.
405.44 409.24 "Анатолий Кулаков" Ну да, я имел в виду, что первого завершился, и надо перебрать все.
409.24 410.24 "Анатолий Кулаков" Ну да, да-да-да.
410.24 411.88 "Анатолий Кулаков" То есть в порядке завершения, грубо говоря.
411.88 418.80 "Анатолий Кулаков" Тебе приходилось вот такой вот список руками поддерживать или каким-то другим способом вычислять, кто уже завершился, а кто ещё не завершился.
418.80 419.80 "Анатолий Кулаков" Это неудобно.
419.80 423.84 "Анатолий Кулаков" Ну так что вполне бытовая нормальная конструкция, очень часто используется на практике.
423.84 424.84 "Игорь Лабутин" Да, ну теперь появилось.
424.84 425.84 "Игорь Лабутин" Хорошо, что есть, да.
425.84 426.84 "Игорь Лабутин" Да.
426.84 446.52 "Игорь Лабутин" Значит, у нас в дотнете тоже относительно давно есть понятие ченнелов, мы как-то, по-моему, про них рассказывали отдельно, тут что-то недавно, и они бывают там bounded/unbounded, и если он был bounded, то его можно было создать prioritized, теперь, короче, есть приоритизированный unbounded channel, то есть channel, который ограничен только размерами оперативной памяти, при этом с поддержкой приоритетов.
446.52 457.72 "Игорь Лабутин" Понятно, что элементы, которые вы туда запихиваете, должны иметь там… туда нужно передать, точнее, comparer, который умеет сравнивать такие элементы, чтобы было понятно, что такое… или точнее, приоритеты, да, а не сами элементы.
457.72 469.64 "Игорь Лабутин" Но, тем не менее, если вам нужен ченнел для передачи данных из одного места в другое, и при этом вам нужен он с приоритетами, как очередь с приоритетами, вот теперь там это и есть в девятом дотнете превью 5.
469.64 474.46 "Игорь Лабутин" Так, OpenTelemetry кусочек чуть-чуть подкрутили, чтобы больше соответствовать спике.
474.46 480.08 "Игорь Лабутин" Я, честно говоря, не знал о такой фиче, как линки, то есть оказывается, в OpenTelemetry есть линки.
480.08 493.76 "Игорь Лабутин" Ты когда создаешь какой-то activity, ты можешь сказать, что он слинкован с каким-то другим activity, причем это может быть совершенно другой спан, вообще просто любой указываешь, и он будет слинкован, это прям линк.
493.76 494.76 "Игорь Лабутин" Вот.
494.76 495.88 "Игорь Лабутин" Вот теперь эта штука поддерживается нормально.
495.88 498.80 "Игорь Лабутин" В дотнете я никогда не пользовался, честно говоря.
498.80 505.24 "Игорь Лабутин" Я только штатным, кто там, parent-child, да, по сути, отношением пользовался.
505.24 510.32 "Анатолий Кулаков" Ну, это и ситуация довольно редко, то есть когда тебе нужно из одного спана сослаться на другую.
510.32 513.08 "Анатолий Кулаков" Я даже на практике такой общий случай не могу вспомнить.
513.08 519.32 "Анатолий Кулаков" У меня есть редкий случай, когда там нужно просто ставить ссылочку для того, чтобы в визуальном ягере, допустим, перейти куда-то.
519.32 523.52 "Анатолий Кулаков" А вот в каком-нибудь частном, ну не знаю, пример пока не приходит в голову.
523.52 535.44 "Игорь Лабутин" Ну, у меня единственный пример, который приходит в голову, это если тебе действительно, не знаю там, из одной операции ты рождаешь пачку других, но не хочешь их делать именно честно дочерними, да, спанами, а вот хочешь как бы… Ну, зачем?
535.44 536.44 "Игорь Лабутин" …отдельными деревьями сделать.
536.44 537.44 "Игорь Лабутин" Ну, зачем ты так не хочешь делать?
537.44 538.44 "Игорь Лабутин" Ну, не знаю.
538.44 539.44 "Игорь Лабутин" Не знаю.
539.44 540.44 "Анатолий Кулаков" Вот зачем-то.
540.44 544.44 "Анатолий Кулаков" Ну, да-да, это всё равно не конкретный пример, если ты зачем-то этого хочешь.
544.44 545.44 "Анатолий Кулаков" Зачем-то?
545.44 546.44 "Игорь Лабутин" Не знаю.
546.44 547.44 "Игорь Лабутин" Конкретно зачем?
547.44 548.44 "Игорь Лабутин" Я не могу подумать.
548.44 551.44 "Игорь Лабутин" То есть я понимаю, зачем это может быть мне полезно, что типа вот ты кликнул на ссылочку, да, и перешёл в этот дочерний.
551.44 554.44 "Игорь Лабутин" Но почему не сделать его исходным дочерним, я не знаю.
554.44 555.44 "Игорь Лабутин" Ну, в общем, если…
555.44 577.24 "Анатолий Кулаков" Мне больше кажется там другое, знаешь, вот когда ты делаешь, например, что у тебя какой-нибудь документ оплачивается, там какой-нибудь корзина у тебя чекаутится, то ты вполне можешь дать ссылку на спан, который положил там элемент в эту корзину для того, чтобы человек, который дебажит, там какая-нибудь служба поддержки быстрее нашла, а пользователь вообще как доклал этот элемент и сколько он, допустим, в тот момент стоил.
577.24 580.60 "Анатолий Кулаков" Чтобы он перешёл вообще на другой спан, который никак не относится к этому воркфлоу.
580.60 583.96 "Игорь Лабутин" Да, ну типа слинковать друг с другом разные операции логически.
583.96 584.96 "Игорь Лабутин" Ну, да, наверное.
584.96 590.56 "Игорь Лабутин" В общем, если вдруг пользователь с таким, расскажите кейсы в комментах где-нибудь, будет интересно узнать.
590.56 591.56 "Игорь Лабутин" Дальше.
591.56 594.48 "Игорь Лабутин" Type Descriptor Trimming Support.
594.48 599.24 "Игорь Лабутин" Штука такая, позволяет теперь вызвать метод.
599.24 631.68 "Игорь Лабутин" На Type Descriptor есть метод RegisterType, дженериковый, типа T, который позволяет, собственно, указать, что вот его RegisterType, заиспользую этот type, и в таком случае на этот, точнее, этот метод RegisterType, единственное, для чего он служит, он не делает ничего внутри, единственное, что он делает, он помечен правильным атрибутом, типа, как там правильно это для тримминга называется, про то, что не надо выкидывать используемый тип, и за счёт этого, собственно, триммеру говорится, что вот этот тип на самом деле используется.
631.68 639.44 "Игорь Лабутин" То есть такой способ указать триммеру, что этот тип используется через RegisterType.
639.44 640.44 "Игорь Лабутин" Дальше.
640.44 650.76 "Игорь Лабутин" А вот следующая штука потенциально интересная, но, наверное, тоже довольно узкий юзкейс, но, тем не менее, это называется TypeNameParsing, то есть парсилка имен типов.
650.76 697.16 "Игорь Лабутин" Оказывается, это довольно частая операция, по мнению Майкрософта, и она, в принципе, доступна в SystemType, вы можете взять SystemType, там что-нибудь попарсить, но SystemType очень тесно завязан на, собственно, runtime и всё такое, и требует загрузки-сборки там, вот это всё, теперь, в общем, у нас есть отдельный тип, который имеет методы parse-try-parse, который, соответственно, возвращает в ответ некоторую структуру класс, в котором есть имя, fullName, assemblyQualifiedName, а также пачка свойств, вида там из Array, из Pointer, из Nested, из ConstructedGenericType, в общем, всё, что вы можете узнать про тип, там плюс-минус есть.
697.16 728.70 "Игорь Лабутин" Таким образом, если вы хотите чисто только парсить имена типов, это всё находится в namespace, точнее, в пакете SystemReflectionMetadata, можно поиспользовать этот пакет и просто парсить строчки, вам для этого тип как таковой, в общем, ну, просто распарсив строчку, если вообще про этот тип ничего не известно, а есть только строчка, понятно, что кроме имени вы ничего, наверное, не получите, а вот если этот тип где-то доступен в каких-нибудь метаданнах, то тогда получите все эти наименования без привязки к SystemType.
728.70 739.38 "Анатолий Кулаков" Как-то странно, мне кажется, смешиваются две концепции, ну, то есть, stringParser, понятно, но тогда неясно, при чём здесь sr и struct, если мы с точки это всё достаем.
739.38 750.62 "Игорь Лабутин" Ну вот это тоже момент непонятный, потому что вроде как действительно, если ты передал большую вот эту полноценную, особенно, помнишь, как там в старом фреймворке, да, fullyQualifiedName там со всякими… Ну да, fullyQualifiedName, нормально передаёшь.
750.62 760.42 "Игорь Лабутин" Вот это всё распарсить, плюс с учётом дженериковости вот это всё, это действительно как бы отдельная задачка, и там имя fullname и assemblyQualified, в принципе, оттуда можно доставить плюс-минус, не из всего, но можно попытаться.
760.42 766.14 "Игорь Лабутин" А вот для всего остального, понятно, что тебе нужен сам тип, чтобы посмотреть на его метаданные вокруг
766.14 767.14 "Анатолий Кулаков" него.
767.14 768.42 "Анатолий Кулаков" И это уже вообще совсем другой домен.
768.42 769.42 "Анатолий Кулаков" Да.
769.42 770.42 "Анатолий Кулаков" Вообще никак с stringParser не связано.
770.42 782.86 "Игорь Лабутин" Ну, с другой стороны, это всё живёт в SystemReflection метадата, то есть, оно всё работает поверх метаданных, и может быть в этом смысле, скорее всего, если ты хочешь парсить именно типов, наверное, ты захочешь и что-то про них узнать.
782.86 790.86 "Анатолий Кулаков" Нет, я не хочу их загружать, я просто хотел бы иметь возможность попарсить, вот без загрузки, без поднятия каких-то метаданных, без обращения к assembly.
790.86 791.86 "Игорь Лабутин" Ну а нафига тебе парсить?
791.86 792.86 "Игорь Лабутин" Куда ты их дальше используешь?
792.86 793.86 "Анатолий Кулаков" А не знаю.
793.86 794.86 "Анатолий Кулаков" Я придумаю.
794.86 795.86 "Анатолий Кулаков" Ну, как бы хотелось бы мочь.
795.86 801.62 "Игорь Лабутин" Вот мы уже в прошлом функте обсуждали, какой бы хороший use case придумать, здесь та же самая фигня.
801.62 806.82 "Анатолий Кулаков" Я как-то занимался генераторами типов, и там у меня были такие задачи, когда мне нужно было просто распарсить.
806.82 813.50 "Анатолий Кулаков" Особенно, когда дело касается каких-нибудь nested типов с дженериковложенностями, вот там вообще начинаются непредсказуемые штуки твориться.
813.50 821.58 "Анатолий Кулаков" Ну, то есть, если мы пишем генераторы, то там задача как бы попарсить имена, сделать новое имя и узнать, что это за имя.
821.58 825.42 "Анатолий Кулаков" Она довольно часто встречается без типа, у меня нет такого типа вообще.
825.42 831.46 "Игорь Лабутин" Ну генераторы возьми, рослин, да все это рослином делай, на основе исходного кода.
831.46 832.46 "Игорь Лабутин" Ну, не знаю.
832.46 836.18 "Игорь Лабутин" В общем, тоже пока непонятная штука, но зачем-то нужна была.
836.18 840.58 "Игорь Лабутин" Я не читал, честно говоря, ищли на тему, зачем это внедрили, но, наверное, там есть какая-то мотивация.
840.58 841.58 "Игорь Лабутин" Ладно, давай дальше.
841.58 871.06 "Игорь Лабутин" Дальше у нас раздел про SPNetCore, здесь появилось несколько в основном вещей про Blazor, но начнем мы не с него, начнем мы со Static WebAsset Delivery, у нас есть давно возможность использовать метод, называется useStaticFiles, и там это, понятно, кусочек мидлварьки, который будет сервить ваши статические файлы, которые лежат там по определенному пути, не отдавая обработку дальше в ваш pipeline мидлварий.
871.06 939.94 "Игорь Лабутин" Так вот, теперь вместо useStaticFiles можно использовать метод, называется mapStaticAssets, там такое более общее название заиспользовали, и у вас будет происходить некоторая магия в том смысле, что, во-первых, все ассеты начнут сервиться автоматически сжатыми, то есть он будет автоматически все это компрессить, причем компрессия происходит не на лету, в момент запроса файлов, а в момент билд-тайма, то есть mapStaticAssets, она какая-то относительно магическая, она, как сказано, влияет еще и на билд-тайм, то есть в момент билда или паблиша у вас уже будут готовы генериться гзипнутые ассеты, которые будут потом мидлварькой просто отдаваться на лету, и в момент отдачи будут еще вешаться всякие специальные e-таги, в зависимости от контента, такие специальные штатовые хедра, которые позволяют браузеру закэшировать у себя контент и не перезапрашивать его заново, если этот хедр не менялся, ну и там есть еще всякие хедра, которые позволяют сказать, насколько долго можно его закэшировать, соответственно, через сколько браузер проверит, что там что-то поменялось.
939.94 960.98 "Игорь Лабутин" В общем, автоматически у вас будет побыстрее все работать, и если вы там отдаете статикой, например, какие-нибудь, не знаю, JS-файлики, то они, понятно, очень хорошо гзипнутся и будут быстрее передаваться, если вы, конечно, заранее сами не настроили гзипнутый мидлварьку до статик-файлов, наверное, так все и делают, не знаю.
960.98 962.58 "Игорь Лабутин" Дальше про Blazor.
962.58 1049.86 "Игорь Лабутин" Blazor-сервер улучшили в вопросе реконнекта, внезапно там не было Exponential Backoff, то есть он долбился в сервер с фиксированными интервалами, теперь там есть Exponential Backoff, когда он понимает, что у него пропал коннекшн к серверу, он будет так периодически его спрашивать с увеличивающимся тайм-аутом, но если пользователь вернулся в приложение, не знаю, как они это определяют, ну, там не знаю, получило фокус в приложении или еще что-то там, браузер или что-то сработало, какой-нибудь хендлер подобный, то он забьет на вот этот Exponential и тут же пойдет пытаться реконнектиться мгновенно, ну, чтобы обеспечить такой типа smooth, да, гладкий, бесшовный опыт, чтобы как можно быстрее законнектиться, вот, а если поймет, там еще такая ситуация, что типа сделать реконнект не получится, потому что там что-нибудь на сервере типа не разрешается, ну, то есть там как-то хитрые коннекшны используются, что вот прямо реконнект сейчас не получится, потому что сервер тоже как бы пытается от DDoS бороться с этим и так далее, но если вы зарефрешите страничку браузера, то он воспримет это как новое как бы интенс приложение и разрешит, и вот там сделана логика, что типа если мы понимаем, что законнектиться не получается, но по причине того, что сервер что-то там отлупливает текущую сессию, то он еще автоматически страничку браузера зарефрешит, и тогда у вас будет прям совсем, типа само должно реконнектиться почти всегда, как написано, посмотрим.
1049.86 1098.10 "Игорь Лабутин" Дальше, мы про Blazor когда-то давно обсуждали, что у компонент есть разные режимы рендера, то есть там он бывает серверный, бывает фронтовый, ну в общем разные они бывают, теперь есть API, которая позволяет понять внутри компонента в момент ронтайма, в каком она режиме работает, это все находится в пропертие класса ComponentBase, пропертие называется Platform, правда в новости, в статье написано, что она будет переименована в RenderInfo, и из нее торчит всего два свойства, это Name и IsInteractive, ну IsInteractive это понятно true или false, а Name, там четыре варианта возможно стать, к серверу, FB Assembly или WebView, таким образом вы сможете понять и как, не знаю, компонент может менять свое поведение в зависимости от того, как она сейчас и где она сейчас рендерится, не могу придумать useCase зачем, но наверное может быть полезно.
1098.10 1235.90 "Игорь Лабутин" Так, ну и какие-то мелочи про AuthenticationStateSerialization, чуть более простили, и новый SolutionTemplate для .NET, MAUI и Blazor хайбрид приложений, ну новый и новый, ладно, в EvCore добавили всего две, ну там добавили, конечно, побольше всяких багфиксов, но основных в статье вошло два, это улучшили немножко DatabaseProvider для AgeCosmosDB, если он работает в режиме NoSQL, а также улучшили то, как транслируются запросы в целом, в EvCore, если у вас используются комбинации типа там count не равно 0 или count больше 0, ну что-нибудь в таком духе, они получше стали транслироваться, потому что научились транслироваться метод timeOnlyFromDateTime и timeOnlyFromTimeSpan в нативный SQL, и в общем-то это все про EvCore, и там весь релиз что-то типа там, а еще мы пофиксили шесть багов для релиз ноута, типа за две недели больше не успели, и MAUI, в MAUI в этот раз не только PerformanceImprovements и Quality, что-то там, ого, прям ближе к релизу они рвут, да, там прям целых четыре поинта, значит первый поинт я уже сказал, это BlazorHybridUpdatedTemplates, ну те самые темплейт для Visual Studio, второй они поменяли, в смысле, меняли, как мы помним, MAUI не все рендерит сам, а, так сказать, делегирует рендерер собственно нативным API, поэтому им нужно иметь доступ к нативному API, и вот в этом релизе они поддержали биндинги для Android API 35 Beta 2, тоже так себе, мне кажется, версионирование, но в общем, 35 версия Beta 2 для Андроида теперь поддержана, пользуйтесь, в LLVM-MarshalledMethods они включены теперь по дефолту, если у вас не Blazor-приложение для Android, не очень понятно, а, ну да, MAUI, но не Blazor, тогда у вас будут LLVM-MarshalledMethods доступны, ну и улучшили там тримминг, теперь более точно работает тримминг, поменьше вырезать нужного и побольше вырезать ненужного.
1235.90 1250.46 "Игорь Лабутин" Типа какой-то, не знаю уж, насколько это сильно меняет опыт работы с этим, с MAUI, там каких-то сравнительных чисел особо я не видел, но посмотрим, поглядим.
1250.46 1251.46 "Игорь Лабутин" Примерно так.
1251.46 1259.58 "Анатолий Кулаков" Насколько я понимаю, что главная проблема MAUI – это сейчас огромное количество багов, они с багами никогда не отчитываются, хотя бы там в процентах или в тысячах.
1259.58 1286.30 "Игорь Лабутин" Нет, так не отчитываются, там даже есть в сайте, например, есть специальный раздел, типа там iOS, ну потому что все основное раздел, он про Android, вот эти все, там LLVM, это все Android, соответственно iOS, там написано release is focused on quality, точка, все, весь как бы, все содержимое раздела про iOS, больше там ничего не написано, так что никаких чисел, только если за GitHub смотреть вручную, я чуть
1286.30 1287.30 "Анатолий Кулаков" ленюсь.
1287.30 1302.06 "Анатолий Кулаков" Магический фреймворк, я не знаю, если у нас есть в слушателях разработчики, которые работают на MAUI или более близко там общаются с этим фреймворком, приходите, напишите выпуск, приходите, мы вас пригласим, как-нибудь обсудим, как у него там дела, потому что последние годы как-то непонятно.
1302.06 1306.06 "Анатолий Кулаков" Магическая штука, которая якобы никому не нужна и вроде все еще как-то живет и пахнет.
1306.06 1317.50 "Игорь Лабутин" Да, мы при этом по ней судим, в общем-то только по новостям и каким-то отзывам в чатах и на форумах, ну в смысле на GitHub, да, выше их и еще где-то, потому что сами на ней не пишем, я по крайней мере.
1317.50 1330.62 "Анатолий Кулаков" Ну ладно, превьюшка вроде есть, как-то двигается, не сказать бы там, что какие-то страшные и хорошие новости, нам до сих пор не завезли все-таки расширения, типы расширений, до сих пор их нет для общего пользования, ну ждем, ждем.
1330.62 1331.62 "Анатолий Кулаков" Да, ждем.
1331.62 1362.50 "Игорь Лабутин" Ну и традиционно вместе с превью вышла превью конечно же Visual Studio, называется это Visual Studio 2022, кто она, 17.11 по-моему по идее, сейчас превью 2, я что-то не записался в заметке, ну в общем, превью 2 короче, новый студии, там основной раздел это конечно копайлот, копайлот и еще раз копайлот, там теперь можно и имена генерировать, и AI Generated Breakpoint Expressions можно делать, ну в общем все что связано с копайлотом там, улучшили, углубили, расширили и так далее.
1362.50 1366.42 "Игорь Лабутин" Но есть и не только изменения, которые относятся к искусственному интеллекту.
1366.42 1384.82 "Игорь Лабутин" В отладке стало получше отлаживаться на ARM64, там были какие-то проблемы, добавили возможность Blazor VBS для дебаггинга, более удобную хорошую, теперь есть Breakpoint группы, по-моему они кстати были в прошлом превью, мне кажется, да, ведь если не в релизе, что-то я не помню.
1384.82 1385.82 "Игорь Лабутин" Брекпоинт группы, не, не помню.
1385.82 1404.66 "Игорь Лабутин" Когда Breakpoint группы добавили, ну теперь по крайней мере одну из групп можно пометить флажком, что она дефолтная и все автоматически, просто вручную добавляемые Breakpoint, ну не знаю, в студии кликнули, да, мышкой слева строчка кода, или там F9, какой там шорткат, добавили Breakpoint, он теперь будет попадать в такую группу по дефолту, можно такую назвать.
1404.66 1455.10 "Игорь Лабутин" И есть штука под названием Innumerable Visualizer, по-моему она была уже в релизе, в прошлой, так сказать, версии студии, но теперь это называется Expressive Innumerable Visualizer, штука позволяет сделать следующее, вы берете какой-нибудь innumerable, который у вас есть в коде, и в этом окошке вы можете прямо в момент дебага дописывать туда link you выражение, то есть вы берете какую-нибудь коллекцию в переменной, которая у вас есть, ну коллекцию либо какой-то innumerable, и можете прямо в этой окошке дебага написать там .where что-нибудь, там точка, там не знаю, of type, там cast, не знаю, select, что хотите, и это все будет визуализироваться у вас в, так сказать, ниже лежащем окне, такой типа интерактивный, ну как sharp lab, не знаю, link pad для innumerables.
1455.10 1461.50 "Анатолий Кулаков" Ну да, кастомные коммерческие средства для дебага, такое уже лет 10 позволили делать, наконец-то.
1461.50 1466.54 "Игорь Лабутин" Не, ну тоже кастомные и коммерческие, тут дошли руки у базового и бесплатного, ха-ха.
1466.54 1469.30 "Игорь Лабутин" Ну безусловно, безусловно хорошо.
1469.30 1497.54 "Игорь Лабутин" Вот, значит IDE-шка теперь можно включить ее автоматически апдейт вместе с основным Windows апдейтом, это прям какой-то большой бигдил, там по-моему чуть ли не отдельная статья про это вышла, и Mads, кто он, не торгуйся, Кристенсен, который главный по этим экстенджинам, вот этим всему, он прям про это, не знаю, в Твиттере неделю он писал про эти апдейты через Microsoft Update, не знаю, почему это так важно, но допустим.
1497.54 1641.90 "Игорь Лабутин" С точки зрения Веба добавили в принципе полезную штуку, вижу в студии, там сейчас есть штука под названием Endpoint Explorer, которая умеет посканить ваш код, ну и как-то статически понять, какие rest-эндпойнты у вас в коде есть, ну и их показать, соответственно в этом окошке вы там по ним можете что-то поделать, но у вас могут быть какие-то эндпойнты, которые статически не понять, ну например, вы подключите библиотеку, ну там Nuget-пакет, который в рантайме добавит еще какие-то эндпойнты, так вот теперь, когда ваше приложение запускается, то студия умная, она понимает, что там куда загружается, понятное дело, в момент отладки или в момент запуска, и в этот Endpoint Explorer докинет те эндпойнты, которые были добавлены в рантайме, их тоже можно будет потом, соответственно, подергать или еще что-то поделать с ними, она теперь может в рантайме проанализировать ваше приложение и понять, какие там rest-контроллеры есть, ну контроллеры или эти minimal API-эндпойнты, и для дотнета там по сути одна большая новость, тоже заслужившая прям отдельную статью, это новый ресурс-эксплорер, если вы когда-нибудь работали над каким-нибудь, не знаю, виндовым десктопным приложением, то вы, конечно же, знаете, что такое ресурс-эксплорер, где вы там строчки указываете, переводы делаете, не знаю, там иконки задаете, вот это все, и его прям довольно существенно переделали, в основном это касается именно строковой части, в смысле управления строками, но оно там прям прикольное, во-первых, там теперь можно сделать так называемый multi-ресурс view, то есть увидеть, например, все локализации в одном таком гряде, где строчки у вас это ваши строки, а с колонки это языки, на которые переведено, там работает поиск и фильтрация, у каждого перевода можно указывать комменты и видеть их в ресурс-эксплорере, при этом есть валидация на placeholder в переводах, это прям вот штука, на которую мы, например, напарывались очень много, когда ты в английском тексте указал там какую-нибудь фигурно-скобочку 0, фигурно-скобочку 1 для будущего стринг-формата, а потом какие-то переводчики решили что-то какая-то хрень и не перевели это вообще и не включили, вот теперь это все валидирует в студии, она говорит, что в английском у вас было, а тут что-то нет, фигня, не заработает, ну и там подкрутили всякие accessibility, UI, вот это помелочи, в общем, если вы работаете с ресурсами, посмотрите на новую превьюшку, говорят, будет круто.
1641.90 1646.18 "Игорь Лабутин" Ну вот и все про Visual Studio.
1646.18 1651.82 "Анатолий Кулаков" Кажется, что да, для ресурсов прям must-have то, что получилось, надо пробовать срочно.
1651.82 1665.74 "Анатолий Кулаков" Так, давай про новостям немножко отложим, закончим, давай глубимся в статейки, тут как раз мне на днях попалась хорошая статья про консистент-билды, и вот ее мы как раз сейчас и рассмотрим.
1665.74 1673.26 "Анатолий Кулаков" Давайте с вами поговорим о том, как мы собираем наше приложение, а самое главное, с какими версиями и с каким SDK.
1673.26 1685.30 "Анатолий Кулаков" Автор решил поднять тему, в принципе, тема хорошая, несложная, но почему-то мало освещается, и поэтому мы решили тоже поддержать такую нужную вещь.
1685.30 1709.70 "Анатолий Кулаков" Про что, собственно, речь, мы раз поговорим с вами про Global JSON, и на конкретном примере, когда вы собираете ваше приложение, на самом деле тот результат, который вы получите, какой бинарник получится на выходе, зависит от очень многих вещей, и эти вещи очень часто довольно сильно неинтуитивны и непредсказуемы.
1709.70 1721.90 "Анатолий Кулаков" Если вы хотите углубиться в эту тему, то посмотрите на статейку, которая называется Reproducible Builds, мы ее уже упоминали в наших старых выпусках, но опять же, не грешно будет ее освежить вашей памяти.
1721.90 1733.10 "Анатолий Кулаков" Так вот, Reproducible Builds, очень много там всяких тонкостей и хитростей подразумевает, которые мешают вашему приложению собираться ровно в тот же бинарный код, который он собирался, допустим, минуту назад.
1733.10 1742.66 "Анатолий Кулаков" И один из пунктов, это всего лишь навсего один из пунктов, это то, что он может собираться разными версиями с ДК.
1742.66 1743.66 "Анатолий Кулаков" Как это происходит?
1743.66 1753.14 "Анатолий Кулаков" Ну, допустим, типичная команда разработчиков, когда у вас есть как минимум два разработчика, один работает на одной машине, другой на другой машине, между ними стоит CI.
1753.14 1772.14 "Анатолий Кулаков" Так вот, у первого разработчика может стоять на компьютере СДК какой-нибудь 80200 версии, второй разработчик может быть какой-то модный хипстер, он себе девятый СДК поставил дотнетовский и разрабатывает под ним, и на CI у нас там стоит тоже какой-то СДК, который поставили давно там 80100 версии.
1772.14 1777.50 "Анатолий Кулаков" Так вот, все эти СДК, они по факту разные, как не очевидно, да, из версии.
1777.50 1781.90 "Анатолий Кулаков" И между ними есть несовместимые фичи, баги и тому подобное.
1781.90 1794.98 "Анатолий Кулаков" Ну, например, между восьмым СДК и девятым СДК, естественно, есть куча breaking changes, и которые возникают не прям вот в коде, что у вас код не соберется, а, допустим, хотя бы в родственных анализаторах, или в студии, или в компиляторе, или еще где-то.
1794.98 1805.26 "Анатолий Кулаков" Ну, то есть, если у вас разработчик локально собрал какую-то версию, и у него все было хорошо, он в этот момент может запушить это на CI, и CI в этот момент может упасть.
1805.26 1813.06 "Анатолий Кулаков" Можно сказать, я типа нашел новый анализатор, который считает, что тот код, который он написал, он больше не проходит валидацию, несмотря на то, что локально все собиралось.
1813.06 1821.90 "Анатолий Кулаков" Или, если он пропустит, то второй разработчик может скачать эту версию из мастера и обнаружит, что мастер у него почему-то локально не собирается.
1821.90 1825.74 "Анатолий Кулаков" Хотя CI прошел, все тесты зеленые, но почему-то мастер не собирается.
1825.74 1826.74 "Анатолий Кулаков" Вот такая ситуация тоже возможна.
1826.74 1847.34 "Анатолий Кулаков" И все это как раз происходит потому, что все эти точки могут собираться разными СДК, вплоть до того, что даже тот СДК, который был раньше, например, упомянутый 80100, C# СДК, Дотнет СДК, он может содержать уязвимости.
1847.34 1849.06 "Анатолий Кулаков" На самом деле он содержит уязвимости.
1849.06 1852.22 "Анатолий Кулаков" Именно поэтому его с Докерхаба скрыли, его убрали.
1852.22 1858.74 "Анатолий Кулаков" То есть на Докерхабе вы больше этот СДК скачать не можете, хотя несмотря на то, что именно восьмерка реализовалась именно с этим СДК.
1858.74 1867.14 "Анатолий Кулаков" То есть те проекты, которые вы переводили прям самыми первыми на восьмерку, они больше у вас не соберутся, потому что на Докерхабе данный образ больше не доступен.
1867.14 1871.70 "Анатолий Кулаков" Поэтому вы будете пользоваться или локальным закэшированным, ну или переходить на какой-то новый.
1871.70 1880.82 "Анатолий Кулаков" То есть даже без того, чтобы ваш код поменялся, даже без того, что разработчики там что-то зачекинили и что-то поломали, у вас вполне может поломаться билд просто со временем.
1880.82 1887.02 "Анатолий Кулаков" Потому что там были какие-то секьюрити уязвимости, базовый образ просто-напросто взяли и убрали из публичного доступа.
1887.02 1888.62 "Анатолий Кулаков" То есть такое тоже может быть.
1888.62 1892.58 "Анатолий Кулаков" Вот мы тут описали кучу проблем, давайте немножко их подытожим.
1892.58 1902.86 "Анатолий Кулаков" Итак, прежде всего нам для того, чтобы предсказуемо скомпилировать приложение, на всех машинах должен быть один и тот же SDK.
1902.86 1907.22 "Анатолий Кулаков" Если SDK отличается, то вполне вероятно, что на выходе получится что-то другое.
1907.22 1916.14 "Анатолий Кулаков" Может быть вообще не скомпилиться, если какие-то несовместимые изменения были, а может просто выдать какой-нибудь бинарный код, который работает не так, как вы ожидали.
1916.14 1919.22 "Анатолий Кулаков" Если у вас недостаточно покрытия тестом, то вы об этом даже никогда не узнаете.
1919.22 1921.26 "Анатолий Кулаков" В общем, такой риск есть.
1921.26 1924.62 "Анатолий Кулаков" Его нельзя просто на него забить.
1924.62 1934.54 "Анатолий Кулаков" Теперь у нас есть CI, и допустим такие CI-инструменты, как Azure DevOps или GitLab, помогают вам забилдить ваше дотнет-приложение.
1934.54 1941.58 "Анатолий Кулаков" Для этого вы должны просто вызвать какой-нибудь шаг, который называется, например, use.net_sobako2, то есть второй версии.
1941.58 1944.86 "Анатолий Кулаков" И все, и у вас магически все сбилдится.
1944.86 1949.26 "Анатолий Кулаков" Но при этом вы не знаете, каким SDK будет этот CI билдить.
1949.26 1973.58 "Анатолий Кулаков" use.net_sobako2 на самом деле устанавливает SDK восьмой версии, при том восьмой он учитывает только мажор, все остальное он может поменять как угодно, то есть может 8.1, 8.2, 8.3, и при этом он позволяет устанавливать превью-версии, которые еще может быть не до конца отлажены, стабилизированы и содержать какие-то там баги или несовместимости с предыдущими версиями.
1973.58 1986.10 "Анатолий Кулаков" То есть, понадеявшись на какой-нибудь Azure DevOps, на его шаг, который каким-то SDK как-то билдит ваше приложение, вы очень легко можете нарваться на несовместимости как раз в компиляторах.
1986.10 1987.10 "Анатолий Кулаков" Следующий шаг.
1987.10 1998.98 "Анатолий Кулаков" Помним, что наши SDK, наши фреймворки имеют security уязвимости, и они вполне могут отозваться.
1998.98 2002.14 "Анатолий Кулаков" Также, если они вдруг не отозвались, что это значит?
2002.14 2006.70 "Анатолий Кулаков" Ну там, если вы, допустим, локально закешировали этот образ и не позволяете никому естественно его удалять.
2006.70 2007.70 "Анатолий Кулаков" Что это значит?
2007.70 2015.22 "Анатолий Кулаков" Это на самом деле значит, что вы используете какой-то ну дырявый SDK, или какой-то уязвимый фреймворк, или какой-то уязвимый базовый образ.
2015.22 2023.58 "Анатолий Кулаков" На машинах разработчиков это еще полбеды, но это значит, что вы, скорее всего, используете его и на продакшене, если вы за этим не следите, за правильным версионированием SDK.
2023.58 2036.10 "Анатолий Кулаков" То есть, не решается проблема взять и просто-напросто во всей компании объявить одну единственную версию SDK, какой-то единственноверный, поставить ее всем разработчикам, поставить ее на все CI и забыть про это.
2036.10 2038.02 "Анатолий Кулаков" Нет, такая штука тоже не работает.
2038.02 2046.18 "Анатолий Кулаков" SDK нужно обновлять, нужно следить за security-патчами, за security-уязвимостями и, в общем, держать свой environment как-нибудь консистентно и безопасно.
2046.18 2052.34 "Анатолий Кулаков" И вот эти проблемы мы сейчас с вами как раз в статье и рассмотрим.
2052.34 2056.74 "Анатолий Кулаков" В принципе, всего этого можно избежать, если использовать небольшие рекомендации.
2056.74 2063.74 "Анатолий Кулаков" Ну, во-первых, нужно явно указывать тот SDK, с которым билдится ваше приложение, на которое вы рассчитываете.
2063.74 2070.38 "Анатолий Кулаков" И это SDK должно быть явно указано везде, на всех компьютерах разработчиков, на всех CI и так далее.
2070.38 2074.58 "Анатолий Кулаков" Это как раз и позволяет сделать файлик, который называется global.json.
2074.58 2086.02 "Анатолий Кулаков" Вторая часть проблем с security-уязвимостями и обновлениями того SDK, который мы зафиксировали, решается с помощью автоматизированных средств управления зависимостями.
2086.02 2092.10 "Анатолий Кулаков" Давайте поподробнее вот как раз сейчас над этими инструментами, над этими решениями остановимся.
2092.10 2103.14 "Анатолий Кулаков" Ну, во-первых, чтобы понимать, как мы должны версионировать и на что мы должны версионировать, нужно немножко получше разобраться в методе версионирования .NET SDK.
2103.14 2109.46 "Анатолий Кулаков" На вид он выглядит как приличный semantic version, и вы, может быть, подумаете, что он действительно семантически версионируется.
2109.46 2110.46 "Анатолий Кулаков" На самом деле нет.
2110.46 2112.78 "Анатолий Кулаков" Никакого отношения он к semantic version почти не имеет.
2112.78 2115.38 "Анатолий Кулаков" Ну, то есть у него там какая-то своя логика.
2115.38 2128.42 "Анатолий Кулаков" Ну, во-первых, у нас есть мажорная версия, наверное, вам известный .NET 5.0, .NET 6.0, .NET 7, 8.0, и скоро там у нас будет 9.0 .NET, вот это мажорная версия.
2128.42 2150.10 "Анатолий Кулаков" Это как раз то, что вы прописываете в вашем csproj файле, когда вы указываете элемент в csproj файле target-framework, там вы обычно пишите net 9.0, вот это вот и есть та мажорная версия, которая вот выходит, релизится и поддерживается весь релизный цикл, пока не выйдет следующая мажорная версия.
2150.10 2160.46 "Анатолий Кулаков" Дальше есть минорная версия, которая, казалось бы, у нас 5.0, 6.0, то есть вот этот второй нолик, который стоит, это как раз и есть минорная версия, но на самом деле она не используется.
2160.46 2163.22 "Анатолий Кулаков" Начиная с .NET 5.0, там всегда будет нолик.
2163.22 2167.46 "Анатолий Кулаков" В общем, пока она нам не нужна, и поэтому никаких проблем с этими нет.
2167.46 2170.22 "Анатолий Кулаков" Может быть, потом придумаешь, что с ней завязать, но пока просто игнорим.
2170.22 2171.22 "Анатолий Кулаков" Там всегда ноль.
2171.22 2174.38 "Анатолий Кулаков" А вот дальше начинаются интересности.
2174.38 2177.18 "Анатолий Кулаков" Каждый месяц выходят security апдейты.
2177.18 2186.70 "Анатолий Кулаков" Эти security апдейты еще внутри себя могут включать не только security апдейты, но и какой-нибудь набор фич, а также обновлять какие-то компоненты, которые входят в SDK.
2186.70 2190.62 "Анатолий Кулаков" Ну, например, тот же самый Nuget, тот же самый компилятор и так далее.
2190.62 2191.82 "Анатолий Кулаков" Они тоже могут обновляться.
2191.82 2198.10 "Анатолий Кулаков" И вот эти вот изменения, они все отражаются с помощью третьей цифры.
2198.10 2205.18 "Анатолий Кулаков" Третья цифра обычно состоит всегда из трех цифр, из трех чиселок.
2205.18 2212.94 "Анатолий Кулаков" То есть у нас есть 100, 101, 201, 385, то есть этих цифрок всегда сотни.
2212.94 2218.06 "Анатолий Кулаков" И это неспроста, потому что здесь зашита определенная магия.
2218.06 2227.38 "Анатолий Кулаков" Ну, например, если у нас есть две версии, 101 и 201 в третьей цифре, то это означает, что у них разные фичи-бэнды.
2227.38 2234.06 "Анатолий Кулаков" То есть набор каких-то новых фич, которые в SDK были привнесены.
2234.06 2244.02 "Анатолий Кулаков" Если изменяется первая циферка, то есть та, которая отвечает за сотни, это значит, изменился набор фич, которые были привнесены.
2244.02 2247.42 "Анатолий Кулаков" Вместе с этим также возможны breaking changes.
2247.42 2251.22 "Анатолий Кулаков" Естественно, никто каких-то страшных breaking changes вставлять вам не будет.
2251.22 2262.98 "Анатолий Кулаков" Ну, какие-нибудь мелкие, незаметные, там в анализаторах или в параметрах, или еще где-то, breaking changes возможны даже когда увеличивается, меняется вот эта треть цифра.
2262.98 2263.98 "Анатолий Кулаков" Это нужно помнить.
2263.98 2279.98 "Анатолий Кулаков" Теперь, если у нас цифра меняется не в сотнях, а в десятках и в единицах, ну, допустим, версия у нас 101 и 199 в третьей цифре, это значит, что используется тот же самый набор фич, тот же самый фич-бэнд.
2279.98 2288.14 "Анатолий Кулаков" То есть никаких нововведений не внесено, но при этом могут фикситься security уязвимости и какие-то баги.
2288.14 2290.38 "Анатолий Кулаков" Баги тоже могут фикситься.
2290.38 2295.86 "Анатолий Кулаков" То есть таким образом самая главная цифра, на которую нам нужно смотреть, это третья, когда мы обновляем наш SDK.
2295.86 2301.22 "Анатолий Кулаков" В общем, третья цифра состоит из двух таких блоков.
2301.22 2308.18 "Анатолий Кулаков" Это первая цифра, которая там за сотни отвечает и две следующих за десятки и единицы.
2308.18 2310.46 "Анатолий Кулаков" Вот они значимы и они нам важны.
2310.46 2319.50 "Анатолий Кулаков" Теперь, когда мы разобрались, что, собственно, за что отвечают версии и как SDK может меняться, давайте посмотрим, как мы можем улучшить наши проекты.
2319.50 2339.78 "Анатолий Кулаков" Самое первое, что стоит сделать, это создать файл GlobalJson, который как раз позволяет объявить то, с помощью какого SDK данный солюшен должен собираться, компилироваться, реставрироваться пакеты, должны запускаться тесты и в общем все то, что у нас делается с помощью, например, утилиты .NET.
2339.78 2342.66 "Анатолий Кулаков" .NET Build, .NET Run, .NET Test и так далее.
2342.66 2349.72 "Анатолий Кулаков" То есть какой SDK используется абсолютно для полной сборки и приготовки этого пакета.
2349.72 2364.84 "Анатолий Кулаков" Обычно этот файлик располагается в руте, в солюшен директоре, называется он, как я уже сказал, Global.Json и если он отсутствует, то используется самый последний SDK, установленный на вашей машине.
2364.84 2370.80 "Анатолий Кулаков" То есть абсолютно непредсказуемая вещь, потому что как бы поставили вы новую версию студии, она с собой таскает SDK.
2370.80 2375.52 "Анатолий Кулаков" Поставили новую версию какого-нибудь другого IDE, она могла притащить с собой SDK.
2375.52 2381.26 "Анатолий Кулаков" Или просто могли поставить какую-нибудь превью SDK и он автоматически подхватится всем вашим текущим рабочим проектом.
2381.26 2382.26 "Анатолий Кулаков" В общем страшная вещь.
2382.26 2385.16 "Анатолий Кулаков" Вот чтобы такого безобразия не было, создаете такой файлик.
2385.16 2389.36 "Анатолий Кулаков" Этот файлик довольно простой, в нем буквально можно максимум три строчки засунуть.
2389.36 2391.20 "Анатолий Кулаков" Вот давайте подробно рассмотрим.
2391.20 2394.64 "Анатолий Кулаков" Ну, во-первых, мы можем указать SDK version.
2394.64 2399.12 "Анатолий Кулаков" Это минимальная версия, с которой будет собираться наш проект.
2399.12 2400.12 "Анатолий Кулаков" Почему минимальная?
2400.12 2402.68 "Анатолий Кулаков" Ну, для того, чтобы как раз для гибкости.
2402.68 2408.68 "Анатолий Кулаков" Максимальная версия, с помощью которой он будет собираться определяется следующим параметром, который называется SDK roll forward.
2408.68 2413.92 "Анатолий Кулаков" То есть, с помощью стратегии roll forward мы выбираем, а какая максимальная версия SDK может быть.
2413.92 2422.76 "Анатолий Кулаков" Если вдруг минимальная не найдена на данной машине, но есть какая-то допустимая, недалеко от нее стоящая, то можем собрать с помощью нее.
2422.76 2428.32 "Анатолий Кулаков" У этого параметра есть дефолтное значение, это latest patch.
2428.32 2432.44 "Анатолий Кулаков" То есть, мы собираем SDK, у которого не менялся мажор, минор и фичбенд.
2432.44 2435.28 "Анатолий Кулаков" То есть, у которого менялись только последние две цифры.
2435.28 2439.56 "Анатолий Кулаков" Это вот самый безопасный вариант, поэтому он по дефолту и стоит.
2439.56 2443.48 "Анатолий Кулаков" И, соответственно, мы можем дальше этим жонглировать.
2443.48 2456.28 "Анатолий Кулаков" То есть, есть latest feature, когда мажорный и минорный разделы не менялись, latest minor, когда только мажорный не менялся, и latest major, когда вообще может даже мажор меняться в большую сторону, естественно.
2456.28 2462.44 "Анатолий Кулаков" Может меняться как угодно, и мы говорим, что наше приложение будет собираться и работать прекрасно, без всяких проблем.
2462.44 2463.44 "Анатолий Кулаков" Почему бы нет?
2463.44 2464.44 "Анатолий Кулаков" То же такое может быть.
2464.44 2467.04 "Анатолий Кулаков" И есть отдельная стратегия, о которой стоит упомянуть.
2467.04 2468.04 "Анатолий Кулаков" Называется она Disable.
2468.04 2473.60 "Анатолий Кулаков" Это значит, что не умничай, товарищ, никаких максимальных версий у нас нет.
2473.60 2478.32 "Анатолий Кулаков" Вот ровно то, что было указано в SDK version, вот ровно ту версию используй.
2478.32 2481.56 "Анатолий Кулаков" Если ее будет не найдено, то ваш билд упадет просто-напросто.
2481.56 2484.68 "Анатолий Кулаков" Это гораздо лучше, чем собрать с непопадичем.
2484.68 2488.40 "Анатолий Кулаков" То есть, лучше предсказуемый пас, чем непредсказуемо собраться.
2488.40 2490.92 "Анатолий Кулаков" Какие здесь можно отдать рекомендации?
2490.92 2503.76 "Анатолий Кулаков" Если мы говорим про четыре поля, вот там четвертое еще есть, Pre-release, то есть вы можете сказать, а можно ли с помощью Pre-release SDK собирать ваш Solution или не стоит?
2503.76 2507.72 "Анатолий Кулаков" В общем, и теперь давайте посмотрим все-таки рекомендации.
2507.72 2508.72 "Анатолий Кулаков" Рекомендации.
2508.72 2514.60 "Анатолий Кулаков" Для того, чтобы собирать ваш проект, прежде всего нужно определиться с минимальной версией SDK.
2514.60 2516.96 "Анатолий Кулаков" Ну и здесь рекомендации элементарные.
2516.96 2520.56 "Анатолий Кулаков" Используйте максимальную версию, которую вы только можете использовать в своих проектах.
2520.56 2531.48 "Анатолий Кулаков" Естественно, чем больше SDK, тем больше версии SDK, тем ваш собранный проект будет лучше, тем больше возможностей будет у C#, тем больше возможностей у компилятора, у рантайма и прочего.
2531.48 2540.64 "Анатолий Кулаков" Ну, разумеется, если ваш проект собирается только под .NET 5, не стоит ему выставлять SDK 9, потому что наверняка ничего работать не будет.
2540.64 2543.16 "Анатолий Кулаков" То есть, максимальная версия, под которую вы можете собраться.
2543.16 2544.16 "Анатолий Кулаков" Это ваш путь.
2544.16 2545.16 "Анатолий Кулаков" Дальше.
2545.16 2553.80 "Анатолий Кулаков" Для стратегии, какая максимальная стратегия подходит для roll-forward?
2553.80 2554.80 "Анатолий Кулаков" Это only-patch.
2554.80 2558.84 "Анатолий Кулаков" То есть, если патч-версия поменялась, то это хорошо.
2558.84 2566.12 "Анатолий Кулаков" Значит, вы можете, в принципе, допустить, что компилятор или наш запускатор .NET выбрал именно такое SDK.
2566.12 2577.20 "Анатолий Кулаков" Это позволит вам избежать breaking changes, то есть вы точно можете гарантировать, на 100% уверены, выставив параметр only-patch, можете гарантировать, что оно точно соберется.
2577.20 2587.04 "Анатолий Кулаков" Там нет никаких новых анализаторов, там нет никаких breaking changes, там будут только максимум фиксы багов, обратно совместимые фиксы багов и security-патчи.
2587.04 2596.28 "Анатолий Кулаков" А security-патчи мы хотим ставить, именно поэтому не нужно использовать exact, то есть disable, потому что все-таки security – это хорошо и это важно.
2596.28 2601.96 "Анатолий Кулаков" После того, как мы соблюли все эти рекомендации, чего мы добились?
2601.96 2609.04 "Анатолий Кулаков" Мы добились того, что у нас есть в нашем репозитории, он чекинится вместе со всем кодом, вот этот прекрасный JSON-файлик.
2609.04 2619.76 "Анатолий Кулаков" Это значит, что во всех разработчиков на машине проект будет собираться четко тем SDK, который мы прописали в этот файлик, не больше и не меньше.
2619.76 2626.20 "Анатолий Кулаков" Если такого SDK не будет, билд упадет, а разработчик будет вынужден его заинсталлировать такой SDK и продолжит работать спокойно и красиво.
2626.20 2645.88 "Анатолий Кулаков" Также это значит, что этот SDK будет использоваться для сборки на CI, потому что, естественно, с каким фреймворком мы разрабатывали, с каким фреймворком мы тестировали, с этим фреймворком желательно и крутить наше приложение в продакшене, поэтому в продакшене у нас уже тоже предсказуемый хороший, понятный SDK, и это прекрасно.
2645.88 2648.16 "Анатолий Кулаков" Идем дальше.
2648.16 2681.82 "Анатолий Кулаков" Такие CI-системы, как, например, Azure DevOps и GitHub Actions, умеют принимать Global JSON, т.е. если им указать специальный параметр в их чудесной яму настройки, то они могут вам не просто запустить вашу компиляцию с каким-то .NET SDK, как мы упоминали уже немножко выше, а взять правильную версию из Global JSON, заинсталлировать именно этот SDK, который вы там указали, и собрать ваше приложение, ваш Solution так, как вы попросили.
2681.82 2687.30 "Анатолий Кулаков" Т.е. он будет собираться ровно таким же, как и разработчики собирали его на локальных машинах.
2687.30 2688.30 "Анатолий Кулаков" В общем, прекрасно.
2688.30 2690.46 "Анатолий Кулаков" Все как раз, как мы хотели.
2690.46 2691.46 "Анатолий Кулаков" Вот.
2691.46 2697.70 "Анатолий Кулаков" Теперь у нас остается еще один интересный персонаж, у которого есть версия SDK, которая зависит от версии SDK.
2697.70 2699.14 "Анатолий Кулаков" Это, конечно же, Dockerfile.
2699.14 2714.26 "Анатолий Кулаков" Если вы новомодный хипстер, то, естественно, весь билд у вас происходит в Multistage Dockerfile, т.е. вы билдите в Dockerfile со всеми предсказуемыми зависимостями, и вы также точно распространяете ваше приложение в виде обычного Dockerfile.
2714.26 2715.26 "Анатолий Кулаков" Вот.
2715.26 2722.54 "Анатолий Кулаков" И если вы так делаете, то у вас в Dockerfile обязательно будет базовый имидж, из которого вы берете SDK, и базовый имидж, из которого вы берете рантайм.
2722.54 2725.90 "Анатолий Кулаков" И в этих базовых имиджах у вас обязательно будет указана версия.
2725.90 2735.82 "Анатолий Кулаков" Опять же, мы возвращаемся к вот этой самой версии, с помощью которой мы будем билдить, и с помощью которой версия рантайм у нас будет работать.
2735.82 2736.82 "Анатолий Кулаков" Вот.
2736.82 2743.70 "Анатолий Кулаков" И эти версии, они тоже должны совпадать с тем, что вы имплементировали в Global SDK.
2743.70 2751.94 "Анатолий Кулаков" К сожалению, нет инструмента, который берет ваш Global SDK, сравнивает с вашим Dockerfile, и каким-то образом магическим подставляет или корректирует это.
2751.94 2752.94 "Анатолий Кулаков" В общем, такого не бывает.
2752.94 2755.86 "Анатолий Кулаков" Но здесь можно зайти с другой стороны.
2755.86 2759.30 "Анатолий Кулаков" У нас есть третья проблема, которую мы не решили.
2759.30 2761.82 "Анатолий Кулаков" Если вы помните, проблема устаревших версий.
2761.82 2777.38 "Анатолий Кулаков" Напомню, что версии SDK могут содержать секьюрити-уязвимости, их периодически нужно обновлять, ну и естественно обновлять как-то разумно, не просто автоматически брать какую-нибудь мажорную версию, а вот проходить весь пайплайн тестирования, весь код ревью и прочее-прочее.
2777.38 2786.02 "Анатолий Кулаков" Поэтому в данном, чтобы подойти с этой стороны, используются другие инструменты, которые называются как раз таки инструменты по управлению версиями.
2786.02 2796.02 "Анатолий Кулаков" Они помогают вам держать версии ваших SDK, пакетов, Dockerfile, базовых образов, вообще чего угодно, позволяют держать в актуальном состоянии.
2796.02 2800.90 "Анатолий Кулаков" То есть без breaking changes, но при этом с секьюрити-фиксами.
2800.90 2803.34 "Анатолий Кулаков" Что не может не радовать.
2803.34 2806.54 "Анатолий Кулаков" По-английски они звучат как Dependency Management Tools.
2806.54 2812.14 "Анатолий Кулаков" Наверняка многие из вас, кто пользуется GitHub могли сталкиваться с таким прекрасным персонажем, как Dependobot.
2812.14 2822.18 "Анатолий Кулаков" Это тот назойливый робот, который все время приходит и говорит вам обновитесь, обновитесь, у вас там какие-то секьюрити-уязвимости нашлись в ваших зависимостях, срочно обновитесь, я вам создал pull-request.
2822.18 2826.46 "Анатолий Кулаков" Вот Dependobot это типичный представитель как раз Dependency Management Tools.
2826.46 2830.54 "Анатолий Кулаков" Но, к сожалению, он работает только на GitHub.
2830.54 2833.90 "Анатолий Кулаков" Нормальные, уважающие себя люди, естественно, держат self-hosted решения.
2833.90 2838.14 "Анатолий Кулаков" И здесь тоже есть инструменты, которые помогают вам сделать Dependobot локального.
2838.14 2842.38 "Анатолий Кулаков" Один из них, например, очень популярный, это Renovate.
2842.38 2852.62 "Анатолий Кулаков" Renovate поддерживает все абсолютно, там очень много репозиторий, которые там вы знаете, то же самое GitHub, и GitLab, и TeamCT, и чего только не поддерживает.
2852.62 2875.90 "Анатолий Кулаков" В общем, много чего поддерживает, также самое для нас, что актуально, он умеет self-hosted решения, то есть не обязательно выпускать в интернет, можно установить у себя, и делает он практически то же самое, что Dependobot, то есть проходится по всем вашим зависимостям, ну, которые вы там указали в config файлах, и обновляет их в соответствии с правилами, которые вы, опять же, указали.
2875.90 2898.70 "Анатолий Кулаков" Когда он находит новую версию, которая подходит под все эти описания, то есть, допустим, в вашем SDK нашли какие-то секьюрити уязвимости, и он хочет вам помочь обновиться, в этот момент он создает pull request, в этом pull request он может обновить global JSON файл, он может обновить Docker файл, который мы упоминали, и даже NuGet-пакеты, которые есть в вашем приложении, он, естественно, тоже может пообновлять.
2898.70 2909.62 "Анатолий Кулаков" Все это он умеет, он довольно-таки много разных поддерживает форматов, разумеется, не только для .NET, как бы там абсолютно большая куча, но для .NET нам, в принципе, вот эти вот три довольно интересны.
2909.62 2934.58 "Анатолий Кулаков" После того, как он создает pull request, естественно, он не мерзнет сразу, у вас проходят тесты, у вас, может быть, во время тестов находятся какие-то breaking changes, которые могут быть, вот в это время вы должны, в этот момент вы должны пойти и поправить breaking changes, каким-то образом обновить ваш код, запушить все изменения в этот pull request, который он создал, и влить уже новую обновленную SDK в соответствии вашей репозитории.
2934.58 2944.62 "Анатолий Кулаков" Этот новый SDK с новыми версиями соберется уже на вашей CI-системе и пойдет в прот, устраня при этом все security-вызывности, которые были найдены.
2944.62 2957.62 "Анатолий Кулаков" Таким образом, мы вот решили все поставленные задачи, которые были перед нами, мы получили какой-то предсказуемый билд, мы понимаем, каким образом он собирается, из каких версий, мы сделали так, что он собирается одинаково на всех машинах, на которых он должен собираться, т.е.
2957.62 2976.46 "Анатолий Кулаков" билды у нас более-менее становятся предсказуемыми, ну и мы сделали, не самую маловажную вещь, мы улучшили безопасность нашего подхода, т.е. мы теперь можем с помощью Management Tools следить за security-вызимостями во всех наших пакетжах, от которых мы зависим, и вовремя патчиться.
2976.46 2983.30 "Анатолий Кулаков" Такая интересная статичка, в общем, за подробностями, за конфигами, за ссылками, пора следуйте к автору, если вам понравилось.
2983.30 2998.58 "Анатолий Кулаков" Также, если у вас тема с reproducible билдами, интересно, опять же, посмотрите на документы Microsoft, чтобы ужаснуться, от чего вообще зависят билды, оказывается, там, SDK-версия – это не самое страшное, что с вами может произойти.
2998.58 3001.34 "Анатолий Кулаков" Но она одна из самых главных, поэтому следить за ней стоит.
3001.34 3018.32 "Игорь Лабутин" Это точно, следить за ней действительно стоит, следить за тем, что находится в вашем глобу лыжи, он тоже стоит, и регулярно обновляться на плюс-минус последние версии, чтобы получать security-фиксы, однозначно, стоит хотя бы в докер-имеджах.
3018.32 3021.54 "Игорь Лабутин" Не факт, что там на сборках, но хотя бы в докере.
3021.54 3034.22 "Анатолий Кулаков" Слушай, кстати, странно, я когда создавал в последний раз из темплейта репозиторий, ну как, он даже не репозиторий, а там solution создается, вот этот solution GlobalJson не подкладывал.
3034.22 3041.14 "Анатолий Кулаков" Я не знаю, что-то давно не смотрел уже, так не могу вспомнить, какие-то свежие версии, но почему-то по дефолту нет в темплейте этого файла.
3041.14 3045.38 "Игорь Лабутин" Потому что нужно быть на последней версии всегда так круче.
3045.38 3050.70 "Анатолий Кулаков" Ну, на последней версии – да, но не на последней, которая случайно найдётся на машине.
3050.70 3054.22 "Анатолий Кулаков" Вот это вот вообще разные вещи, потому что на машине можно найти что-то вообще непредсказуемое.
3054.22 3056.82 "Игорь Лабутин" И это правда, это правда, действительно.
3056.82 3062.10 "Игорь Лабутин" Ну, в общем, контролируйте, на чём вы собираетесь и на чём вы, главное, запускаетесь в Prodee.
3062.10 3065.14 "Игорь Лабутин" А пока пойдём дальше, дальше по статейчкам.
3065.14 3074.66 "Игорь Лабутин" И у нас Andrew Locke, давно у нас не было Andrew Locke, а тут вышло у него несколько статей, и мы разберём парочку, а именно про primary конструкторы.
3074.66 3094.94 "Игорь Лабутин" Фактически, на самом деле, вышло у него три статьи про primary конструкторы, но первую мы относительно пропустим, там в основном разбор про то, что это такое, я просто кратенько напомню, что primary конструкторы – такая особая конструкция языка C#, когда вы можете написать там какой-нибудь public class Person и прямо дальше в скобочках указать поля.
3094.94 3100.14 "Игорь Лабутин" Ну, на самом деле, это не поля, это аргументы конструктора.
3100.14 3114.14 "Игорь Лабутин" То есть если бы вы объявили рекорд, то, понятно, это были бы поля рекорда, они преобразуются в property, автоматические read-only, причём property, или как там они, init-only, правильно называть property и всё такое прочее.
3114.14 3129.50 "Игорь Лабутин" В классе же это просто, если вы пишете public class Person и в скобочках круглых string firstname и lastname, это просто некоторые параметры, пока ещё конструктора, если вы их никак внутри не заиспользуете, так и останется просто параметрами конструктора.
3129.50 3136.18 "Игорь Лабутин" Но вы их можете внутри класса использовать, и, в общем-то, в них есть два основных вида использования.
3136.18 3152.02 "Игорь Лабутин" Один вид, это называется инициализация полей или пропертей, когда вы можете внутри класса уже объявить собственно property или поле, и как мы обычно пишем инициализаторы, написать присвоить, и вот этот самый параметр конструктора, который у вас в объявлении класса написан.
3152.02 3160.66 "Игорь Лабутин" Это один вариант, а второй вариант, вы в принципе можете напрямую использовать эти самые параметры в любых других местах, в каких-нибудь лямбдах, методах, ну где угодно.
3160.66 3173.50 "Игорь Лабутин" И в этом случае, если это так происходит, то компьютер за вас создаст внутреннее private поле, оно будет, как обычно, с каким-нибудь нехильно читаемым именем, ну и заменит все использование этого параметра на вот такое поле.
3173.50 3189.34 "Игорь Лабутин" Простая штука, призванная уменьшить вот это наши стандартные многоэтажные конструкторы, где единственное, что вы делаете, вы пишете, источник A присвоить A, источник B присвоить B, источник C присвоить C, и хорошо, если это A, B, C, а не какие-нибудь длиннющие названия.
3189.34 3193.06 "Игорь Лабутин" Ну и все поля еще заодно объявляете такие же.
3193.06 3196.74 "Анатолий Кулаков" Смотри, но в то же самое время они нам не упростили эту задачу.
3196.74 3200.74 "Анатолий Кулаков" То есть если я все-таки хочу локальные поля, я вынужден все равно их явно посоздавать.
3200.74 3201.74 "Анатолий Кулаков" Да-да-да.
3201.74 3218.06 "Анатолий Кулаков" И плюс они внесли какое-то недопонимание, потому что большинство людей, которые разумно посмотрят на эту штуку, они будут интуитивно думать, что они используют локальные поля, когда будут просто обращаться к параметрам вот этого, к параметрам конструктора, которые не присвоены в локальные.
3218.06 3221.18 "Анатолий Кулаков" Здесь тоже опять вводится какая-то сложность, нафига?
3221.18 3224.20 "Игорь Лабутин" Вот непонятно, нафига Эндрю, собственно, по этому делу и проходится.
3224.20 3235.04 "Игорь Лабутин" Он говорит про то, что, собственно, что такое самый лучший способ использования этих самых primary конструкторов — это, конечно же, инициализация филдов.
3235.04 3252.16 "Игорь Лабутин" Ну то есть здесь все просто и понятно, да, вы объявляете поле, и вы там, где напишите private string a, присвоить a, да, которое было, или там private string firstname, присвоить firstname из конструктора.
3252.16 3258.52 "Игорь Лабутин" Firstname и firstname, да, вроде один и тот же firstname, но один это параметр конструктора, другой это поле.
3258.52 3274.84 "Игорь Лабутин" Тут вроде все понятно, все хорошо и здорово, ну единственное, что да, как ты правильно говоришь, все равно приходится писать поле, но если вы хотите хоть немножко валидировать, а иногда в конструкторах мы хотим валидировать, что там пришло, то все становится интересно.
3274.84 3277.12 "Игорь Лабутин" Понятно, что валидация на null, но она простая.
3277.12 3300.76 "Игорь Лабутин" У нас есть оператора, значит, два вопросика, после которого можно писать throw new что-нибудь, аргумент null exception или что-нибудь в таком духе, и там все хорошо, но если вам нужна какая-то чуть более сложная валидация, строчку проверить на то, что она пустая, например, то там уже приходится всячески приседать со всякими тернарными операторами, либо городить какую-нибудь static функцию, которую вы сможете вызвать, и уже все это становится не очень красиво.
3300.76 3314.64 "Игорь Лабутин" При этом в целом есть сценарий, где это очень полезно, то есть как один из примеров, он приводит, например, тесты.
3314.64 3322.72 "Игорь Лабутин" Если вы берете типичный xUnitTest класс, вам туда нужно прокинуть, например, itestOutputHelper, чтобы потом в тестах использовать его.
3322.72 3340.94 "Игорь Лабутин" И вот это типичнейший вариант, где можно спокойно закинуть itestOutputHelper в primary конструктор, не объявлять поле, спокойно заиспользовать прямо этот output, например, параметр внутри какого-нибудь теста, да, он закепчерится, да, он создаст какое-то свое внутреннее поле, ну да какая разница, работать будет.
3340.94 3345.80 "Игорь Лабутин" И в тестах вам не так важно, какая там видимость у этого поля.
3345.80 3351.72 "Игорь Лабутин" Там mute было, не mute был, readonly, не readonly, это абсолютно все равно, вы в тестах.
3351.72 3373.24 "Игорь Лабутин" А второй кейс, где он говорит, что primary конструктор - это очень хорошо и ценно и здорово, это создание классов, давай так, описание классов, которые вы, скорее всего, сами создавать не будете, но у которых типично бывает большое количество параметров, ну, например, контроллеры.
3373.24 3390.76 "Игорь Лабутин" То есть контроллеры вы никогда в целом не пишете, там you чего-нибудь, контроллер, поэтому особо проблем с тем, что там именования какие-то, про это еще чуть-чуть дальше поговорим, не нативные, не соответствуют код-конвеншенс, никаких проблем особых с этим нет.
3390.76 3417.88 "Игорь Лабутин" Второе, в среднем в конструкторе, в контроллере вы инициализируете всякие сервисные, допустим, эти самые instances из di-контейнера, и опять же, несмотря на то, что поля по дефолту создаются muteable, то есть они не readonly, особых проблем нет, вряд ли вы захотите какой-нибудь там ilogger переприсваивать где-то внутри вашего контроллера, поэтому в целом в контроллерах это прям выглядит нормально, более-менее приемлемо.
3417.88 3426.80 "Анатолий Кулаков" Слушай, ну ты описал вообще типичный мой сервис, у меня все выглядит как контроллер, я сервисы из руками не создаю, у меня все через di заинжектируется.
3426.80 3443.00 "Игорь Лабутин" Ну вот, видишь, в целом да, но вопрос как бы, какова вероятность, что если ты, не знаю, заинжектишь какой-нибудь, ну я не знаю, ioption, да, и что-нибудь, то ты не захочешь поменять его почему-то внутри.
3443.00 3455.00 "Игорь Лабутин" Понятно, что ты не захочешь, но мы же как бы readonly расставляем не потому что там, не знаю, против себя будущего, но и в том числе, чтобы всем остальным дать понять, что поле тут readonly, а тут у тебя будет не readonly поле.
3455.00 3459.36 "Анатолий Кулаков" Ну вот как бы да, да, вот и поэтому нехорошо, что не доделали.
3459.36 3460.36 "Анатолий Кулаков" Вот.
3460.36 3466.20 "Игорь Лабутин" И вот тут как раз Энди переходит к проблемам, коих он насчитал аж 5 штук.
3466.20 3506.20 "Игорь Лабутин" Ну, во-первых, это тот самый capturing, который может быть дублироваться, то есть если вы, например, создали поле, его заинтеллировали, а потом где-то внутри этого самого тела класса заиспользовали из параметра конструктора заново, то фактически у вас создастся два поля, одно, которое создали вы, другое, которое создал компилятор за вас, причем оба mutable, и если вдруг по логике, это может быть очень странная логика, но, например, по логике состояние этого поля нужно менять, ну, например, вы его инсталлизируете каким-нибудь там начальным стейтом, да, а потом дальше по логике класса этот стейт вы меняете, то надо не забыть, что у вас два поля фактически.
3506.20 3512.08 "Игорь Лабутин" Причем ко второму обращаться нужно через название аргумента primary конструктора, ну, как-то, в общем, странно.
3512.08 3521.48 "Анатолий Кулаков" Ну и если вы там считаете как-нибудь размер этого объекта, у вас таких объектов миллиарды, то это может быть не прям увеличить ваш размер, это вам в два раза легко.
3521.48 3525.48 "Игорь Лабутин" К счастью, к счастью, про этот кейс компилятор выдает warning.
3525.48 3539.40 "Игорь Лабутин" То есть если у вас включены warning, а лучше, если у вас включены warning as errors, мимо не пройдете, у вас будет warning про то, что вы, типа, один и тот же параметр конструктора и закепчурили, и использовали в инстализации.
3539.40 3542.64 "Игорь Лабутин" Поэтому, к счастью, от этого можно быстренько избавиться.
3542.64 3548.44 "Игорь Лабутин" Второе, ну, собственно, то, про что мы тут уже много раз говорим, все вот эти вот неявные поля не редумли.
3548.44 3573.08 "Игорь Лабутин" Скорее всего, скорее всего, есть вероятность, что эту штуку может быть пофиксит в будущих версиях C#, каким-нибудь очередным, не знаю, атрибутиком или ключевым словом, я не знаю, чем, восклицательным знаком около названия типа или там вопросить, ну, в общем, что-нибудь придумают, но есть вероятность, что, может быть, это исправят.
3573.08 3575.24 "Игорь Лабутин" Поэтому тут, может быть, будет хорошо когда-нибудь.
3575.24 3580.88 "Анатолий Кулаков" Это в любом случае будет смотреться не так лаконично, там придумают какое-нибудь очередное безобразие.
3580.88 3581.88 "Игорь Лабутин" Конечно, конечно.
3581.88 3585.72 "Игорь Лабутин" Редумли будет, там будет редумли, стринг, что-нибудь, ключевое слово, что у нас есть.
3585.72 3591.78 "Анатолий Кулаков" Ну, да, сделаем каку, но зато научим компилятор громко о ней кричать, и потом в будущем эту каку оборудим заборчиком.
3591.78 3593.84 "Анатолий Кулаков" Ну, блин, а почему сделать нормально было сразу?
3593.84 3597.16 "Игорь Лабутин" Времени мало, они ж это теперь интерактивно все фичи делают.
3597.16 3599.32 "Игорь Лабутин" Подожди, надо ждать 3-4 релиза.
3599.32 3600.32 "Игорь Лабутин" Нормально.
3600.32 3609.16 "Игорь Лабутин" Я вон слушал сейчас, как раз перед записью подкаста, не до конца еще дослушал, этот DotNet Rocks с как раз мэдсом Торгерсоном.
3609.16 3617.00 "Игорь Лабутин" И он там так классно рассказывает про то, что блин, теперь так круто, мы теперь, вот смотрите, паттерн-матчинг, мы целых 4 версии C# делали, это же круто.
3617.00 3618.00 "Игорь Лабутин" Вот.
3618.00 3620.60 "Игорь Лабутин" А ты хочешь сразу и все.
3620.60 3621.60 "Игорь Лабутин" Погоди.
3621.60 3622.60 "Анатолий Кулаков" Не торопись.
3622.60 3628.52 "Анатолий Кулаков" Должен же какой-то планчик быть, то есть хорошо пусть делают 4 версии, но они должны понимать, к чему они должны прийти.
3628.52 3632.08 "Анатолий Кулаков" А потому что сейчас они такого нагородили, что без брейкинджизов они к этому не придут.
3632.08 3635.28 "Анатолий Кулаков" Соответственно, это уже не починится никогда, мы с этим вынуждены будем жить.
3635.28 3644.12 "Игорь Лабутин" Прайд, они тоже говорят, что ранние релизы таких вот частичных фич позволяют узнать фидбэк от пользователей и понять куда дальше идти, поэтому план у них может быть и есть.
3644.12 3648.76 "Игорь Лабутин" Но они никому его особо видимо не говорят, плюс смотрят на реакцию комьюнити.
3648.76 3654.72 "Игорь Лабутин" Ну слушай, я думаю, что что-нибудь они с этим сделают, потому что природолог ли говорит, по-моему, все, кто трогал прайм-реконструкцию.
3654.72 3655.72 "Анатолий Кулаков" Ну да ладно.
3655.72 3660.52 "Анатолий Кулаков" Да вряд ли мне касается, что если уже дошли в таком версии до превью, то вряд ли они будут прям настолько менять.
3660.52 3662.68 "Игорь Лабутин" Да непонятно, непонятно.
3662.68 3667.60 "Игорь Лабутин" Подожди, почему превью-то, прайм-реж они ж в релизе нет?
3667.60 3668.60 "Игорь Лабутин" Это восьмерка.
3668.60 3669.60 "Анатолий Кулаков" Восьмерка?
3669.60 3670.60 "Анатолий Кулаков" Да.
3670.60 3671.60 "Анатолий Кулаков" Нет?
3671.60 3672.60 "Анатолий Кулаков" Да, это восьмерка, да.
3672.60 3673.60 "Игорь Лабутин" Это восьмерка, они в релизе.
3673.60 3674.60 "Игорь Лабутин" Ну тогда все, как бы, че так.
3674.60 3675.60 "Игорь Лабутин" За релиз?
3675.60 3676.60 "Игорь Лабутин" Не, почему?
3676.60 3678.60 "Игорь Лабутин" Ну, с ключевой словой редонлида писать никогда не мешает.
3678.60 3683.88 "Анатолий Кулаков" Мешает, чувство прекрасного, и ограничение там сколько у нас?
3683.88 3684.88 "Анатолий Кулаков" В 80 что ли положено строк?
3684.88 3685.88 "Игорь Лабутин" Вот оно мешает.
3685.88 3688.24 "Игорь Лабутин" Видишь, каждый аргумент на новой строке писать, не парься.
3688.24 3689.40 "Игорь Лабутин" Мы до джава еще не доросли.
3689.40 3691.64 "Игорь Лабутин" Да вот, с чего-то мне кажется, что мы и не достигнем.
3691.64 3693.52 "Игорь Лабутин" Количество ключевых слов и длино их.
3693.52 3694.52 "Игорь Лабутин" Ладно.
3694.52 3695.52 "Игорь Лабутин" Дальше.
3695.52 3711.96 "Игорь Лабутин" Дальше то, что ты сказал, что вот эти неявные поля меняют layout класса, действительно, то есть если у вас есть какой-нибудь там интероп, и вы к вашей структуре внезапно или к чему-нибудь такому решили прикрутить primary конструктор, ну будьте готовы к тому, что там все будет плохо.
3711.96 3714.28 "Игорь Лабутин" Лучше не надо.
3714.28 3717.72 "Игорь Лабутин" Дальше есть такая проблема странная с именованием.
3717.72 3726.68 "Игорь Лабутин" То есть, с одной стороны, это параметры, и вам хочется их именовать как параметры, то есть, ну, как правило, smallcase, начиная с маленькой буквы, и каждое слово с большой дальше.
3726.68 3739.16 "Игорь Лабутин" С другой стороны, если вы к ним обращаетесь как к полям, а у вас, например, кодинг-конвеншен, как в дотнете, когда у вас private филды через подчеркивания, то, наверное, хотелось бы их с подчеркивания начинать.
3739.16 3748.48 "Игорь Лабутин" Но если вы их начинаете с подчеркивания, то в том месте, где вы используете конструктор явно, у вас, если вы используете named arguments, будут named arguments с подчеркиванием.
3748.48 3749.48 "Игорь Лабутин" Что-то же не круто.
3749.48 3750.48 "Игорь Лабутин" Ну и параметры с подчеркиванием.
3750.48 3751.48 "Игорь Лабутин" Странно выглядит.
3751.48 3755.92 "Игорь Лабутин" Короче, тоже такая мелочь, конечно, но непонятно.
3755.92 3759.28 "Игорь Лабутин" Либо надо делать как ты, никогда не создавать явно, и тогда нет проблем.
3759.28 3762.00 "Игорь Лабутин" Называйте, как вы хотите, чтобы они у вас были внутри класса.
3762.00 3764.72 "Анатолий Кулаков" Не-не-не, у меня есть более лучшее решение.
3764.72 3773.00 "Анатолий Кулаков" Надо жить по гайдлайнам первых дотнетов, которые вы рассказывали, что подчеркивание – это пережитки перла и c++-ов.
3773.00 3779.72 "Анатолий Кулаков" Не делайте подчеркивания, называйте нормально ваши переменные, каким он, camelcase.
3779.72 3780.72 "Анатолий Кулаков" Ну camelcase, да.
3780.72 3784.08 "Анатолий Кулаков" Да, field и camelcase, и все, и нет никаких проблем вообще.
3784.08 3793.08 "Игорь Лабутин" Ну, проблема в том, что это не совсем field, если ты напишешь this. и вот это вот имя из primary constructor, тебе компилятор скажет «извини, нет такого поля».
3793.08 3803.76 "Анатолий Кулаков" Вот, а такого, наверное, у андрелока нет, да, что тебя немножко конфьюзит, когда ты пообращаешься к этим переменным как к хрен пойми к чему в каком-нибудь закопченной строке, а вот к field-ам через this можно
3803.76 3804.76 "Игорь Лабутин" обратиться.
3804.76 3812.32 "Игорь Лабутин" Не-не-не, есть у него где-то, я это явно не уносил в своей заметке, но есть, есть оно, то есть он где-то там про этому тоже проходится, не явно, косвенно, но проходится в одном из этих пунктов.
3812.32 3820.20 "Анатолий Кулаков" Вот мне кажется, что это для новичков, тех, кто изучает синтаксис, это вполне такой нормальный минус, потому что неконсистентный синтаксис получается уже.
3820.20 3859.64 "Игорь Лабутин" Вот, а самый последний пункт у него – это то, что с рекордами, короче, это все конфьюзится очень сильно, то, что я сказал вначале, т.е. если ты, допустим, объявишь рекорд, скажешь public, там рекорд, person, внутри string, там firstname, lastname, все будет хорошо, у тебя будет рекорд, у тебя будут в нем два свойства, которые будут и need, и set, соответственно, иметь эти самые модификаторы, у тебя будет конструктор, все будет зашибись, а потом ты меняешь ключевое слово рекорд на ключевое слово класс, у тебя сам код вот этого класса, он как бы скомпилится, но все, что его использовало, нет, потому что у тебя пропали автоматически созданные свойства, в общем, все пропало и ничего не компилируется.
3859.64 3875.12 "Анатолий Кулаков" Ну, а надо понимать, что это не такой уж редкий случай, когда мы классы меняем на астракты во время там перформанс-оптимизации каких-нибудь, и наоборот, астракты тоже часто бывают, переходят в классы, когда они становятся большими, копировать их слишком накладно становится.
3875.12 3880.92 "Игорь Лабутин" Ну, дело даже не в трактах, а в рекордах, у тебя может быть рекорд-класс, тут как бы рекорды же у нас теперь классы могут быть.
3880.92 3886.96 "Анатолий Кулаков" Да, могут, но опять же, есть рекорды астракта, есть рекорды класса, т.е. там тоже можно запутаться.
3886.96 3902.40 "Игорь Лабутин" Да, если ты из рекорда класса перейти вот в такой более продвинутый класс, где тебе может потребоваться параметры конструктора, вполне могут быть такие моменты, потому что, например, тебе рекорды уже мало, и ты хочешь переписать на нормальный класс с полноценным большим там набором не знаю чего.
3902.40 3906.36 "Анатолий Кулаков" Ну да, как только у тебя там появляется пара проверок, тебе уже становится его мало.
3906.36 3907.36 "Игорь Лабутин" Вот.
3907.36 3908.36 "Игорь Лабутин" Короче, вот такие дела.
3908.36 3909.92 "Игорь Лабутин" Т.е. кейс частый, да?
3909.92 3925.48 "Игорь Лабутин" Вот эта вот статья про то, что ну вроде есть и плюсы и минусы, как бы он приходит к мысли, что внутри своего кода, да, то, что он пишет, надо понимать, что я понимаю, что он там где-то разработал, он в датадок же сейчас, по-моему.
3925.48 3927.76 "Игорь Лабутин" Да, он поддержку дотнета в датадоке пишет.
3927.76 3936.64 "Игорь Лабутин" Вот, он говорит, что мы как авторы либы, ну как бы нам тоже надо это осмотрительно глядеть на то, какие классы наружу мы предоставляем, с какими именованиями и вот этим всем.
3936.64 3941.64 "Игорь Лабутин" Тут чуть как бы обширнее проблемы, да, чем в своей собственной кодовой базе внутри компании.
3941.64 3965.88 "Игорь Лабутин" А вот он говорит, что мы вроде как, ну так, внутреннее соглашение, ну или его там личное мнение, которого он всем доносит, про то, что мы используем параметры только в режиме инициализации филдов, то есть ты все равно руками прописываешь все филды, все проперти, все, что надо, а primary constructor чисто ради вот, чтобы не писать эту портянку с источника, призвать что-то, ты ее просто переносишь в объявление этих самых полей.
3965.88 3969.92 "Игорь Лабутин" В принципе, ну чуть-чуть сокращает код, понятное дело.
3969.92 3975.20 "Игорь Лабутин" Вот, но возникает вопрос, а как же сделать так, чтобы ты случайно не заюзал его где-то еще?
3975.20 3981.76 "Игорь Лабутин" И вот тут появляется уже третья статья про то, что можно использовать для этого roslin-аналайзер.
3981.76 3988.88 "Игорь Лабутин" Более того, такой roslin-аналайзер существует, он находится в пакете.
3988.88 3992.80 "Игорь Лабутин" Сейчас я даже не вспомню, как он называется, если не записал.
3992.80 4007.08 "Игорь Лабутин" Вот, он опубликован на nuget, но в описании этого пакета написано не используйте пакет, он только для roslin-internal-use, то есть это такой nuget-пакет с roslin-аналайзерами только для репозитория roslin-а, самого себя.
4007.08 4012.16 "Анатолий Кулаков" То есть команда roslin-а такая умная, что хочет правильного использовать, а нам навязать всякие глупости.
4012.16 4020.52 "Игорь Лабутин" Ну, там просто в пакете на самом деле есть и полезные аналайзеры типа этого, но на самом деле там просто куча всего, которые очень специфичны именно для roslin-а.
4020.52 4023.28 "Игорь Лабутин" Но Эндрю написал статью, как его таки добавить.
4023.28 4027.48 "Игорь Лабутин" Вы его добавляете, как обычный nuget-референс, вопросов нет.
4027.48 4045.68 "Игорь Лабутин" Дальше вы ставите такую пропертию в вашем css-продже, называется analysis-mode roslin-diagnostics-design, и значение у него должно быть all disabled by default, таким образом вы отключаете нафиг все анализаторы из этого nuget-пакета, а дальше нужно включить только нужный вам.
4045.68 4068.32 "Игорь Лабутин" Для этого в эдитор-конфиге, я не понимаю, почему не в css-продже, но теперь в эдитор-конфиге, нужно добавить строчку dotnet-diagnostics.rs0062.severity, ну и дальше поставить error or warning, что вы там хотите, вот rs0062 это как раз таки ошибка аналайзера про capturing параметров primary конструктора.
4068.32 4075.04 "Игорь Лабутин" И казалось бы, на этом все, все здорово, мы задизайблили все и включили только нужное.
4075.04 4111.72 "Игорь Лабутин" Однако на этом проблемы не заканчиваются, потому что этот nuget-пакет тянет за собой еще парочку транзитивных пакетов с roslin аналайзерами, в частности там есть public api аналайзер, если вы помните, я по-моему выпуска 3-4 назад мне кажется рассказывал про подход к public api, когда вы там держите файлик publicapi.publish.txt, publicapi.unpublish.txt и там как-то между ними все сортируете, это очень важно для библиотек, где вы хотите четко менеджить, что у вас входит в public api, а что не входит, но если вы делаете код, которым это абсолютно не важно, то этот аналайзер вам не нужен.
4111.72 4134.32 "Игорь Лабутин" Его тоже можно выключить через эдитор-конфиг, для этого туда нужно написать следующую строчку dotnet-public-api-analyzer.publish.txt и такая аналайзер .require-api-files внезапно true, я бы ожидал false, но если поставить require-api-files в true, то почему-то аналайзер public-api выключается, наверное в этом есть какая-то тонкая и важная логика, но в общем выключается.
4134.32 4135.80 "Анатолий Кулаков" Мы будем надеяться, что он будет есть.
4135.80 4155.96 "Игорь Лабутин" Да, короче, таким образом вы сможете затащить к вам в проект аналайзер, который, собственно, будет следить за тем, что если вы используете primary конструкторы, то вы используете, параметры этих конструкторов используются только для инициализации полей или пропертей, а не capture-ются они где-то в коде методов, пропертей либо еще чего-то.
4155.96 4171.80 "Игорь Лабутин" Энди говорит, ну, короче, нормальный, конечно, вариант, но по большому счету проще такой аналайзер, если у вас есть пакет с какими-нибудь вашими локальными аналайзерами, просто закинуть себе, потому что там весь аналайзер типа 20 строчек кода или 30, около того, он прям в стасе его и приводит.
4171.80 4183.64 "Игорь Лабутин" Там типа какая-то очень простая логика этого аналайзера, а благо Roslin довольно мощная штука, и написание аналайзера не очень сложное в этом случае конструкция.
4183.64 4198.88 "Игорь Лабутин" Поэтому если используете primary конструкторы или думаете о том, не затащить ли их в свою кодовую базу, обновившись на восьмерку .NET, посмотрите, подумайте, как же вы хотите использовать primary конструкторы и не хотите ли вы их чем-то ограничить, использование в вашей кодовой базе.
4198.88 4201.96 "Игорь Лабутин" Если хотите, смотрите статью, там написаны рецепты.
4201.96 4219.72 "Анатолий Кулаков" Ну, вот нам доставили фичу, которая в принципе сократила немножко пару строчек кодов в написании, но при этом ухудшило чтение, ухудшило понимание того, что реально происходит, а самое главное, ухудшило output, то есть тот код, который мы в результате компиляции получим.
4219.72 4232.00 "Анатолий Кулаков" И также точно вполне вероятно наличие бага из-за этого капчюринга, который может быть иногда кем-то не проверится или как-то хитро закапчурится, или там у него еще есть пара проблем из передачи в базовый класс.
4232.00 4235.56 "Анатолий Кулаков" Такое ощущение, что намного легче ее не использовать, тебе не кажется?
4235.56 4241.08 "Анатолий Кулаков" Чем вот эти все костыли городить, договариваться, анализаторы подключать, следить за этим за всем.
4241.08 4251.80 "Игорь Лабутин" Ну, слушай, грубо говоря, вот в классах типа контроллера, ну, которые в большинстве проектов не создаются руками, кажется, что проблем с этим нет.
4251.80 4254.20 "Игорь Лабутин" Хоть капчюри, хоть то дело, ну какая разница по большому
4254.20 4255.20 "Анатолий Кулаков" счету.
4255.20 4257.16 "Анатолий Кулаков" Ну, у меня ридонли, отсутствие ридонли там смущает.
4257.16 4263.92 "Игорь Лабутин" Ну вот, опять же, кажется, что в контроллерах, наверное, это не очень важно, хотя, черт знает, меня тоже немножко
4263.92 4264.92 "Анатолий Кулаков" смущает.
4264.92 4268.52 "Анатолий Кулаков" Опять же, если бы не было важно, мы бы его не использовали, а так у меня весь код обмазан ридонли, значит, где-то
4268.52 4269.52 "Игорь Лабутин" это важно.
4269.52 4270.52 "Игорь Лабутин" Еще и классы силт, небось.
4270.52 4274.64 "Анатолий Кулаков" Ну, обязательно, хотя бы это они не забрали у нас.
4274.64 4275.64 "Анатолий Кулаков" Хотя бы это мы можем добавить.
4275.64 4277.68 "Анатолий Кулаков" Ну, вот и там, я думаю, сможешь.
4277.68 4280.44 "Игорь Лабутин" Я тебе говорю, еще ключевое слово, и нормально.
4280.44 4292.60 "Игорь Лабутин" Эксплисит ридонли, имплисит ридонли, че ты, прям в классе будешь писать паблик класс имплисит ридонли, нет, паблик имплисит ридонли класс, вот, и будет нормуль.
4292.60 4296.92 "Анатолий Кулаков" Ох, ох, ох, ладно, пойдем дальше, сейчас сплошные расстройства.
4296.92 4297.92 "Анатолий Кулаков" Давай дальше.
4297.92 4298.92 "Игорь Лабутин" Чтобы нам успокоиться.
4298.92 4302.88 "Игорь Лабутин" Я придумываю идеи, так сказать, я их не пишу на github в C# команду, ты порадуйся.
4302.88 4307.52 "Анатолий Кулаков" Да, мне кажется, они как бы ловят, ловят все идеи, которые ты придумываешь, и потом имплементят.
4307.52 4308.52 "Анатолий Кулаков" Хорошо.
4308.52 4312.68 "Анатолий Кулаков" Поэтому ты, там, поменьше генерим или хотя бы что-то можешь.
4312.68 4313.68 "Анатолий Кулаков" Окей, не буду подсказывать.
4313.68 4315.68 "Анатолий Кулаков" Не буду подсказывать, не буду подсказывать, того буду.
4315.68 4316.68 "Анатолий Кулаков" Да.
4316.68 4320.52 "Анатолий Кулаков" Давай немножко успокоимся, а чтобы успокоиться, у нас есть нормальный раздел, называется архитектура.
4320.52 4326.52 "Анатолий Кулаков" В общем, безусловно, каждый разработчик, уважающий себя, естественно, разработчик, должен стремиться стать архитектором.
4326.52 4334.56 "Анатолий Кулаков" Поэтому мы регулярно в нашем подкасте, для тех, кто уже дорос, естественно, до этого уровня, рассказываем про архитектурные статейки.
4334.56 4344.96 "Анатолий Кулаков" И вот сейчас время медитации, поэтому налейте чаевочка, и погнали промедитируем про одну интересную предъяву, наброс.
4344.96 4354.68 "Анатолий Кулаков" Называется он, что вы не должны использовать натуральные ключи для того, чтобы выставлять праиморяки у таблиц.
4354.68 4361.48 "Анатолий Кулаков" Тоже вокруг меня что-то часто возникает эта тема, и вот как раз мне Марк Симон попался на глаза с этой статьей.
4361.48 4366.92 "Анатолий Кулаков" Он тоже сказал, что его, в принципе, все задолбали с этим дурацким заблуждением каким-то, почему оно ходит, до сих пор непонятно.
4366.92 4377.32 "Анатолий Кулаков" Я так порылся в уголках своей памяти, откуда вообще это поверье пошло, что мы должны выбирать натуральные ключи, и что натуральные ключи почему-то лучше синтетических, лучше искусственных.
4377.32 4382.44 "Анатолий Кулаков" Мне кажется, какой-то из модных небожителей такое проповедовал.
4382.44 4385.64 "Анатолий Кулаков" Игорь, не приходит на ум, откуда это вообще взялось?
4385.64 4388.92 "Игорь Лабутин" Нет, что-то я до схода не могу сообразить.
4388.92 4392.20 "Анатолий Кулаков" То ли чистый код, то ли DDD, то ли вот Evans.
4392.20 4405.92 "Игорь Лабутин" Где-то оттуда, да, но я что-то прям как бы… Я не помню нигде явных отсылок про это, мне кажется, это во многих книжках есть, и может быть в них это используется для упрощения.
4405.92 4413.12 "Игорь Лабутин" Ну то есть понятно, что когда у тебя есть какой-нибудь модельный пример для книжки, чем городить ещё один ключик, ну зачем?
4413.12 4416.08 "Игорь Лабутин" Вот он у тебя есть, код проще читать или удобнее.
4416.08 4427.84 "Анатолий Кулаков" Опять же, если мы говорим о новичках, которые только начинают свой путь, то им гораздо сложнее объяснить, что такое натуральный ключ, чем это чревато и какие баги у них будут, чем просто сказать, чуваки, всегда гуит и всё.
4427.84 4428.84 "Анатолий Кулаков" Ну, может быть, не знаю.
4428.84 4429.84 "Игорь Лабутин" Не знаю.
4429.84 4433.40 "Игорь Лабутин" С другой стороны, многие верят, что, не знаю, номер паспорта уникален.
4433.40 4437.88 "Анатолий Кулаков" Вот давайте про это подробнее поговорим, потому что действительно многие верят.
4437.88 4441.92 "Анатолий Кулаков" И в общем, независимо от их титула, такое заблуждение встречается довольно-таки часто.
4441.92 4458.96 "Анатолий Кулаков" Вот и Марк как бы посмотрел какой-то там очередной курс по проектированию баз данных, и каково же было его удивление, что на приличном солидном курсе начинающим разработчикам опять же вешает эту лапшу на уши, что базы данных должны дизайниться с точки зрения натуральных ключей.
4458.96 4462.12 "Анатолий Кулаков" То есть, если у вас натуральный ключ, то он должен быть праймари-кью.
4462.12 4463.84 "Анатолий Кулаков" Что такое натуральный ключ?
4463.84 4467.48 "Анатолий Кулаков" Это то, что мы в нашем мире, допустим, используем для идентификации.
4467.48 4471.68 "Анатолий Кулаков" Ну, вот есть у вас человек, у этого человека есть имя.
4471.68 4474.44 "Анатолий Кулаков" Естественно, каждому очевидно, что имя уникально.
4474.44 4478.04 "Анатолий Кулаков" Ну, как минимум, может, фамилия не уникальна, а имя с фамилией точно уникально.
4478.04 4482.08 "Анатолий Кулаков" Ну, если имя с фамилией не уникально, то имя, фамилия, отчество, оно вот точно везде уникально.
4482.08 4485.96 "Анатолий Кулаков" И вот это вот называется как бы естественный ключ, натуральный ключ.
4485.96 4489.52 "Анатолий Кулаков" Вот как-то его еще, наверное, называют.
4489.52 4495.52 "Анатолий Кулаков" Вот такие ключи рекомендуют на курсах дизайна баз данных создавать.
4495.52 4498.88 "Анатолий Кулаков" Иногда, кое-где, до сих пор, почему-то.
4498.88 4503.92 "Анатолий Кулаков" Давайте разберемся, а действительно ли это хорошая идея и действительно ли стоит ее придерживаться.
4503.92 4507.68 "Анатолий Кулаков" Ну, для примера возьмем какой-нибудь банальный примерчик.
4507.68 4513.24 "Анатолий Кулаков" Допустим, вам нужно создать таблицу, которая будет содержать в себе 50 самых лучших ресторанов в мире.
4513.24 4520.96 "Анатолий Кулаков" Обычный студент после такого курса создает таблицу ресторанс и у нее там, допустим, 4 колонки.
4520.96 4534.80 "Анатолий Кулаков" Это год, за который мы считаем эти 50 ресторанов, это позиция, на которой находится ресторан, это name, т.е. имя ресторана, как он называется, и, может быть, имя сити, имя города, в которой этот ресторан расположен.
4534.80 4542.36 "Анатолий Кулаков" И курса советует выбрать здесь обычный натуральный ключ.
4542.36 4544.08 "Анатолий Кулаков" Что же может быть здесь натуральным ключом?
4544.08 4550.80 "Анатолий Кулаков" Ну, во-первых, нужно сказать, да, что никакой дополнительной колонки с ключом мы не заводим, мы пытаемся здесь найти какой-то натуральный.
4550.80 4567.04 "Анатолий Кулаков" Ну, вполне натуральный может быть ресторан name, но, опять же, имя ресторана, наверное, может пересекаться, если там какой-то не мировоизвестный бренд, но даже мировоизвестные бренды делают какие-то бранчи, франшизы и так далее, и тоже могут называться одинаково в разных городах.
4567.04 4574.48 "Анатолий Кулаков" Ну, можно сделать составной ключ, можно сделать имя ресторана и плюс имя города, в котором находится этот ресторан.
4574.48 4579.92 "Анатолий Кулаков" Более или менее, наверное, это уже как-то прокатит для топ-50, если мы говорим, лучших ресторанов в мире.
4579.92 4587.52 "Анатолий Кулаков" Ну, вот чем отличается обычный разработчик от хорошего разработчика?
4587.52 4595.04 "Анатолий Кулаков" Он начинает, хороший разработчик, он начинает это решение каким-то образом челленджить, т.е. он начинает думать, а действительно ли это так?
4595.04 4603.80 "Анатолий Кулаков" А действительно ли все рестораны подходят под это условие главного ключа, т.е. не может быть двух ресторанов с одинаковым именем в одном и том же городе?
4603.80 4626.76 "Анатолий Кулаков" Ну, наверное, если мы делаем тот топ-50, то не может, но хороший разработчик понимает, что если бизнес сегодня попросил сделать табличку топ-50, завтра он попросит сделать топ-100, потом топ-1000, а потом давайте делать вообще справочник всего ресторана, всех ресторанов во всем мире, да, и когда мы делаем справочник всех ресторанов во всем мире, а действительно ли нам хватит имени и города как натурального ключа?
4626.76 4628.36 "Анатолий Кулаков" Ну, теперь уж точно не хватит.
4628.36 4636.24 "Анатолий Кулаков" Можно добавить country, т.е. если у нас будет, в принципе, страна, то это уже как-то ещё сужает нашу область.
4636.24 4645.60 "Анатолий Кулаков" Ну, даже если мы добавим country, да, т.е. у нас получается, допустим, Россия, СПБ, великий, самый лучший ресторан, который называется Шаверма.
4645.60 4650.12 "Анатолий Кулаков" Вот как вы думаете, сколько в СПБ ресторанов, которые называются Шаверма?
4650.12 4660.36 "Анатолий Кулаков" Если вы думаете, что нужно добавить какой-нибудь регион, т.е. район города, в котором мы наш списочек немножко сужаем, то нет, район вам тоже не поможет.
4660.36 4665.20 "Анатолий Кулаков" Я думаю, что даже на одной улице десяток таких ресторанов найдётся.
4665.20 4667.76 "Анатолий Кулаков" Т.е. этот ключ всё равно не будет уникальным, т.е.
4667.76 4672.36 "Анатолий Кулаков" вы его в уникальность никак не приведёте никакими вашими приседаниями.
4672.36 4681.88 "Анатолий Кулаков" И, в принципе, вот это отсутствие уникальности, если мы разбираем общий случай, а не какой-то очень узкий, очень частый, оно нас сопровождает очень много где.
4681.88 4692.12 "Анатолий Кулаков" Например, часто в регистратурах или в паспортных столах уникальным ключом выбирается фамилия, имя, отчество у человека, что тоже абсолютный бред, это абсолютно не уникальный показатель.
4692.12 4701.44 "Анатолий Кулаков" Так же точно, как, например, могут там в справочнике городов выбираться, что во всём мире город будет назван уникально, без учёта страны, это тоже бред, никогда он не будет назван уникально.
4701.44 4707.48 "Анатолий Кулаков" Но это же относится к любым именам, например, моделям, модель телефона, модель автомобиля, ещё чего-то.
4707.48 4720.28 "Анатолий Кулаков" Они тоже, несмотря на то, что вам кажется, что Nokia 3310, она единственная во всём мире, нет, бывают кроме Nokia ещё какие-то изобретения, используя эти цифры.
4720.28 4732.60 "Анатолий Кулаков" В общем, когда мы говорим о каком-то человекочитабельном имени, то, скорее всего, можно найти кейсы, где оно не уникально, т.е. здесь нам вот этот естественный ключ подходит не очень хорошо.
4732.60 4736.08 "Анатолий Кулаков" Теперь поговорим про другой аспект – это идентичность.
4736.08 4745.56 "Анатолий Кулаков" Ну, допустим, с именами, конечно, пример может быть вырожденный, потому что до этого иногда джиньёры додумываются, что имя может быть не уникально.
4745.56 4753.12 "Анатолий Кулаков" Но у нас есть другие примеры, которые прямо явно говорят, что их нужно использовать для вот этого натурального ключа.
4753.12 4764.84 "Анатолий Кулаков" Допустим, тот же самый Вин номер, который есть во всех автомобилях и чётко декларируется в любом справочнике, что Вин номер уникален, он во всём мире уникален, он 100% уникален, и никуда вы от этого не денетесь.
4764.84 4775.72 "Анатолий Кулаков" А также, например, есть номер паспорта, номер паспорта тоже уникален, по номеру паспорта легко можете определить человека и никуда вы от этого тоже не денетесь.
4775.72 4789.88 "Анатолий Кулаков" Более того, и номера паспортов и Вины уже есть в какой-то базе данных, где они точно 100% уникальны, например, в паспортном столе наверняка у них есть список паспортов, где номер паспорта уникален, т.е. вам кто-то в сторонне даже уже гарантирует, что это точно уникальность.
4789.88 4794.40 "Анатолий Кулаков" Надо ли вам использовать этот номер паспорта у себя в таблице как уникальный?
4794.40 4805.36 "Анатолий Кулаков" В принципе, нет, потому что действительно вы можете по номеру паспорта индивидуально определить человека, т.е.
4805.36 4815.80 "Анатолий Кулаков" уникальность у него может быть хорошая, но вот какого человека и когда вы определите, вот это уже вопрос большой, потому что один человек может иметь несколько паспортов.
4815.80 4817.92 "Анатолий Кулаков" У этих паспортов, естественно, будут разные номера.
4817.92 4838.16 "Анатолий Кулаков" Также, ну, допустим, старый у вас паспорт, вы его поменяли, вы можете его просто поменять, а также вы можете получить еще какой-нибудь второй паспорт, может быть, другой страны, может быть, вы старый потеряли, а новый получили, и у вас два актуальных паспорта будут, или вы можете вообще не иметь паспорта, в принципе, ничего не мешает, по конституции вы не обязаны иметь паспорт, ничего не мешает жить без паспорта.
4838.16 4854.12 "Анатолий Кулаков" Этот кейс тоже валиден, т.е. мы видим несколько ситуаций, когда, казалось бы, номер паспорта уникальный и все хорошо, но для идентификации человека оно не подходит, особенно если мы говорим на какой-то конкретный определенный промежуток времени, вот у него вчера был один паспорт, сегодня он поменял, например, у него другой паспорт.
4854.12 4867.36 "Анатолий Кулаков" В общем, это все происходит потому, что уникальность никаким образом не дает вам биекции, т.е. вы теряете немножко информации, та, которая у вас есть сейчас.
4867.36 4903.04 "Анатолий Кулаков" Ну, например, если вы говорите, что у нас есть какой-то ВИН-номер, да, и мы хотим этот ВИН-номер использовать как уникальный ключ для идентификации автомобиля, то вы можете потерять часть информации, например, если вы вместе с ВИН-номером захотите хранить регистрационный номер автомобиля, тот, который выдается как раз юридически, который выдается в ГАИ, и этот регистрационный номер, естественно, может меняться, один ВИН-автомобиль, т.е. один физический автомобиль, отдельное шасси, рама, она может менять регистрационный номер в ГАИ сколько угодно раз.
4903.04 4916.40 "Анатолий Кулаков" Таким образом, у них сегодня один регистрационный номер, завтра другой регистрационный номер, и вот эту всю историю вы теряете, если привязываетесь к тому, что ВИН-номер у вас является праймари-ключом, т.е. это естественный ключ.
4916.40 4929.48 "Анатолий Кулаков" И таких примеров их в принципе миллион, т.е. таких адресов, которые уникальны, с ними все хорошо, но при этом они не созданы для того, чтобы однозначно идентифицировать какой-то определенный срез данных.
4929.48 4937.52 "Анатолий Кулаков" Ну, например, упомянутый уже регистрационный номер, да, тоже, казалось бы, он уникальный, хотя бы в пределах России регистрационный номер уникален, на него можно положиться.
4937.52 4940.48 "Анатолий Кулаков" Ну, опять же, нет.
4940.48 4944.80 "Анатолий Кулаков" Мак-адрес у сети тоже уникальный в пределах мира, но он меняется.
4944.80 4950.72 "Анатолий Кулаков" IP-адрес, такая же точная ситуация, хоть он и уникальный там в пределах какого-то маршрутизатора, но он тоже меняется.
4950.72 4966.16 "Анатолий Кулаков" Многие базы данных грешат тем, что ставят номер телефона как уникальный ключ, тоже естественный, красивый, но опять же, многие забывают, что у пользователя может быть несколько телефонов, может не быть телефона, пользователь хочет поменять телефон, тогда начинаются проблемы.
4966.16 4973.28 "Анатолий Кулаков" Та же точная ситуация с e-mail адресом, почему-то все рассчитывают, что у пользователя обязательно есть e-mail адрес, он никогда не меняется и он всегда один, это полная глупость.
4973.28 4990.60 "Анатолий Кулаков" Те, кто работал в интерпрайзе и сталкивался с таким замечательным инструментом, как Confluence, наверняка не раз жалели, что у него естественный ключ – это заголовок страницы, т.е. вы не можете создать страницу, две страницы с одинаковым заголовком, он работает по типу Вики.
4990.60 4996.36 "Анатолий Кулаков" Тоже пример полного абсурда, зачем так было делать, абсолютно непонятно.
4996.36 5000.32 "Анатолий Кулаков" Т.е. без учета иерархии, глобальным в одном подразделе нельзя так делать.
5000.32 5007.04 "Анатолий Кулаков" Поэтому мы теперь приходим ко второму свойству ключа, которое должно соблюдаться и удовлетворяться – это идентичность.
5007.04 5014.72 "Анатолий Кулаков" Т.е. уникальность – это, конечно, хорошо, и даже если вы нашли ключ, уникальный во всем мире, то подумайте, а что именно он идентифицирует.
5014.72 5024.34 "Анатолий Кулаков" Теперь подходим к третьему шагу, допустим, вы нашли идеальный уникальный ключ, который уникален во всем мире, допустим, он идентифицирует то, что вы хотите и это никогда не меняется.
5024.34 5033.32 "Анатолий Кулаков" Ну вот вы захотели физическую шасси, номер шасси идентифицировать, вот вам ВИН подошел 100% и больше вам, в принципе, из жизни ничего не надо.
5033.32 5039.70 "Анатолий Кулаков" Вы не привязываете к нему ни юридические регистрационные номера, ни владельцев, ничего, это у вас там хранится в других базах.
5039.70 5043.76 "Анатолий Кулаков" Допустим, вы все это сделали, т.е. могут быть такие ситуации.
5043.76 5053.40 "Анатолий Кулаков" Здесь есть один финальный аргумент, который должен вас уберечь от того, чтобы все-таки использовать естественные ключи – это ошибки ввода-вывода.
5053.40 5054.72 "Анатолий Кулаков" Что это значит?
5054.72 5060.72 "Анатолий Кулаков" Это значит, что когда пользователь вводит этот ВИН-номер, он может опечататься, он может допустить ошибку.
5060.72 5069.60 "Анатолий Кулаков" Это бывают ошибки ввода-вывода, это бывают ошибки, например, в сериализации и форматировании, или, например, когда вы передаете данные из одного сервиса в другое.
5069.60 5077.88 "Анатолий Кулаков" Один сервис вам выдает, допустим, номера телефонов в одном формате, а тот принимающий сервис пытается по телефону распространить совершенно в другом формате.
5077.88 5085.20 "Анатолий Кулаков" Более того, можно эту ситуацию представить не только между разными сервисами.
5085.20 5101.24 "Анатолий Кулаков" Допустим, когда вы свой сервис обновляете, у вас были, например, только локальные номера телефонов, только в пределах России, а потом вы сделали миграцию какую-то в базе данных или в коде, или еще где-то, и теперь вы международные номера телефонов воспринимаете как правильные и адекватные.
5101.24 5112.76 "Анатолий Кулаков" Так вот, если у вас был ключом номер телефона в одном формате, а потом стал ключом номер телефона в другом формате, то нужно понимать, что все ссылки, допустим, на внешние таблицы вам тоже необходимо будет обновить.
5112.76 5114.60 "Анатолий Кулаков" Но ссылки – это еще полбеды.
5114.60 5135.36 "Анатолий Кулаков" А вот если вы эти Primary ключи отдавали куда-то наружу, ну, например, отправляли смски или отправляли e-mails с определенно сформированной ссылкой, которая должна была вернуть вас обратно и четко идентифицировать вас на определенную запись, а эта запись идентифицировалась вашим ключом, а ключом у вас был номер телефона в старом формате.
5135.36 5140.92 "Анатолий Кулаков" Так вот, после миграции вы этого ключа в старом формате больше у себя в базе не найдете, потому что он теперь записывается в новом формате.
5140.92 5164.80 "Анатолий Кулаков" И вот такая неконсистентность данных, вот такая изменяемость данных должна навести вас на определенную мысль, потому что система должна быть задизайнена таким образом, особенно вот система хранения, долгосрочного хранения базы данных, она должна быть задизайнена таким образом, чтобы позволять корректировать данные, особенно это касается внешних данных.
5164.80 5173.76 "Анатолий Кулаков" Те же самые номера телефонов, их формат может меняться, вы можете осваивать новые рынки и во всех странах номера телефона более-менее отличаются.
5173.76 5179.52 "Анатолий Кулаков" Ну, номера телефона – это полбеды, а если мы, например, возьмем регистрационные номера машин, то это вообще лютый ахтунг.
5179.52 5184.72 "Анатолий Кулаков" Там у каждой страны абсолютно свои стандарты, общимирового не существует.
5184.72 5196.28 "Анатолий Кулаков" Или даже если вы возьмете там тот же самый social security number, который тоже популярный и очень, потому что он якобы уникальный, выдается человеку с рождения, никогда не меняется и так далее.
5196.28 5207.12 "Анатолий Кулаков" Это тоже неправда, потому что были прецеденты, когда его формат менялся, добавлялись новые буковки, новые циферки, какие-то новые данные и приходилось немножко подстраиваться под этот новый формат.
5207.12 5216.88 "Анатолий Кулаков" То есть, все это меняется, поэтому вы должны дизайнить свою систему с тем расчетом, что любая внешняя информация может корректироваться.
5216.88 5225.00 "Анатолий Кулаков" То есть, те данные, которые вам сказали, что они никогда не меняются и будут только в этом формате, они в любом случае могут корректироваться.
5225.00 5231.96 "Анатолий Кулаков" Даже если государство поклянется, что никогда их менять не будет, у вас могут быть ошибки пользовательского ввода, вы обязаны уметь их корректировать.
5231.96 5238.40 "Анатолий Кулаков" У вас может быть взаимодействие с какой-то сторонней системой, но формат совершенно другой, вы обязаны уметь это всё тоже корректировать.
5238.40 5247.56 "Анатолий Кулаков" Таким образом, мы приходим к тому, что все вот эти естественные данные, которые мега уникальные, мега красивые, мега хорошие, они должны уметь меняться.
5247.56 5249.24 "Анатолий Кулаков" Отсюда следует простой вывод.
5249.24 5263.52 "Анатолий Кулаков" Раз они должны уметь меняться, то есть корректироваться, их ни в коем случае нельзя использовать как primary ключи для вашей базы данных, потому что primary ключи должны быть стабильными и не меняться никогда, даже если пользовательский ввод их ввел некорректно, меняться они от этого не должны.
5263.52 5273.68 "Анатолий Кулаков" И здесь мы вступаем в конфликт с тем, что мы одновременно хотим эти данные и показывать пользователю, и поддерживать их в актуальном, в корректном состоянии, и при этом меняться они никогда не должны.
5273.68 5278.94 "Анатолий Кулаков" Поэтому мы приходим к логическому выводу, что это должны быть разные поля.
5278.94 5288.44 "Анатолий Кулаков" Есть определенное поле, которое никогда не меняется, которое уникальное, которое стабильно, которое ни при каких условиях не будет корректироваться, от чего бы оно ни зависело.
5288.44 5296.56 "Анатолий Кулаков" Есть отдельные поля, которые показывают пользовательские данные, которые показывают какие-то, опять же, естественные данные.
5296.56 5299.16 "Анатолий Кулаков" Вот они должны отображаться пользователю и должны показываться.
5299.16 5308.56 "Анатолий Кулаков" Это абсолютно не значит, что вы на них не можете накладывать уникальные констрейнты, даже более того, вы должны на них накладывать уникальные констрейнты, если хотите, чтобы ваша программа гарантировала их уникальность.
5308.56 5312.84 "Анатолий Кулаков" Но, опять же, не путайте, это не primary ключ, и вот там его использовать не нужно.
5312.84 5319.44 "Анатолий Кулаков" Что можно сказать в заключении всей этой тирады?
5319.44 5328.52 "Анатолий Кулаков" Говорит, что в те далекие времена, когда он был молодым, зеленым и глупым, и когда пытался использовать натуральные ключи, не было ни одного времени, когда он об этом бы не пожалел.
5328.52 5331.92 "Анатолий Кулаков" Поэтому сейчас он пришел к одной единственной истине.
5331.92 5334.52 "Анатолий Кулаков" Всегда нужно использовать синтетические ключи.
5334.52 5339.76 "Анатолий Кулаков" Не загоняться, не думать, не рассчитывать на то, что они когда-то там не поменяются, ничего там не сделают.
5339.76 5345.80 "Анатолий Кулаков" Нет, они поменяются, они скорректируются, они всегда будут не уникальными, в общем, синтетические ключи – наше все.
5345.80 5358.84 "Анатолий Кулаков" Поэтому никогда не пытайтесь использовать натуральные ключи, а просто всегда делайте синтетические ключи, и будет вам счастье, ваши волосы будут шелковистыми, а на ваши натуральные ключи просто накладывайте уникальные констрейты, если для вас это важно, и живите безопасно.
5358.84 5363.16 "Игорь Лабутин" Мне даже добавить особо нечего, действительно.
5363.16 5366.04 "Игорь Лабутин" Всегда используйте синтетический ключ, и все.
5366.04 5376.68 "Анатолий Кулаков" Это, опять же, смотри, это несложно, в отличие от натуральных ключей, которых ты обязан задумываться, как бы их обозначить, а как бы их скомбайнить, а как бы их передать, а как бы их там поддержать.
5376.68 5382.80 "Анатолий Кулаков" Т.е. слишком много непонятных сложностей, и 100% ты потом в будущем на эти грабли наступишь, и они тебя подведут.
5382.80 5393.72 "Анатолий Кулаков" Когда ты просто берёшь синтетический ключ, здесь не надо думать, не надо никаким образом загоняться с реализаторами, ты просто делаешь синтетический ключ и живёшь потом счастливо, ну т.е. одни плюсы.
5393.72 5396.36 "Игорь Лабутин" Откуда вообще пошла такая мода, вообще непонятно.
5396.36 5406.68 "Игорь Лабутин" Заодно есть ещё такой эффект, этот самый primary ключ часто попадается в урлах каких-нибудь, там get/что-нибудь, и одно дело там будет GUID, а другое дело там будет номер паспорта.
5406.68 5420.98 "Анатолий Кулаков" Да, да, опять же, не надо забывать, что часто такие уникальные ключи, они очень часто бывают, или там personal information, или personal security, или вообще какие-нибудь нежелательные данные.
5420.98 5429.40 "Анатолий Кулаков" А если вы будете засовывать в урлы, то это всё кэшируется, достаётся из кэшей, всяких DNS-проксей, и это не очень хорошо.
5429.40 5430.40 "Анатолий Кулаков" Да, всё так.
5430.40 5444.68 "Игорь Лабутин" Ну давай пойдём дальше, у нас есть ещё одна техническая тема, она такая, частично новость, частично статья, но кажется довольно интересно, и это обновление в сайте документации Microsoft, внезапно.
5444.68 5455.44 "Игорь Лабутин" Я сначала, когда новость увидел, подумал, что ну как бы обновился, обновился, что там про это рассказывать, а потом прям новость почитал, и там такая глубокая техническая статья, поэтому расскажем про неё поподробнее.
5455.44 5470.76 "Игорь Лабутин" Штука в чём, поскольку у нас дотнет опенсорсный, то когда мы нашли какую-нибудь интересную напишку или полезную напишку, или просто вы используете какую-то опишку в стандартной библиотеке, она как-то себя ведёт непонятно, странно.
5470.76 5490.12 "Игорь Лабутин" Ну допустим, вы идёте читать документацию, вдруг там написано, почему она себя ведёт именно так в каком-то конкретном вашем случае, а иногда там не написано, или ваш случай какой-нибудь очень специфический, и тогда вы идёте в исходный код разбираться, что же там происходит-то и почему, и найти, где же она есть в исходном коде, иногда довольно большая проблема.
5490.12 5499.72 "Игорь Лабутин" Во-первых, нужно либо поискать по гитхабу, ну, вы поищите, там будет какой-нибудь, не знаю, стринг джойн, как вы думаете, сколько этих стринг джойнов в исходниках дотнета?
5499.72 5500.72 "Игорь Лабутин" Вообще много.
5500.72 5506.36 "Игорь Лабутин" Ну и опять же, искать что-то отдельное, плюс там перегрузок дофигища, сложно.
5506.36 5519.48 "Игорь Лабутин" Поэтому теперь в самых популярных, как сказано в статье, кусочках документации, ну, референсной документации по каким-нибудь методам, есть ссылки прямо на исходный код.
5519.48 5533.04 "Игорь Лабутин" То есть прямо там, где у вас написано, в какой обычной сборке оно лежит, да, в каких версиях поддерживается, там же есть прямо ссылочка на гитхаб, где вы можете прямо почитать код прям конкретной каждой функции.
5533.04 5537.72 "Анатолий Кулаков" Слушай, мне кажется, если бы у документации была бы киллер-фича, то вот это вот она.
5537.72 5554.12 "Анатолий Кулаков" В общем, я ловил себя на мысли, что мне очень часто не хватало такой штуки, я очень часто гуглил, искал на гитхабе какие-то определенные классики, испытывал все те трудности, которые ты рассказал, и прямо вот это вот именно та вещь, которая должна была быть везде с самого начала, как только они за open-source селись.
5554.12 5555.12 "Игорь Лабутин" Это очень круто.
5555.12 5566.88 "Игорь Лабутин" Да, у меня давно уже склонирован run-time repository к себе, но опять же искать по ним это прямо сложно, да, это полнотекстовый поиск, и он, ну, так себе работает.
5566.88 5631.08 "Игорь Лабутин" Короче, теперь у нас есть такая штука, и это работает как минимум в .NET API, у которых выполнены следующие критерии, то есть, во-первых, там должен быть включен сурс-линк, во-вторых, PDB-шки к ним должны быть доступны, ну и в-третьих, исходники, понятно, должны хоститься в публичном репозитории, то есть если там найти какую-нибудь .NET API, которая, не знаю, является оберткой на какой-нибудь внутренней виндовой API, поэтому исходники этой .NET API лежат в какой-нибудь private-репозитории Microsoft, ну, сорян, конечно, тут линка никуда не будет, но для большинства API из обычного .NET все будет работать, и причем там прикольно, что если у вас много оверлоудов, то в каждом оверлоуде будет ссылка на свой собственный оверлоуд внутри исходников, то есть оно не просто как бы на файле, где оно есть, а прямо на нужный диапазон строчек с нужным оверлоудом, где вы уже дальше можете погулять по ним и понять, что, где, как и что работает.
5631.08 5640.16 "Игорь Лабутин" Как же это все устроено, то есть вот первая часть статьи, она была про то, что же мы сделали, она довольно короткая, а вот дальше как оно все устроено, и там прям интересно.
5640.16 5647.88 "Игорь Лабутин" Значит, как работает, вообще как собирается сайт доков Microsoft?
5647.88 5663.60 "Игорь Лабутин" Он на самом деле собирается довольно забавно, потому что он, это некоторый набор скриптов, pipeline, который работает, и источником этой информации является на самом деле набор dll, ну и некоторых nuget пакетов.
5663.60 5671.44 "Игорь Лабутин" Именно сканируя эти dll, сайт Microsoft, генератор документации понимает, какие вообще API нужно включить в документацию.
5671.44 5680.00 "Игорь Лабутин" Дальше есть отдельный вопрос, где-то там есть более подробное описание, где-то менее подробное описание, но в целом как бы начинаем мы с dll.
5680.00 5703.44 "Игорь Лабутин" И дальше надо сделать всего лишь простую штуку, то есть нам нужно всего лишь, взяв dll, поняв, какие в нем есть функции, понять, где же исходники от этой dll, мало того, где исходники не только в момент сборки dll, но где эти исходники искать на GitHub, ну и потом как это все слепить вместе.
5703.44 5719.04 "Игорь Лабутин" И по факту, по факту, то, что нужно сделать, очень похоже, прям довольно сильно совпадает с тем, как ведет себя функциональность под названием GoToDefinition в студии, ну или где угодно.
5719.04 5733.04 "Игорь Лабутин" То есть по факту, когда вы стоите на какой-то функции и жмете на ней горячую клавишу или выбираете в меню GoToDefinition, по большому счету это то же самое, как если бы вы читаете документацию на эту функцию и хотите перейти к ее исходникам.
5733.04 5735.64 "Игорь Лабутин" В общем-то, примерно похожая задачка.
5735.64 5753.28 "Игорь Лабутин" И поскольку для решения задачки GoToDefinition в какой-то момент была реализована технология SourceLink, то как раз-таки именно она довольно неплохо подходит для решения задачи, как бы нам сделать ссылки из документации в код.
5753.28 5765.36 "Игорь Лабутин" Значит, что такое SourceLink и вообще как оно, когда-то мы про него немножко рассказывали, когда он видимо только появился или где-то в каких-то новостях светился, но аккуратненько напомню.
5765.36 5766.36 "Игорь Лабутин" Что же такое SourceLink?
5766.36 5771.60 "Игорь Лабутин" То есть SourceLink это штука, которую можно включить в дотунет-проекте в момент сборки.
5771.60 5796.12 "Игорь Лабутин" И в этом случае, помимо стандартной PDB-шки, где лежат собственные отладочные символы, и некоторое соотношение, грубо говоря, диапазонов исходного кода с какой-то отладочной информацией, с лиль-кодом и так далее, так чтобы можно было сделать маппинг обратно из кода в символы.
5796.12 5872.04 "Игорь Лабутин" Ну, в дотунете с символами попроще, да, у нас есть метаданные, которые, в общем, почти все содержат и так, и без PDB-шек, но тем не менее, некоторая вспомогательная база данных, грубо говоря, для отладки, но кроме этого, при включении SourceLink генерится еще некоторый специальный маппинг из имен локальных файлов, причем относительно корня Solution, грубо говоря, до абсолютных урлов в репозитории каком-то, из которого это все собиралось в момент сборки, т.е. если вы собрали что-то и это было на GitHub, то, соответственно, SourceLink должен указывать на GitHub, но надо понять, а как, собственно, этот самый, как теперь вот собрать эту уникальную ссылку для каждого типа или мембера этого типа в DLL-ке, т.е. вот у нас есть DLL, там есть какая-то API, на которой у нас есть документация, внутри у нас есть какой-то там SourceLink информация, т.е. маппинг из имен файлов в какие-то ссылки в каком-то GitHub, например, как из этого собрать ссылку на место конкретного файла для конкретного метода API, что делается?
5872.04 5897.28 "Игорь Лабутин" Ну, для начала мы уже сегодня упоминали библиотечку System Reflection Metadata, вот она используется для того, чтобы обойти все типы и мемберы в этой DLL-ке и поискать информацию, которая помечена, которая содержится в специальной табличке "Method Debug Information" в этом pdb-самом метаданных, и все это вместе позволит построить нам ссылочки.
5897.28 5898.60 "Игорь Лабутин" Что делается?
5898.60 5902.16 "Игорь Лабутин" Ну, для начала нужно понять корень.
5902.16 5917.52 "Игорь Лабутин" Начало ссылки, т.е. это, грубо говоря, от самой репозитории основной, плюс в репозитории обычно выбирается либо ветка, либо в большинстве случаев выбирается не конкретная ветка, потому что нужна же точная информация, да, из чего собирался, поэтому выбирается прям конкретный snapshot-репозитория.
5917.52 5937.80 "Игорь Лабутин" И вот эта базовая информация, она есть в сурс линковой информации, откуда взята, ну, соответственно, обычно она выглядит что-то в духе GitHub.com/.net/runtime/blog/idnick.commit, это как бы прям уникальная вот ссылка, которая указывает точно на тот commit, из которого было собрано все.
5937.80 5943.56 "Игорь Лабутин" Дальше возникает вопрос в какое место, в каком файле это искать.
5943.56 5956.86 "Игорь Лабутин" Это содержится в PDB-шке, в табличке под названием document, и оттуда получается путь вида какой-нибудь там src/libraries/system-private-core-lib/src/system/string.cs.
5956.86 5968.68 "Игорь Лабутин" Но string.cs, если просто открыть его в репозитории, это как бы там сотни строк, давно не открывал, но по-моему там сотни строк в буквальном смысле, а нам нужна тот самый наш там, не знаю, string.join конкретный.
5968.68 5981.68 "Игорь Лабутин" Для этого внутри ссылки GitHub позволяет сделать хайлайт нужных ссылок, для этого нужно ему передать специальные query-параметры, это решетка l что-нибудь, да, тире там решетка, тире l что-нибудь другое.
5981.68 6004.16 "Игорь Лабутин" И тут мы снова смотрим в табличку method_debug_information, и там написана штука под названием sequence_points, и это данные, которые майпят по сути набор или инструкций в методе обратно к исходникам в коде.
6004.16 6008.60 "Игорь Лабутин" Ну и собственно о чем мы с этим делаем-то теперь?
6008.60 6033.04 "Игорь Лабутин" Ну с этим как бы нужно нам сделать следующее, это общая информация про то, что хранится по сути в этом файлике, да, что хранится в pdb, в source-линке, то есть мы технически, зная где у нас находится этот метод dll, да, какой или ему соответствует, можем найти теперь в каком репозитории, в каком файле и какие, какой конкретные строчки в этом файле соответствуют этому методу.
6033.04 6043.00 "Игорь Лабутин" Ну это все здорово, но теперь нам нужно понять, вот у нас есть dll, а нам нужно собрать из этого сайт документации, что будем делать?
6043.00 6069.04 "Игорь Лабутин" Ну первонаперво нам нужно понять откуда взять pdb, и тут тоже есть несколько вариантов, вариант первый, если вы собирали ваш код, или дотнет конкретно собирался с опцией debug_type_embedded с sproj, то в таком случае pdb-шка будет прям заимбежана в dll в виде ресурса, это простой случай, вот pdb прям лежит внутри, но это раздувает размер файла, и понятно, что дотнет с таким по-моему не собирается.
6069.04 6087.44 "Игорь Лабутин" Дальше pdb-шка может лежать прямо рядом с dll, прямо вот в той же директории, тоже легко найдется, обычный дотнет тоже не вариант, ну и для дотнет естественно используется Microsoft Symbol Server, публичный символ сервер, где можно найти все pdb-шки для официально собранных dll.
6087.44 6094.24 "Анатолий Кулаков" Похоже чем-то на nuget, то есть если вы с nuget забираете пакеты, то вы можете сходить на такой же сервер и достать оттуда pdb-шки.
6094.24 6114.44 "Игорь Лабутин" Да, да, да, да, вот туда публикуются официальные, все официально собранные дотнет SDK, и поэтому понятно, что если вы собрали дотнет SDK и на его основе собираете сайт документации, то pdb-шки будут на Symbol Server, может быть не на официальном и публичном, если вы собираете что-то заранее, а на каком-нибудь внутреннем и промежуточном, но где-то они будут.
6114.44 6121.64 "Игорь Лабутин" Дальше интереснее, pdb-шку-то мы нашли, вот дальше есть еще пункт под названием finding the dll file.
6121.64 6134.36 "Игорь Лабутин" Казалось бы, ну а в чем проблема-то, как бы dll-ки-то вот они же все лежат, но на самом деле для некоторых dll-ик нужно очень покреативить.
6134.36 6141.32 "Игорь Лабутин" Пункт первый, ну даже не совсем про dll-ки, dll-ки-то они лежат, но для некоторых dll-ик нужна прям очень креативная обработка.
6141.32 6229.88 "Игорь Лабутин" Во-первых, некоторые dll-ки есть только в виде reference assembly, то есть это специальный режим сборки, ну с ней специальные сборки, которые умеют генерировать компилятор, которые содержат только, грубо говоря, паблик информацию о типе, то есть все паблик там поля, то есть все, что может вам потребоваться знать для того, чтобы поиспользовать такие классы или там такие методы, мемберы, все что угодно из других сборок, но без собственно реализации, потому что ну обычно тело реализации для такого не нужно, нужно для фазы компиляции и так далее, так вот для таких reference сборок у них нету pdb-шек, тут как раз приходится выпендриваться, и если мы знаем, что у нас есть какая-то такая reference сборка, мы специально загружаем специальный runtime package, то есть у нас, понятно, такие сборки обычно используются, если мы, например, собираем относительно shared рантайма, то вам не нужно такую сборку тащить в свою сборку, она будет в рантайме, вам нужно только на этапе компиляции иметь reference assembly, чтобы знать, какие типы там есть, больше ничего не нужно, потому что сама сборка будет в рантайм пакедже у вас, установленном там, где вы запускаетесь, так вот в момент сборки нам нужно сходить тогда, скачать этот рантайм пакедж, найти там такую же нужную сборку, которая соответствует вашей reference дл, и из нее уже проделывать pdb-шки, искать source-линки и так далее.
6229.88 6282.60 "Игорь Лабутин" А второе, у нас есть генерация сурсов в момент сборки, и вот тут совсем плохо, потому что ну как бы, а как, вот тут сложнее, тут мы понятно, что не можем никуда сослаться, ну у нас просто нету никаких гитхабовских, точнее как какой-то гитхабовский код есть, который собственно занимается генерацией этих сурсов, мы технически можем на него сделать ссылку, но я так понимаю особо таким сейчас не делают, не занимаются, но это point для улучшения в будущем, то есть что-то делать с сурсами, которые генерятся в момент сборки, и сурсы в этом смысле тогда имбедятся внутри pdb-шек прямо, и на них нету никакой внешней ссылки, надо думать еще, команда пока думает, что с этим делать.
6282.60 6304.96 "Игорь Лабутин" Ну как только у нас найдены такие dll-ки, pdb-шки, все это вместе можно сложить, так сказать, в единую конструкцию, и в итоге генерить один большой json-файлик, который коммитится уже в репозитории, где лежат доки сайта, а там уже при сборке сайта у вас получится нормально собрать со всеми линками.
6304.96 6326.36 "Игорь Лабутин" Есть проблемы с этим подходом, например, есть типы, для которых не генерится ничего в pdb, например, таким типом являются enums, потому что, ну вот, enums не нужны в pdb-шке почему-то.
6326.36 6329.88 "Игорь Лабутин" Не изучал почему, но почему-то нет, и интерфейсов, кстати, там тоже нет.
6329.88 6374.48 "Игорь Лабутин" Вот для того, чтобы обойти эту проблему, и таки иметь возможность в pdb сложить какой-то референс на то, где эти enums определены, добавили специальный тип, который добавляется в табличку custom debug information в pdb-шке, чтобы потом иметь возможность на момент генерации метаданных таки добыть, где эти enums располагались в исходном коде, и добыть ссылки на них, но дальше есть проблема, что в некоторых dll-ках, они не уточняют в каких, в момент сборки эта инфа все равно триммится, и поэтому даже если, несмотря на то, что ее добавили в момент сборки и в pdb-шке, все равно она оттуда удаляется.
6374.48 6376.12 "Игорь Лабутин" Короче, пока не решенная проблема.
6376.12 6404.46 "Игорь Лабутин" И второй момент, если у вас есть класс, и в нем есть ряд мемберов, у которого нет тела, ну например, абстрактный метод, класс базовый, то в этом случае у него не будет той самой sequencePointInformation, то есть строчек, потому что кода-то у метода нету никакого в pdb-шке, у него нету соответствующего кусочка или кода, это только запись метаданных.
6404.46 6485.56 "Игорь Лабутин" И в таких случаях как бы некуда ставить ссылку для абстрактных методов, таким образом ссылка из документации ведет просто на файл целиком, мы не знаем, в каком месте файла находится ваш метод, но на файл мы вам укажем, а дальше уж ищите по имени, грубо говоря, ctrl-f-ом прямо на страничке гитхабе, вот, ну, в общем, вот, и есть еще фичаны, которые они думают, что может быть это все-таки замодифицировать, сейчас это все делается по сути такими полукостылями вокруг использования существующих технологий вида source-link и pdb-шек, а возможно все-таки они как-то замодифицируют рослин, так чтобы рослин просто имитил дополнительный маппинг в момент сборки, типа в момент сборки всех типов он будет знать и про enum и про абстрактные методы и про все остальное и сможет корректно выдать все номера строчек со всеми нужными файликами и уже этот json-чик файл, например, положить в репу с доками, в общем, будем посмотреть, но сама по себе фича, конечно, крутая, я тут попользовался и это прям очень удобно, просто экономит время, реально, не то чтобы сильно часто приходится это делать, в смысле относительно общего чтения документации, но
6485.56 6496.24 "Анатолий Кулаков" в целом бывает полезно. И действительно кажется, что у них же есть в руках сам рослин, у которого вся эта информация есть, ну вот бери, сделай по-человечески, ну нет, смотри, как так, за костыльками пошли, за
6496.24 6500.96 "Игорь Лабутин" костыльками. Ну, видимо, их хотели выкатить пораньше, молодцы, выкатили, но теперь спокойненько можно сделать
6500.96 6508.18 "Анатолий Кулаков" нормальный через рослин. Да, или как пруф сделали, в принципе, они доказали, что это мегафич, всем нужна, все хотят, в общем, теперь можно, может, и по-человечески
6508.18 6519.44 "Игорь Лабутин" сделать. Да. Ну чё, мы уже опять приближаемся к 2 часам, давай завершать с остальными статьями, у нас есть ещё кратенько о разном, тут тоже немало, давай по ним
6519.44 6553.84 "Анатолий Кулаков" пробежимся. Так, давай по-быстренькому тогда. Я хотел рассказать, что вышел Microsoft Visual Studio Code Extension для .NET MAUI, т.е. теперь, он был в превью, да, теперь вышел в General Availability. Что это такое? Это специальный extension, как не стоит догадаться, Visual Studio Code, который помогает вам делать вот эти прекрасные ксамолинейные интерфейсики. Он основан на C# девкете, это значит, что вы получаете всё, что нужно нормальному C#, Solution, C# IntelliSense, и там тесты, и прочее, прочее.
6553.84 6747.86 "Анатолий Кулаков" Что делает этот extension? Он добавляет к этому прекрасному списку ещё ксамолинтеллисенс и ксамолхотрилод, т.е. прям с первого в лоббилите ксамолхотрилод сдают, это прекрасно. Так, ещё вышла серия статейчек в блоге SICA, который позволяет вам заменить, не то чтобы заменить, немножко делать конкуренцию expired, в общем, они хайпанули на этой теме, мы как раз обсуждали в предыдущих выпусках. Статья так и называется «Persistent log для вашего expired дашборда», т.е. expired дашборд прекрасен всем, он проводит логи, трейсы, метрики, он вообще красавец и всё такое, но его большой минус заключается в том, что эти данные не персистентятся, т.е. как только вы перезагрузили своё приложение, всё, все ваши логи, все ваши метрики потерялись, обычно это всё-таки не очень удобно. И вот авторы подсуетились и говорят, а у нас есть SIC, SIC умеет не только, не просто сохранять все ваши данные, а ещё навешивать всякие retention policy красивые, которые помогают эти данные вовремя чистить. У него есть ещё и свои фишки, аналитические query, дашборды, алерты, очень удобный поиск по логам и так далее, ну т.е. он реально круто. Поэтому они немножко вот на этом хайпе решили вписаться. Что же они сделали? Во-первых, они научились вписать в SIC всё то, что выдаёт Aspire Dashboard, ну т.е. специальный метод расширения, который перехватывает весь Open Telemetry поток, который есть и отсылает его в SIC. Для этого достаточно там addExporterToSIC метод вызвать и всё, и всё хорошо. Второй этап они сделали Aspire Component, который называется Aspire.SIC, вы теперь можете добавить этот пакет к себе в Solution и сделать BuilderAddSIC и после этого вместе со всем Aspire, вместе со всем его дашбордом он будет в докер-контейнере подымать рядом SIC и писать в него то же самое, что и в Aspire Dashboard. После того, как вы Aspire Dashboard закрыли, всё в SIC у вас по-прежнему будет персиститься, храниться, визуализироваться и так далее. В общем, тоже прекрасная вещь. Пока единственный минус в том, что SIC поддерживает логи и дистрибьюдит рейтинги, но, к сожалению, не поддерживает метрики. В общем, с этим пока придётся пожить. Я думаю, что ребята вот на этом хайпе должны и метрики тоже добавить, почему бы и нет. И также Microsoft на Build-е 24-м анонсировал официальную поддержку OpenAI библиотеки для .NET. Там из интересного, она поддерживает абсолютно весь спектр AI, всю платформу, это GPT4, то есть 4.0, это стриминг-компоненты, это экстеншабилити специальные, также там есть API для доступа к DALI, то есть можно генерить имиджи, есть API для распознавания аудиопотоков с помощью виспера, есть API для ассистанса, в общем, действительно кажется, что абсолютно всё засунули, что там есть. Но этот пакет всё ещё находится в бете, сейчас уже на данный момент доступна бета 4, но я думаю, скоро зарелизят после такого громкого анонса. Нужно понимать, что есть альтернативы, есть биталга OpenAPI и есть OpenAI.NET. В общем, две библиотеки, которые уже давно развиваются, в хорошем состоянии, поэтому может быть, они имеют чуть больше функциональности и стабильности, чем официальный пакет, но я думаю, что в любом случае официальный пакет их скоро догонит.
6747.86 7046.56 "Игорь Лабутин" Угу, здорово. У меня тоже некоторое количество тулов или библиотек, которые пробежали мимо меня. Это Serilog 4.0 релиз, я не помню, обсуждали мы его или нет, но что-то у меня как-то он в линках лежал отдельно, так что добавим сюда, если вы пользуетесь Serilog, обновитесь, серилог 4.0 релиз был в ноябре 23-го, полгода назад, больше даже, так что, наверно, там прям мейджор вершен апдейт, это прям важно и здорово, хотя всего две больших фичи заявлены, это батчинг-саппорт для синков, то есть если у вас есть синки, которые требуют батчинга, то теперь это прям билтинг-саппорт, и экспериментал фича под названием Dotted Name Capturing, то есть если вы внутри ваших строк логирования указываете не просто название ваших параметров, а можно теперь название указывать через точку, и они также через точечку будут captured в серилоговские сообщения, других каких-то прям нововведений, не знаю, почему вдруг 4.0, может там, кстати, дропнули какие-нибудь старые самые фреймворки, таргеты, надо посмотреть, не смотрел, а может просто давно релиза не было, поэтому пусть будет 4.0, красиво, а вторая тулуза, не тулуза, а библиотека, это tmds.ssh, это .net ssh client library, то есть клиентская библиотека, которая позволяет вам работать на современном дотнете с ssh, подключаться, там файлики, копировать директорию, создавать что угодно, плюс имеет поддержку sftp, то есть там есть встроенный sftp клиент, если вам вдруг надо работать с sftp, посмотрите, и плюс она автоматически подтягивает все ваши open ssh конфиги, всякие приватные ключики, ноун хосты, короче, все как надо, по отзывам из того, что я видел, народ пишет типа, вау, где вы были много лет назад, короче, давно ждали вот это все, в общем, если работаете, нужно вдруг зачем-то работать с ssh из дотнета, кажется, что это очень хороший кандидат на то, чтобы проверить, как оно, и последняя новость — это тул под названием dnvm, это, наверное, штука, которая, ну, давайте так, это аналог популярных тулзов из всяких других языковых миров, то есть если мы говорим про java, там есть sdkman, который позволяет вам ставить всякие разные sdk-шки от разных версий java, если мы говорим про python, там есть какой-нибудь там pyenv или кто-нибудь такой в таком духе, если мы говорим про .net, то у нас как-то, ну, у нас есть .net, да, наш command-line-tool, у которого есть волшебная команда --list, defuse-sdks, которая покажет вам все sdk, которые установлены, но по сути у вас нет возможности взять и поставить там, хочу поставить 6-ое sdk, 8-ое sdk, либо это делать от средств операционной системы, ну, или пакетного менеджера, у которого стоит чоколад или там брю, если вы на маке, либо еще что-то в таком духе, либо руками скачаете с сайта, а вот этот tool -- это попытка сделать такой tooling, но для .net, то есть ему можно сказать там install 8-ое, install 6-ое, он сам все поставит как надо, везде там что-то куда-то пропишет, пока все это на очень защаточной стадии, но в принципе идея интересная, если вам по какой-то причине требуется жонглировать sdk, там вы, не знаю, превью часто ставите, потом удаляете, потом снова ставите, может, это нормальный вариант, попробовать действительно как-то попроще работать с кучей sdk в .net Полезненько, полезненько Ну да, я вот думал, я не пробовал, я сейчас на маке сберу, в принципе оно плюс-минус работает, но у меня нет необходимости часто менять sdk, поставил там 8-ку сейчас, ну как бы и живем на ней, все, вот у меня есть 6-ка и 8-ка сейчас стоят, больше вроде особо и не надо, поэтому, наверное, это все-таки больше для энтузиастов, которые туда-сюда все это гоняют на всякие превью, пробуют Такие дела, на этом, наверное, все, кажется, что у нас, ну не то, что у нас закончились статьи, у нас закончились запланированные на сегодня статьи, и так уже 2 часа почти сидим, поэтому dotnet 9 превью 5 успели посмотреть, visual studio превью 2 посмотрели, узнали, как нам правильно собирать консистентно билды, чтобы были все последние патчи, но при этом вы не затянули случайно лишние новые фичи, посмотрели на мнение ndbok на предмет primary конструкторов, подумали вместе с Марком Симоном о том, надо ли использовать natural keys для ваших сущностей в базе данных, узнали, как теперь в опишенных документациях генерируются ссылки прямо на исходники dotnet, ну и кратенько посмотрели про разные библиотечки, тулзы, которые стали нам доступны или про которых мы просто почему-то не знали или они обновились.
7046.56 7048.36 "Игорь Лабутин" На этом всё.
7048.36 7058.68 "Анатолий Кулаков" Да, всем счастливо, до новых встреч, шарик, колокольчики, бустики, в общем всё вы знаете, всем комментариев побольше пишите, так, всё, всем пока.
7058.68 7059.24 "Игорь Лабутин" Всем пока.
7059.24 7071.24 "Игорь Лабутин" [музыка]
