6.92 11.30 SPEAKER_01 Здравствуйте, дорогие друзья! В эфире Радио Дотнет, выпуск номер 110.
11.30 13.96 SPEAKER_01 И в эфире ее постоянный ведущий - Анатолий Кулаков.
13.96 16.32 SPEAKER_01 И Игорь Лабутин. Всем привет!
16.32 19.12 SPEAKER_01 А также вместе с нами наши прекрасные помогаторы.
19.12 21.92 SPEAKER_01 Друзья, только слушайте эти замечательные имена.
21.92 41.74 SPEAKER_01 Александр, Сергей, Владислав, Гурий Самарин, Александр Лапердин, Виктор, Руслан Артамонов, Сергей Бензенко, Шевченко Антон, Ольга Бондаренко, Сергей Краснов, Константин Ушаков, Постарнаков Андрей, Дмитрий Сорокин, Дмитрий Павлов, Александр Ерыгин, Егор Сычев, Гольдебаев Александр, Лазарев Илья и Тимофей.
41.74 44.32 SPEAKER_01 Большое спасибо, друзья, что нас поддерживаете.
44.32 46.84 SPEAKER_01 Кто не поддерживает - заходите, еще поддерживайте.
46.84 49.24 SPEAKER_01 Мы рады всем на нашем Бусти-канале.
49.24 56.92 SPEAKER_01 Кстати, у нас на Бусти есть много интересного контента, кроме вот этих выпусков, которые у нас называются "За кулисье".
56.92 60.66 SPEAKER_01 То есть это те разговоры, которые у нас идут перед или после подкастов.
60.66 64.98 SPEAKER_01 Там тоже иногда бывает что-нибудь интересное, но в основном бесполезное.
64.98 69.66 SPEAKER_01 Но есть также еще и полезные, потому что у нас есть такой формат, как "Разговорный клуб".
69.66 71.88 SPEAKER_01 И там мы поговорили уже про много всего интересного.
71.88 78.56 SPEAKER_01 Например, про криптовалюту от известного криптотрейдера, который рассказал, что это, зачем это, как это работает.
78.56 89.18 SPEAKER_01 Потом, оказывается, наши люди еще сидят в бюро кредитных историй, и изнутри просто нам рассказали, как вообще работают кредиты, кто такой кредитный рейтинг, как его выстраивать, где его посмотреть.
89.18 96.06 SPEAKER_01 И все, что связано с вашей кредитной историей, если вас когда-нибудь интересовало, тоже можно посмотреть, послушать.
96.06 108.36 SPEAKER_01 Также у нас был спикер из крупного банка, который рассказал, каким образом они в банк внедряли микросервисы и как они пришли к модульным монолитам.
108.36 117.30 SPEAKER_01 И еще мы разговаривали про эксепшены, как правильно обрабатывать эксепшены, когда нужно оборачивать резулты, когда не нужно оборачивать.
117.30 121.44 SPEAKER_01 Ну и наши новогодние посиделки тоже как раз выходили на нашем Boosty-канале.
121.44 137.56 SPEAKER_01 В общем, там много всего интересного, если вы захотите все это почему-то послушать, заходите, это совсем не сложно, совсем не дорого, и чисто копеечки для того, чтобы научить людей платить за интересный контент, если, конечно, для вас это интересно.
137.56 143.24 SPEAKER_01 Ну и давай, наконец-таки, порадуемся, что нас порадовал.
143.24 145.24 SPEAKER_01 Microsoft.
145.24 155.30 SPEAKER_01 Да, наконец-то Microsoft ожил, и мы можем что-то рассказать уже непосредственно про новый .NET, .NET 10, который когда-нибудь с нами будет, и уже что-то, что-то нам анонсировали.
155.30 172.44 SPEAKER_01 Ну, почему когда-нибудь он будет, прямо сейчас, потому что вышел .NET 10 Preview 1, и в нем, судя по статье, довольно много всяких разных изменений, они вроде небольшие, но на самом деле объем статьи про What's New довольно приличный.
172.44 175.92 SPEAKER_01 Поэтому давайте пройдемся, аккуратненько, все подряд.
175.92 184.38 SPEAKER_01 Начнем традиционно с библиотек, хотя не традиционно, по-моему, начинали с рантайма, но здесь библиотек, они начинают, поэтому пройдемся и мы.
184.38 196.64 SPEAKER_01 Надо сказать, что пока каких-то прям суперсущественных и, ну, таких стратегических, что ли, изменений нет, поэтому все изменения, практически, которые будут озвучены, они такие рандомные.
196.64 201.68 SPEAKER_01 То здесь, то там, тут добавили метод, там убрали, там что-то пофиксили, здесь что-то сломали.
201.68 208.40 SPEAKER_01 Поэтому пока тут не прослеживается какой-то единой стратегии того, во что превратится .NET 10.
208.40 211.46 SPEAKER_01 Так что поглядим, может быть, что-то вырисовывается дальше.
211.46 223.52 SPEAKER_01 Ну а пока в библиотечках улучшилась работа с сертификатами, теперь можно искать не только по сампринтам SHA-1, но и для SHA-256.
223.52 234.48 SPEAKER_01 Но с SHA-256 была засада, что там есть два варианта SHA-256, второй, третий, и у них одинаковая длина строки вот этого там принта, и поэтому нельзя было их отличить.
234.48 240.80 SPEAKER_01 Чтобы все было совсем хорошо, там добавили правильный юнумчик, теперь можно явно передать тип, ну, в общем, все стало по красоте.
240.80 246.28 SPEAKER_01 И вообще весь этот, ну не весь релиз, но очень много в этом релизе, они про...
246.28 250.00 SPEAKER_01 Ой, тут не хватало методов, давайте добавим override.
250.00 260.12 SPEAKER_01 Есть такой класс, я впервые, честно говоря, увидел класс, называется IsoWeek, это про работу с датами, там есть методы типа getWeekOfTheYear и так далее.
260.12 271.00 SPEAKER_01 И вот туда, когда добавили тип dateOnly, почему-то не добавили когда-то соответствующие override, но теперь добавили, раньше работал только с dateTime.
271.00 279.52 SPEAKER_01 В строках добавили еще немножко поддержки спанов там, где их не было.
279.52 307.32 SPEAKER_01 Конкретно в StringNormalization API, нормализация — это юникодная операция, когда вы набор, как это правильно называется, это же не символы юникодных кодпоинтов, насколько я помню, это называется, один и тот же, грубо говоря, итоговый какой-нибудь там эмоджи или что-нибудь, можно выразить на самом деле разными комбинациями кодпоинтов, и вот нормализация приводит их к некоторому единому виду, и вот там теперь можно со спанами работать, если хочется.
307.32 316.88 SPEAKER_01 Полезная фича, которую, мне кажется, многие, наверное, если не ждали, то могут найти это ей применение — это numerical sorting, numerical ordering.
316.88 331.48 SPEAKER_01 То есть теперь в CompileOptions в строках есть специальный enum, numerical ordering, и если с помощью него отсортировать строчку, то у вас все там как положено, отсортируется 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, а не как раньше 1, 10, 2, 3, 4, 5, 6, 7, 8, 9.
331.48 353.88 SPEAKER_01 Вот это, кстати, мне очень не хватало, как бы удивительно, почему так долго не было, потому что часто пригождается, допустим, файловая система, человеческая нормальная хорошая файловая система именно в вашем проводнике или в файловом менеджере должна сортировать файлы по умолчанию именно так, с учетом numerical ordering, и в других, кроме файловых систем, каких-то утилитах это тоже часто пригождалось бы.
353.88 372.44 SPEAKER_01 Да, оно работает, оно работает не во всех методах, то есть, например, там есть всякие разные методы типа starts, ends, with, куда можно передать, было там, культуру или всякие CompileOptions, ну потому что туда как раз передаются всякие видимо case insensitive и прочее, но вот numerical там не поддерживается, но он там особо и не нужен в этом случае.
372.44 381.24 SPEAKER_01 Дальше, в TimeSpan, в метод from milliseconds добавили override, который принимает строго один параметр, потому что иначе там в link_u было не очень удобно использовать.
381.24 400.44 SPEAKER_01 ZipArchivePerformance, о, это вообще шикарная история, ZipArchivePerformance улучшили за счет того, что при определенных операциях, когда вы апдейтируете архив, перестали закачивать весь, как я понял, чуть ли не весь контент архива в память, прежде чем записать его обратно.
400.44 425.52 SPEAKER_01 И там такой шикарный бенчмарк, в котором по CPU мы получили прирост производительности 99.8%, а по памяти мы получили прирост производительности 99.9996% То есть там, короче, один бенчмарк в дотнет, там табличка что-то типа там 4 секунды, 4 миллисекунды до-после.
425.52 430.20 SPEAKER_01 — Надо начальству эти бенчмарки показывать, когда будем аргументировать, почему мы на дотнете.
430.20 445.60 SPEAKER_01 — Да-да-да, там еще какую-то параллелизацию завезли при распаковке, в итоге там, в общем, процентов на 10-15 в каких-то разумных сценариях, местами 20, скорость и по памяти, и по CPU по времени увеличивается, поэтому, в общем, хорошо.
445.60 456.28 SPEAKER_01 Дальше, в Ordered Dictionary, если вы вдруг его зачем-то используете, добавили новые перегрузки для try_add, которые сразу индекс добавляют, в смысле, возвращают.
456.28 462.24 SPEAKER_01 Ordered Dictionary — это такой словарик, в котором сохраняется порядок, и к которому можно обращаться, в том числе, по индексу.
462.24 469.20 SPEAKER_01 Вот теперь эти операции try_add и try_get в том числе могут возвращать индекс.
469.20 471.12 SPEAKER_01 И это все в библиотеках.
471.12 476.64 SPEAKER_01 Дальше есть Runtime. В Runtime интересные вещи. Runtime явно работает над перформансом.
476.64 487.56 SPEAKER_01 И там заявлены три фичи. Ну, про VX 10.2 support много говорить не буду, это очередная поддержка каких-то очередных расширений для специнструкций процессора.
487.56 491.16 SPEAKER_01 Ничего не буду про это говорить, просто JIT стал более умным.
491.16 493.88 SPEAKER_01 Но JIT стал более умным еще в двух местах.
493.88 498.76 SPEAKER_01 Во-первых, то, что называется Array Interface Method Devirtualization.
498.76 501.12 SPEAKER_01 Речь идет о следующем.
501.12 508.56 SPEAKER_01 Когда у нас есть обычный цикл, просто массив, какой-нибудь вы там передали в функцию массив, и по нему проитерировались.
508.56 518.16 SPEAKER_01 Ну, все, наверное, знают это, по-моему, что-то не на собесах иногда спрашивают, что в этом случае bound_check, конечно же, будет один раз в начале цикла, и внутри цикла никаких проблем не будет.
518.16 526.52 SPEAKER_01 Если мы там индексом бегаем, потому что JIT видит, что примерно цикл никак не меняется внутри тела цикла, и все хорошо.
526.52 579.08 SPEAKER_01 Но стоит вам этот самый массив присвоить в переменную, прямо в этой же методе объявленную, типа INUMERABLE, и потом по этой переменной сделать точно такой же FOREACH или FOR или FOREACH, ну, FOREACH на самом деле, потому что FOR с INUMERABLE вы уже не получите, там по индексу не обратиться, то JIT, естественно, поскольку это INUMERABLE, он позовет на нем где-то нумератор, но поскольку это интерфейс, переменная типа интерфейс, то там будет BOM, виртуальный вызов, боксинг, ну, короче, все как положено было, и теперь JIT научился понимать, что в INUMERABLE на самом деле присвоили массив, и внутри там лежит массив, и поэтому не нужно делать все эти виртуальные вызовы, можно просто дернуть методы массива, как для массива, в общем, будет быстрее.
579.08 591.12 SPEAKER_01 Ага, и еще важная штука, то, про которую я несколько раз уже рассказывал вкратце, сейчас тоже вкратце скажу, это очередной кусочек стэка локейшена.
591.12 606.56 SPEAKER_01 В девятом .NET из релиза кусочек, который позволяет частично, я так понимаю, value-тайпы только, специальные, которые не содержат ничего референсного внутри, а локейт прямо на стэке при необходимости.
606.56 613.00 SPEAKER_01 Ну, то есть, типа, не надо боксить int, если известно, что этот int не выйдет за пределы функции.
613.00 633.36 SPEAKER_01 Так вот, в превью 1 добавили фичу, что массивы фиксированного размера и не очень большие, я не нашел так сходу, что значит small, ну, вероятно, там не больше, не знаю, 10-16 элементов, наверное, какая-нибудь константа где-то в коде есть, GTA причем, а такие массивы тоже будут локейтиться на стэке.
633.36 639.80 SPEAKER_01 Важный момент, что это должны быть массивы value-тайпов, в этих value-тайпах не должно быть gc и никаких ссылок.
639.80 660.04 SPEAKER_01 То есть, это уже пока довольно ограниченная штука, но, с другой стороны, то есть массив примитивных чиселок, там, int, double в чем-нибудь таком духе, он маленький массив, константного размера, залокейтится на стэке в превью 1, но с этой фичей все-таки связана какая-то тонкость, потому что в превью 2 ее пока отключат.
660.04 670.40 SPEAKER_01 Уже я видел pull request замерзший, который отключает эту фичу для превью 2, потому что что-то там нашли, но они это пофиксят и, наверное, снова потом включат.
670.40 680.60 SPEAKER_01 В общем, двигаются в направлении побольше разложить все на стэк там, где можно, доказать, что данные не уйдут за пределы функции.
680.60 682.60 SPEAKER_01 И это пока все, что касается рантайма.
682.60 684.60 SPEAKER_01 Дальше у нас есть SDK.
684.60 690.52 SPEAKER_01 SDK, там добавилась, по сути, одна единственная фича, и она такая интересная.
690.52 695.00 SPEAKER_01 Значит, мы рассказывали, что в девятом дотнете добавилась команда nuget audit.
695.00 704.28 SPEAKER_01 Она позволяет посмотреть, на что вы ссылаетесь, на какие пэкэджи, и какую-то информацию по ним рассказать, не знаю, про уязвимости, еще про что-нибудь.
704.28 713.60 SPEAKER_01 Так вот, у нее теперь появилась новая опция, которая включена по дефолту для всех дотнетных target-фреймворков и даже для dotnet standard 2.0.
713.60 715.60 SPEAKER_01 Она заключается в следующем.
715.60 722.12 SPEAKER_01 У нас на самом деле из csproj есть почти всегда сначала ссылка на фреймворк.
722.12 726.28 SPEAKER_01 То есть мы делаем framework reference и ссылаемся на фреймворк.
726.28 736.64 SPEAKER_01 И в фреймворк к нам на самом деле прилетает некоторое количество, ну, собственно, стандартной библиотеки, все дела, и заодно некоторое количество этой самой стандартной библиотеки, оформленной в виде nuget пакетов, возможно.
736.64 752.36 SPEAKER_01 Так вот, если вы в csproj пэкэдж-референсом зареференсите какой-нибудь пакет, который на самом деле и так вам притаскивается target-фреймворком, то, ну, по сути, вы заставляете компилятор-nuget делать двойную работу, когда ресторите.
752.36 756.92 SPEAKER_01 Потому что, с одной стороны, ссылка будет из target-фреймворка, с другой стороны, вы ее явно продублировали в пэкэдж-референсе.
756.92 768.48 SPEAKER_01 Вот теперь есть режим, который будет включен по умолчанию, который такие пэкэдж-референсы будет, ну, как минимум подсвечивать вордингами, а как максимум он, я так понял, чуть ли не сам готов удалять из csproj.
768.48 777.32 SPEAKER_01 Вероятно, только если, понятно, там нет каких-то дополнительных флажков вокруг, не знаю, там условий, еще чего-нибудь, чтобы, значит, облегчить работу.
777.32 780.80 SPEAKER_01 Если вам не нравится, есть опция, которая позволяет это выключить.
780.80 793.80 SPEAKER_01 Так что называется package-pruning, и пока я про нее особо ничего более детально не читал, потом почитаем, если что расскажем, если там будет что-то существенно интересное.
793.80 800.88 SPEAKER_01 C#. В C# тоже появилось некоторое количество пока все-таки мелочей.
800.88 807.16 SPEAKER_01 Ну, во-первых, они снова сказали, что вот это field-keyword на месте.
807.16 809.80 SPEAKER_01 Ну, вроде как уже без флага experimental.
809.80 814.64 SPEAKER_01 Так что есть надежда, что в десятом все-таки все зарелизится, как положено.
814.64 818.16 SPEAKER_01 В nameof теперь можно передавать дженерики без типа.
818.16 826.52 SPEAKER_01 То есть раньше вы, когда вы хотели, например, вызвать nameof от какого-то дженерик-типа, вам нужно было сделать лист от чего.
826.52 829.56 SPEAKER_01 Например, лист от t, вам нужно было сделать лист от чего-то.
829.56 832.88 SPEAKER_01 Теперь можно написать nameof, лист и пустые угловые скобочки.
832.88 837.48 SPEAKER_01 Он вам выдаст имя. Просто лист в данном случае.
837.48 843.60 SPEAKER_01 Дальше интересная фича, она как бы языковая, как бы частично компиляторная.
843.60 845.24 SPEAKER_01 Называется implicit span conversions.
845.24 854.68 SPEAKER_01 То есть теперь, если вы берете, например, массив, вы можете его передать в функцию, которая принимает span или read-only span.
854.68 859.56 SPEAKER_01 И он замечательно сконвертится, причем даже с учетом всякой ковариантности.
859.56 864.20 SPEAKER_01 И также вы строчки можете тоже передавать в read-only span.
864.20 869.04 SPEAKER_01 В смысле, в функции, которые принимают read-only span, тоже все будет конвертиться автоматически.
869.04 872.24 SPEAKER_01 Не нужно там вызывать string span. Вот это все.
872.24 875.88 SPEAKER_01 Оно теперь будет к компиляторам автоматом подставляться.
875.88 879.92 SPEAKER_01 Так, field, ключевое слово я сказал.
879.92 886.88 SPEAKER_01 На лямбда-параметрах можно теперь просто указывать модификаторы, всякие там ref, in и прочее, не указывая тип.
886.88 888.88 SPEAKER_01 Раньше требовалось обязательно указать тип.
888.88 894.32 SPEAKER_01 И экспериментальная фича, я не очень понимаю, почему это фича языка на самом деле.
894.32 901.88 SPEAKER_01 Это больше выглядит как фича компилятора, но это продвигается под разделом C#, поэтому считаем, что это хоть как-то относится к языку.
901.88 909.00 SPEAKER_01 А именно запихивание литеральных строк в дата-секцию PE-файла, если он это о чем-то говорит.
909.00 921.56 SPEAKER_01 То есть не в виде каких-то ресурсов, менедж-ресурсов, а в виде прям бинарного блоба, грубо говоря, в PE-секции исполнимого файла и в виде UTF-8 строк.
921.56 925.92 SPEAKER_01 Довольно сильно похоже на то, как UTF-8 литералы сейчас сохраняются.
925.92 929.36 SPEAKER_01 Вот, включается фича флагом пока.
929.36 936.24 SPEAKER_01 Посмотрим. Видимо, раз она экспериментальная, не очень понятно, нужна ли она, кому нужна в каких случаях.
936.24 938.24 SPEAKER_01 Будем смотреть.
938.24 941.80 SPEAKER_01 Вышли какие-то небольшие изменения по F#.
941.80 949.60 SPEAKER_01 Я, честно говоря, сильно не вчитывался, там какие-то совсем небольшие мелочи, очень специфичные для F#, я боюсь, что особо не расскажем.
949.60 953.88 SPEAKER_01 Но что интересно, вышло обновление Visual Basic, вот уж чего-чего я не ожидал в 2010-м.
953.88 957.08 SPEAKER_01 В интернете увидят какое-то Visual Basic обновление.
957.08 965.60 SPEAKER_01 Но обновили, добавили поддержку Unmanaged Constraint Support, видимо, там что-то где-то не могло работать, и поэтому пришлось добавлять.
965.60 989.24 SPEAKER_01 И помните, что в 9.NET выявился новый атрибут про Resolution Priority, когда вы можете на метод навесить атрибут, и то, в каком порядке компилятор будет выбирать методы для резолва, он в том числе определяется этим атрибутом, вот в Visual Basic компилятор теперь тоже на него будет смотреть.
989.24 992.24 SPEAKER_01 Дальше перейдем к ISP.NET.
992.24 997.24 SPEAKER_01 С ISP.NET тоже потихонечку все делается по чуть-чуть.
997.24 1002.16 SPEAKER_01 Единственное большое достаточно изменение - это поддержка OpenAPI 3.1.
1002.16 1011.64 SPEAKER_01 Казалось бы, раньше поддерживали 3.0, теперь 3.1, но для того, чтобы нормально полноценно поддержать 3.1, там довольно большие изменения, в том числе breaking changes.
1011.64 1029.28 SPEAKER_01 И напомню, что если вы пользуетесь новой поддержкой OpenAPI от Microsoft, вы можете влиять на то, какая OpenAPI-спецификация генерится путем реализации в коде прямо так называемых трансформеров.
1029.28 1044.04 SPEAKER_01 Мы как-то отдельно писали, когда их только-только добавили в выпуск, где рассказывали, что можно написать какой-то специальный код для того, чтобы трансформировать N Point Definition, Document Definition, не помню, еще что-то, Parameter Definition.
1044.04 1054.68 SPEAKER_01 Короче, специальный код, который довесит каких-нибудь новых данных или как-то преобразует значения, или преобразует текст, в общем, что-нибудь сделает, прежде чем это обратится в реальную OpenAPI-спецификацию.
1054.68 1063.72 SPEAKER_01 Ну вот теперь такой код сломается при переходе на десятку, нужно будет его переписать, там изменились названия классов, немножко изменилась иерархия, немножко изменился подход.
1063.72 1066.88 SPEAKER_01 Общая идея стала с той же, но есть изменения.
1066.88 1070.88 SPEAKER_01 Иначе было нормально не сделать OpenAPI 3.1.
1070.88 1084.16 SPEAKER_01 При этом добавилась еще опция возможности генерации в YAML, то есть OpenAPI в support от Microsoft предполагал, что генерируется только JSON, теперь есть опция генерировать YAML.
1084.16 1092.32 SPEAKER_01 Также вокруг OpenAPI добавили, немножко расширили атрибуты про Response Description, чтобы можно было указывать человеческое описание.
1092.32 1108.32 SPEAKER_01 Ну и некоторое количество всяких разных мелочевочек, а именно добавили метод, который позволяет определить, является ли URL локальным или нелокальным, или ведет на какой-то внешний сервер относительно текущего приложения.
1108.32 1118.84 SPEAKER_01 Если вы используете top-level-стейтменты, то у вас могли быть проблемы с юнит-тестами, потому что, как известно, в top-level-стейтменте у вас нет класса Program в коде.
1118.84 1121.52 SPEAKER_01 Он есть на самом деле, он генерируется автоматически.
1121.52 1136.36 SPEAKER_01 И если вы хотите, например, из юнит-теста вызвать что-нибудь, какой-нибудь кусочек вашей программы, которая написана в top-level, ну как бы никак, вы не можете вызвать эту функцию, допустим, даже если вы там определили какую-то функцию, потому что она лежит внутри класса Program, а он генерировался как internal.
1136.36 1142.80 SPEAKER_01 Теперь он public, и с ним все, насколько я понял, и с ним все хорошо, его можно вызвать из тестов.
1142.80 1148.44 SPEAKER_01 Там какие-то небольшие изменения вокруг Razor и Blazor.
1148.44 1150.28 SPEAKER_01 Ну, в общем-то, и все.
1150.28 1154.36 SPEAKER_01 По большому счету, в Esperantcore пока больше ничего нет.
1154.36 1156.56 SPEAKER_01 Теперь давайте перейдем к UI.
1156.56 1159.64 SPEAKER_01 А, нет, давайте до UI поговорим про EF.
1159.64 1164.40 SPEAKER_01 Значит, в EF 2 небольших, ну, как небольших.
1164.40 1174.24 SPEAKER_01 Одно, наверное, полезное изменение, в LinkU добавили left-join оператор такой, и, соответственно, EF его поддержал.
1174.24 1183.08 SPEAKER_01 И это позволяет теперь чуть проще писать left-join в запросах, нежели чем раньше, там нужно было через select-many, и там довольно монструозная конструкция получалась.
1183.08 1188.40 SPEAKER_01 А теперь есть просто метод left-join, который EF понимает и генерирует соответствующую скойль.
1188.40 1199.56 SPEAKER_01 Ну, и executeUpdateAsync теперь получает просто обычную нормальную лямбду, ему не обязательно передавать expression, как раньше, а просто обычную лямбду он ее сам преобразует туда, куда надо.
1199.56 1202.40 SPEAKER_01 Вот, собственно, в EF пока больше ничего и нет.
1202.40 1214.16 SPEAKER_01 В UI MAUI, соответственно, ну, наша стандартная мантра, про то, что this release focused on quality improvements, все еще улучшаем качество.
1214.16 1215.88 SPEAKER_01 Ничего новенького.
1215.88 1226.56 SPEAKER_01 Там есть некоторый набор обновлений для Android и для iOS, но они довольно сильно специфические для платформы, лучше, если вы этим занимаетесь, прочитайте детально.
1226.56 1237.72 SPEAKER_01 WinForms все еще пытаются нормально пережить тот факт, что BinaryFormatter тебе не доступен, потому что BinaryFormatter был в том числе задействован при работе с клипбордом.
1237.72 1254.76 SPEAKER_01 Вот, соответственно, заабсолитили часть апишек, добавили новых типизированных апишек, которые используют другую сериализацию для клипборда, и поэтому там есть прям инструкция, что делать в приложениях, если вы используете клипборд так или так.
1254.76 1267.40 SPEAKER_01 Ну, в WPF тоже quality improvements, и напоследок понятно, что под десятку обновились образы контейнеров, ну, докер-контейнеров, Ubuntu 24.04, Debian 13.
1267.40 1269.48 SPEAKER_01 В общем, такие дела.
1269.48 1271.24 SPEAKER_01 На этом, наверное, все.
1271.24 1275.56 SPEAKER_01 В принципе, для первого превью, мне кажется, неплохо.
1275.56 1281.68 SPEAKER_01 Вообще непонятно, куда все это идет, в смысле, какой-то киллер фичи релиза пока не проглядывается.
1281.68 1284.56 SPEAKER_01 Ну, как обычно, перформанс, наверное, да.
1284.56 1286.36 SPEAKER_01 А там посмотрим.
1286.36 1291.40 SPEAKER_01 И никаких там анонсов, а что будет вообще мейнстримовой фишкой этого релиза?
1291.40 1296.88 SPEAKER_01 Смотри, я видел некоторые статьи на тему, ну, на сайте Майкрософта.
1296.88 1298.44 SPEAKER_01 В смысле, на гитхабе, да, опубликованные.
1298.44 1300.44 SPEAKER_01 Я видел, по крайней мере, ссылочку, у меня лежит в закладках.
1300.44 1305.44 SPEAKER_01 Почитаю, что-то типа ASP.NET Core Roadmap, да, 10-го.
1305.44 1307.64 SPEAKER_01 Я не видел такие же для остальных кусочков.
1307.64 1319.68 SPEAKER_01 Точнее, как правило, они всегда есть, но я не очень понимаю, насколько они, ну, скажем так, публично содержат вообще все, что в реальном роадмапе находится.
1319.68 1320.28 SPEAKER_01 Вот.
1320.28 1326.40 SPEAKER_01 То есть, ну, понятно, да, вот пару лет назад Aspire не было ни в каких роадмапах, он появился внезапно.
1326.40 1328.00 SPEAKER_01 Вот, для нас.
1328.00 1335.00 SPEAKER_01 Поэтому я прочитаю роадмапы, но насколько там будет что-то существенно огромное и большое, пока непонятно.
1335.00 1338.20 SPEAKER_01 Угу, ну, хорошо, подождем, подождем, посмотрим.
1338.20 1346.44 SPEAKER_01 Давай, пока мы ждем, посмотрим, а что у нас еще интересного творилось в существующем дотнете, в существующем C#.
1346.44 1354.12 SPEAKER_01 Тема не то, чтобы новая, но я недавно столкнулся с ней на работе, и поэтому хотелось бы упомянуть, потому что я понял, что не все люди ее до сих пор знают.
1354.12 1357.88 SPEAKER_01 На самом деле, мы говорим про статью Стиффена Клэрри.
1357.88 1363.16 SPEAKER_01 Это статья 2020 года, как ни странно, но, опять же, не устаревает.
1363.16 1371.40 SPEAKER_01 Это не какая-то новость, это статья про то, о какой новый шаблон для логирования исключений появился у нас в C#.
1371.40 1376.00 SPEAKER_01 В те далекие времена, но до сих пор почему-то о нем очень многие разработчики не знают.
1376.00 1381.88 SPEAKER_01 Поэтому давайте устранять это недоразумение, давайте учить разработчиков правильно логировать эксепшены.
1381.88 1391.88 SPEAKER_01 И смысл, суть всего этого логирования заключается в том, что не так нужно эксепшены логировать, как мы обычно привыкли в кейдж-блоке, а нужно их логировать в фильтре.
1391.88 1393.84 SPEAKER_01 Давайте поговорим об этом подробнее.
1393.84 1396.88 SPEAKER_01 Начнем прежде всего со структурного логирования.
1396.88 1400.60 SPEAKER_01 Как вы все, наверное, знаете, что структурное логирование - это хорошо.
1400.60 1407.96 SPEAKER_01 Настолько хорошо, что вообще, в принципе, все современные системы логирования поддерживают богатые структурные логи.
1407.96 1416.44 SPEAKER_01 И эти структурные логи отличаются от текстовых логов, которые у нас были раньше тем, что вы можете добавлять туда индивидуальные поля.
1416.44 1418.56 SPEAKER_01 И эти поля будут со специальными значениями.
1418.56 1426.12 SPEAKER_01 И вам потом, в принципе, в любом анализаторе, в любой вашей системе хранения логов очень просто оперировать с конкретными значениями.
1426.12 1437.44 SPEAKER_01 Вы можете фильтровать, вы можете выбирать, вы можете строить какие-то графики непосредственно структурированных логов на логах уже без какого-то специального парсера, который был нужен раньше.
1437.44 1451.84 SPEAKER_01 Я думаю, те, кто сейчас текают в тему .NET, наверное, даже и не знают, что когда-то логи были чисто текстовыми, и каким образом люди мучились, придумывая различные парсеры для того, чтобы хоть как-то их анализировать и хоть что-то с ними полезное сделать.
1451.84 1453.84 SPEAKER_01 В общем, сейчас это стандарт де-факто.
1453.84 1469.64 SPEAKER_01 После того, как появился особенно микрософтовский логер из ISP.NET Core и переехал там Microsoft Extension, в общем, это уже становится структурированные логи, они стали как бы стандартным вместе с .NET Core.
1469.64 1486.36 SPEAKER_01 Вот. И для того, чтобы ваши логи записать, вам необходимо сделать довольно примитивную вещь логера, вызвать метод, который называется LogInformation, допустим, и передать ему несколько компонентов.
1486.36 1488.60 SPEAKER_01 Первый компонент - это MessageTemplate.
1488.60 1498.28 SPEAKER_01 То есть это строка, которая внутри себя в фигурных скобках имеет некое имя передаваемого аргумента.
1498.28 1502.24 SPEAKER_01 И дальше через запятую вы передаете непосредственно значение этого аргумента.
1502.24 1508.08 SPEAKER_01 Допустим, представим, что у нас есть метод, который называется Divide, который принимает два параметра.
1508.08 1511.84 SPEAKER_01 Первое - это значение, которое мы делим, и второе - значение, на которое мы делим.
1511.84 1515.44 SPEAKER_01 И все, что делает метод, это просто-напросто делит первое значение на второе.
1515.44 1518.40 SPEAKER_01 Но при этом результат он сохраняет в логер.
1518.40 1524.24 SPEAKER_01 То есть он вызывает логер LogInformation, пишет там результат и передает переменную результат.
1524.24 1531.12 SPEAKER_01 И в логах у нас радостно появляется ответ, то есть какой ответ получается при каждом вызове метода Divide.
1531.12 1534.04 SPEAKER_01 И, естественно, результат он возвращает обратно, наверх.
1534.04 1537.08 SPEAKER_01 Вот, это типичное применение структурного логирования.
1537.08 1539.52 SPEAKER_01 Теперь копнем немножко вглубже.
1539.52 1544.44 SPEAKER_01 Большинство современных фреймворков для структурного логирования поддерживают так называемые скоупы.
1544.44 1547.28 SPEAKER_01 Скоупы - это довольно мощная и крутая штука.
1547.28 1556.64 SPEAKER_01 С помощью скоупа вы можете присоединить дополнительные данные, кроме того, которые будут непосредственно логироваться, в каждое сообщение, которое идет внутри этого скоупа.
1556.64 1559.28 SPEAKER_01 Внутри - это не обязательно в том же самом методе.
1559.28 1561.12 SPEAKER_01 Это может быть где угодно.
1561.12 1564.84 SPEAKER_01 Главное, чтобы вы скоуп открыли и когда-нибудь его там в конце закрыли.
1564.84 1568.80 SPEAKER_01 Ну, приведем пример. Вернемся к нашему методу, который называется Divide.
1568.80 1575.52 SPEAKER_01 Внутри него, прежде чем начать деление, мы можем открыть скоуп и в этот скоуп передать наши аргументы.
1575.52 1579.76 SPEAKER_01 Первый параметр и второй параметр, то есть что на что мы будем делить.
1579.76 1590.56 SPEAKER_01 Теперь, как бы далеко и глубоко мы не ушли, как сколько бы внутри себя мы методом не вызвали, любое сообщение, которое будет записано в лог, будет содержать вот эти наши параметры.
1590.56 1592.84 SPEAKER_01 Первый и второй аргумент.
1592.84 1607.60 SPEAKER_01 Поэтому, даже когда мы запишем просто Result и передадим переменную с результатом вычисления, с результатом деления, даже в этой переменной в Message Template добавится то, а как мы этот результат получили, то есть из первого и из второго параметра.
1607.60 1610.16 SPEAKER_01 Поэтому это очень удобно.
1610.16 1612.76 SPEAKER_01 Прежде всего, зачем нужны скоупы? Это безумно удобно.
1612.76 1614.92 SPEAKER_01 Например, для отладки ваших приложений.
1614.92 1632.76 SPEAKER_01 То есть, когда вы не можете в вашем приложении разобраться, а почему так случилось, почему ваша программа вычислила то или иное значение, почему она пошла в ту или иную ветку, обычно для ответа на этот вопрос вам нужны входные какие-то аргументы, которые примерно вас наведут на мысль, а почему от этих входных аргументов она пошла в такой-то результат.
1632.76 1644.60 SPEAKER_01 И очень полезно бывает открывать скоуп как раз вначале с этими входными аргументами и внутри уже начинать какую-то бизнес-логику, чтобы она ветляла и писала какие-нибудь дополнительные логи.
1644.60 1653.12 SPEAKER_01 Но при этом, когда она будет писать, к каждому ее решению будут добавляться те входные аргументы, на базе которых было принято то или иное решение.
1653.12 1660.56 SPEAKER_01 Еще одним типичным примером – это, допустим, открывать скоуп реквеста.
1660.56 1679.96 SPEAKER_01 Когда к вам, например, заходит веб-запрос, вы открываете скоуп реквеста, и все логи, которые пишутся непосредственно в рамках этого реквеста, вы сходили к сервису, вы сделали какую-то валидацию, сходили в базу данных и сохранили в репозитории, все эти логи будут содержать в себя, например, реквест-ID, который к вам пришел.
1679.96 1682.52 SPEAKER_01 Или, может быть, URL, по которому к вам пришли.
1682.52 1690.96 SPEAKER_01 Или, может быть, какой-то correlation ID, который потом мапится в activity ID, который вы цепляете к вашему OpenTelemetry протоколу.
1690.96 1698.20 SPEAKER_01 В общем, все вот эти вот скоупы, они очень хорошо помогают вам связать процесс выполнения, который теперь становится не просто...
1698.20 1725.44 SPEAKER_01 То есть ваши логи становятся не просто какими-то непонятными строчками, разбросанными по всему вашему журналу логирования, а они пронизаны неким скоупом, они пронизаны некоторыми одинаковыми значениями, которые помогают вам их не только сгруппировать в какой-то один, например, реквест, но и понять, с какими параметрами этот реквест заходил, а как он связан с другими парент-реквестами, и построить довольно красивые, интересные графики, которые очень облегчают жизнь и хорошо помогают отладке.
1725.44 1730.52 SPEAKER_01 А теперь давайте вернемся к нашим эксепшенам.
1730.52 1734.04 SPEAKER_01 Как обычно люди логируют исключения?
1734.04 1735.20 SPEAKER_01 Ну, очень просто.
1735.20 1741.24 SPEAKER_01 В том методе, то есть в методе divide мы обычно исключения не ловим и не логируем.
1741.24 1747.24 SPEAKER_01 То есть в том методе, где исключение возникает, обычно оно не ловится, потому что никакого смысла его там ловить нет.
1747.24 1750.28 SPEAKER_01 Максимум, что вы можете сделать, это залогировать результат.
1750.28 1753.72 SPEAKER_01 Ну, другой разговор, если у вас есть какая-то fallback стратегия, мы сейчас не обсуждаем.
1753.72 1762.84 SPEAKER_01 Допустим, у вас fallback стратегии нет, то есть ничего хорошего вы в кетче сделать не сможете, никаких дополнительных аргументов, кроме того, что вы уже знаете, у вас нет.
1762.84 1770.08 SPEAKER_01 Поэтому обычно рекомендуют, что если вам нечего добавить в кетч-блоке, то и не надо ловить исключения.
1770.08 1774.40 SPEAKER_01 Кто-то наверху, более умный, у которого более богатый контекст, его поймает и что-то с ним сделает.
1774.40 1777.20 SPEAKER_01 Кто-то будет уже понимать, а что надо с ним делать.
1777.20 1781.68 SPEAKER_01 Ну, вот так же и здесь в нашем методе divide обычно никакого кетча не будет.
1781.68 1789.56 SPEAKER_01 Мы просто-напросто, если у нас случится какое-то исключение, допустим, когда мы начнем делить на 0, оно выбросится наверх.
1789.56 1791.44 SPEAKER_01 И наверху кто-то умный его обработает.
1791.44 1795.80 SPEAKER_01 Давайте представим, что наверху есть некий обработчик, у которого действительно написан try_ketch.
1795.80 1804.32 SPEAKER_01 Мы пытаемся вызвать метод divide с 0 во втором аргументе, разумно получаем, что на 0 делить нельзя, и здесь же у нас есть кетч-блок.
1804.32 1805.72 SPEAKER_01 Что в этом случае мы делаем?
1805.72 1812.44 SPEAKER_01 Мы берем исключение и пишем в наш логер "LogError" и передаем туда исключение в качестве аргумента.
1812.44 1820.36 SPEAKER_01 И, может быть, даже дальше делаем "Refthrow", то есть перевыбрасываем исключение дальше, пусть оно летит, может кто-то еще что-то поймает, что-то сделает.
1820.36 1827.08 SPEAKER_01 Обычный типичный код, именно в кетче exception и логирует.
1827.08 1830.28 SPEAKER_01 И это как раз есть очень большая ошибка.
1830.28 1841.00 SPEAKER_01 Ошибка заключается в том, что как только мы начинаем в кетче логировать, что какое исключение случилось, в этот самый момент мы уже потеряли скоб.
1841.00 1845.96 SPEAKER_01 То есть в этот самый момент мы уже не знаем, а какие числа мы начинали делить друг на друга.
1845.96 1851.08 SPEAKER_01 Мы уже здесь потеряли тот скоб, который сохранял у нас входные аргументы.
1851.08 1853.88 SPEAKER_01 Поэтому данное исключение будет не очень информативное.
1853.88 1859.64 SPEAKER_01 Оно вылетит с названием, что на 0 делить нельзя, а действительно ли мы пытались делить на 0, или это какая-то наведенка.
1859.64 1864.32 SPEAKER_01 Какие числа к нам пришли на вход и все такое, вот это мы, к сожалению, потеряли.
1864.32 1870.32 SPEAKER_01 То есть этот скоб будет на самом деле залогирован только если девайт прошел успешно.
1870.32 1873.72 SPEAKER_01 То есть если только наш метод выполнился успешно.
1873.72 1879.44 SPEAKER_01 И это очень плохо, потому что мы теряем как раз все эти преимущества, которые я расхваливал сверху.
1879.44 1889.32 SPEAKER_01 То есть никакой теперь красивой отладки как раз в тот момент, когда возникло исключение, когда отладка наиболее полезна и наиболее важна, у нас больше не будет.
1889.32 1890.60 SPEAKER_01 И это плохо.
1890.60 1893.32 SPEAKER_01 Давайте разбираться, как мы будем с этим побороться.
1893.32 1897.92 SPEAKER_01 Для того чтобы с этим разобраться, нам сначала нужно вспомнить, как работает исключение.
1897.92 1901.32 SPEAKER_01 На самом деле, вот так, в верхнем уровне довольно просто.
1901.32 1911.72 SPEAKER_01 Когда исключение происходит в нашем вложенном методе, runtime начинает искать по всему стектрейсу некий хендлер, который подходит ему и который может обработать это исключение.
1911.72 1918.04 SPEAKER_01 Он, по сути, перебирает все кетчблоки и ищет кетчблок с правильным эксепшеном.
1918.04 1922.04 SPEAKER_01 То есть тот, который подходит ему под условия выкинутого в runtime эксепшена.
1922.04 1930.52 SPEAKER_01 То есть он запускает некий type matching, то есть некое сопоставление того, подходит этот кетчблок для обработки или не подходит.
1930.52 1941.04 SPEAKER_01 И если вдруг он находит кетчблок, который подходит, в этот момент он разматывает стэк и устанавливает точку следующего выполнения программы на этот кетчблок.
1941.04 1943.04 SPEAKER_01 И перекидывает, соответственно, управление на кетчблок.
1943.04 1947.04 SPEAKER_01 Здесь очень важно заметить, что у нас есть два отдельных шага.
1947.04 1951.04 SPEAKER_01 Первый шаг - это мы ищем подходящий обработчик, то есть подходящий кетчблок.
1951.04 1955.04 SPEAKER_01 И второй шаг - это мы разматываем стэк и вызываем этот кетчблок.
1955.04 1963.04 SPEAKER_01 Теперь, зная о том, как работает вообще поиск нужного хендлера, на сцену выходят эксепшн-фильтры.
1963.04 1966.04 SPEAKER_01 На самом деле, эксепшн-фильтры появились довольно давно.
1966.04 1968.04 SPEAKER_01 Еще в дотнете первом.
1968.04 1971.04 SPEAKER_01 То есть с 2002 года эксепшн-фильтры поддерживаются.
1971.04 1973.04 SPEAKER_01 Но почему-то мы их не знали.
1973.04 1978.04 SPEAKER_01 А не знали мы их не потому, что в C# они появились только с шестой версии.
1978.04 1980.04 SPEAKER_01 То есть в 2015 году.
1980.04 1983.04 SPEAKER_01 Поэтому в C# они пришли довольно недавно.
1983.04 1992.04 SPEAKER_01 И смысл этих эксепшн-фильтров заключается в том, что они помогают вам перехватить вот эту часть, которая заключается в первом шаге.
1992.04 1996.04 SPEAKER_01 То есть часть, которая выполняется в момент поиска нужного хендлера.
1996.04 1999.04 SPEAKER_01 Она выполняется еще до того, как размотался стэк.
1999.04 2003.04 SPEAKER_01 То есть еще до того, как вызвался эксепшн-хендлер.
2003.04 2012.04 SPEAKER_01 И в этот момент, когда только происходит поиск нужного хендлера, семантические данные еще на месте.
2012.04 2015.04 SPEAKER_01 То есть скоуп еще никуда не делся.
2015.04 2021.04 SPEAKER_01 Потому что точка выполнения программы все еще находится в том месте, где у нас случилось исключение.
2021.04 2025.04 SPEAKER_01 Поэтому скоуп есть, информация о том, где случилось исключение есть, все есть.
2025.04 2030.04 SPEAKER_01 Поэтому мы можем переделать наш процесс логирования немножко по-другому.
2030.04 2032.04 SPEAKER_01 Мы можем засунуть его в эксепшн-фильтры.
2032.04 2034.04 SPEAKER_01 Как будет выглядеть наша программа?
2034.04 2036.04 SPEAKER_01 На самом деле не сильно изменится.
2036.04 2038.04 SPEAKER_01 У нас точно так же будет try/catch блок.
2038.04 2041.04 SPEAKER_01 Внутри try мы делаем деление на 0.
2041.04 2044.04 SPEAKER_01 А вот catch поменяется.
2044.04 2051.04 SPEAKER_01 Кроме того, что мы обозначим, что мы кетчим любой эксепшн, который из него вылетает, появляется ключевое слово then.
2051.04 2055.04 SPEAKER_01 После этого ключевого слова мы должны передать функцию.
2055.04 2057.04 SPEAKER_01 И функция замыкания лямбда.
2057.04 2061.04 SPEAKER_01 И внутри этой лямбды мы можем сделать все, что угодно.
2061.04 2067.04 SPEAKER_01 Эта лямбда как раз вызывается на момент поиска подходящего к хендлера.
2067.04 2072.04 SPEAKER_01 И эта лямбда в качестве ответа может вернуть, а подходит данный хендлер или не подходит.
2072.04 2076.04 SPEAKER_01 В том числе она может не только вернуть, но она еще может вызвать логер.
2076.04 2083.04 SPEAKER_01 Она может залогировать как раз тот эксепшн, который у нас произошел в пределении на 0.
2083.04 2089.04 SPEAKER_01 И как вы помните, вот этот эксепшн-фильтр вызывается в момент поиска хендлера.
2089.04 2092.04 SPEAKER_01 То есть стэк еще весь на месте, скоп еще весь на месте.
2092.04 2099.04 SPEAKER_01 И таким образом тот скоп, который мы создали для запоминания первого и второго аргумента, он еще тоже весь на месте.
2099.04 2109.04 SPEAKER_01 Поэтому если мы вызовем логер внутри эксепшн-фильтра, он прекрасно залогирует не только исключения, но и наши дополнительные параметры, с которыми мы бы вошли в этот метод.
2109.04 2112.04 SPEAKER_01 Те самые примитивные аргумент 1 и аргумент 2.
2112.04 2120.04 SPEAKER_01 То есть мы получим всю ту дебаг-информацию, которую надеялись получить и которую мы бы получили при успешном выполнении метода.
2120.04 2124.04 SPEAKER_01 В общем, теперь мы можем получить ее не только при успешном, но и при исключении.
2124.04 2129.04 SPEAKER_01 То есть полные данные со всем скопом, хорошо и легко залогируется.
2129.04 2133.04 SPEAKER_01 Как я уже сказал, эксепшн-фильтр возвращает булевское значение true или false.
2133.04 2138.04 SPEAKER_01 И оно как раз обозначает то, подошел этот кетч блок или не подошел.
2138.04 2149.04 SPEAKER_01 Для того, чтобы удобно использовать логирование внутри эксепшн-фильтров, Стивен Клэрри предлагает два метода.
2149.04 2154.04 SPEAKER_01 Первый метод называется true, который принимает action, и второй называется false, который принимает action.
2154.04 2156.04 SPEAKER_01 Работают они довольно примитивно.
2156.04 2162.04 SPEAKER_01 Они вызывают action и возвращают булевое значение, соответствующее названию, через return.
2162.04 2166.04 SPEAKER_01 Но они довольно удобны, и поэтому их удобно применять на практике.
2166.04 2169.04 SPEAKER_01 Когда же вообще нужно возвращать true, а когда - false?
2169.04 2174.04 SPEAKER_01 По рекомендации автора, false следует возвращать, если...
2174.04 2175.04 SPEAKER_01 Что значит false?
2175.04 2178.04 SPEAKER_01 False означает, что это не подходящий кетч блок.
2178.04 2181.04 SPEAKER_01 Вы на него не смотрите и его не вызываете.
2181.04 2191.04 SPEAKER_01 Если вдруг ваш кетч блок не делает ничего, кроме того, что снова выбрасывает исключение, то есть делает throw, то в этом случае лучше вызывать false, возвращать false.
2191.04 2193.04 SPEAKER_01 Естественно, логирование вы делаете внутри лямбды.
2193.04 2204.04 SPEAKER_01 Опять же, можно свести, что если вы не делаете ничего в кетч блоке, кроме логирования и rethrow, то тогда нужно возвращать false, а логирование переносить в лямбду.
2204.04 2225.04 SPEAKER_01 Если же ваш кетч блок все-таки обрабатывает исключение, что-то там с ним делает, то в таком случае нужно вернуть true, и тогда вот этот поиск алгоритма, поиск хендлера, он поймет, что да, это тот самый кетч блок, который нам нужен, и вызовет непосредственно хендлер из этого кетч блока.
2225.04 2246.04 SPEAKER_01 Все казалось бы хорошо, вроде мы нашли решение, и все прекрасно, но, к сожалению, этот метод не очень хорошо работает в асинхронном коде, потому что эксцепшены в асинхронном коде возникают не там, где они зарейзились, а там, где стоит await.
2246.04 2258.04 SPEAKER_01 И поэтому эксцепшен-фильтры, которые запускает асинхронный код, они обычно срабатывают именно в await, а как раз не там, где произошло оригинальное исключение.
2258.04 2262.04 SPEAKER_01 Это вам нужно помнить и немножко эту специфику учитывать.
2262.04 2269.04 SPEAKER_01 Поэтому не всегда у вас получится записать scope правильно и красиво, но в большинстве случаев это как раз таки будет работать.
2269.04 2277.04 SPEAKER_01 Поэтому если вдруг вы в своих программах всегда писали лог непосредственно в кетч блоке, то помните, может быть гораздо удобнее и интереснее перенести его в эксцепшен-фильтр.
2277.04 2282.04 SPEAKER_01 Странно, кстати, почему-то я не видел анализаторов, которые советуют это делать.
2282.04 2286.04 SPEAKER_01 А совет довольно правильный и хороший, поэтому надеюсь скоро появится.
2286.04 2291.04 SPEAKER_01 Честно сказать, я никогда в эксцепшен-фильтрах не писал в логе.
2291.04 2294.04 SPEAKER_01 Вот я сейчас пытался понять, было ли у меня такое.
2294.04 2297.04 SPEAKER_01 И вообще, пользовался ли я хоть раз эксцепшен-фильтрами?
2297.04 2298.04 SPEAKER_01 Тебе доводилось?
2298.04 2301.04 SPEAKER_01 Скорее всего, потому что люди очень редкими пользуются.
2301.04 2303.04 SPEAKER_01 Мне кажется, на практике нет.
2303.04 2306.04 SPEAKER_01 Кроме логов, никогда они мне не пригождались.
2306.04 2308.04 SPEAKER_01 Ну вот, может быть.
2308.04 2316.04 SPEAKER_01 Ну, я не исключаю, что, может быть, был какой-нибудь код, знаешь, типа, подсмотрел на Stack Overflow, вот сделайте вот так вот, какой-нибудь инфраструктурно очень глубоко.
2316.04 2322.04 SPEAKER_01 Может быть, где-нибудь что-нибудь такое у меня и было, но я вот сейчас упор не помню, чтобы я когда-нибудь такое использовал.
2322.04 2329.04 SPEAKER_01 Может быть, просто потому что это, несмотря на все преимущества, которые ты там расписывал, выглядят все-таки немножко ненатурально.
2329.04 2330.04 SPEAKER_01 Вот.
2330.04 2338.04 SPEAKER_01 И читать код типа catchExceptionWhenFalse, ну как-то странновато немножко, не знаю.
2338.04 2342.04 SPEAKER_01 Да, мне тоже кажется, что синтаксис не очень хороший выбрали.
2342.04 2345.04 SPEAKER_01 Ну и действительно, ситуации довольно редкие, когда вам нужно это делать.
2345.04 2358.04 SPEAKER_01 В общем-то, тебе нужно не только, чтобы исключение не отличалось по типам, чтобы, например, у тебя исключение летит одно и то же, ну, допустим, какой-нибудь HTTP-респонсор эксцепшен, который там отличается, допустим, только по HTTP-коду.
2358.04 2369.04 SPEAKER_01 Вот там ты, например, можешь сделать несколько catch-блоков, во всех catch-блоках ловить responseException, но при этом when писать анализ на основании как раз HTTP-кода.
2369.04 2374.04 SPEAKER_01 Допустим, здесь я хочу только 400, здесь хочу только 200, что-то типа того можно придумать.
2374.04 2375.04 SPEAKER_01 Ну, редкая, редкая инфраструктура.
2375.04 2376.04 SPEAKER_01 Ну, наверное, да.
2376.04 2377.04 SPEAKER_01 Согласен?
2377.04 2378.04 SPEAKER_01 Да.
2378.04 2382.04 SPEAKER_01 Ну, хорошо, может, кто-нибудь новенький узнал и применит где-нибудь на практике.
2382.04 2383.04 SPEAKER_01 Почему нет?
2383.04 2384.04 SPEAKER_01 А мы пойдем дальше.
2384.04 2391.04 SPEAKER_01 И у нас не только релиз .NET 10 превью 1, но еще и релиз .NET Aspire 9.1.
2391.04 2393.04 SPEAKER_01 Это прям релиз, это не превью.
2393.04 2399.04 SPEAKER_01 И там это минорный релиз, там не так много изменений, но, тем не менее, они довольно интересные.
2399.04 2403.04 SPEAKER_01 Во-первых, довольно сильно прокачали дашборд.
2403.04 2423.04 SPEAKER_01 Настолько сильно прокачали, что если вы почитаете твиттер Джеймса Ньютона Кинга, который, я так понимаю, сейчас активно работает в Aspire и над Aspire, то он там, по-моему, последние недели 3 или 4, короче, активно твиттил каждый день на тему того, новые фичи в дашборде еще до релиза.
2423.04 2430.04 SPEAKER_01 Видимо, подгадывал, чтобы к моменту релиза, так сказать, фичи закончились, которые можно рассказать.
2430.04 2434.04 SPEAKER_01 Значит, в дашборде есть 6, так скажем, основных фич.
2434.04 2439.04 SPEAKER_01 Это, во-первых, показываются теперь отношения между ресурсами.
2439.04 2450.04 SPEAKER_01 Если у вас, например, есть пасдгря, в ней есть какие-то базы данных, а над пасдгрё есть какой-нибудь сервис, который его использует, то все это будет показано в виде дерева в некотором смысле.
2450.04 2457.04 SPEAKER_01 То есть он пытается понять, кто кому является ребенком, и пытается отрисовать это в виде дерева, а не просто плоского списка.
2457.04 2464.04 SPEAKER_01 Если вам нравится видеть дашборд на каком-то специфическом языке, дашборд теперь поддерживает собственную локализацию, независимо от языка браузера.
2464.04 2468.04 SPEAKER_01 Ну, по дефолту выбирается язык браузера, но можно переключить.
2468.04 2477.04 SPEAKER_01 В всяких списках, ну, в основном, понятно, в ресурсах теперь можно фильтровать по типу, состоянию, health check.
2477.04 2482.04 SPEAKER_01 В общем, если у вас какой-то большой продукт в Aspire, то, может быть, будет полезно.
2482.04 2498.04 SPEAKER_01 Для ресурсов показывается более детальная информация, то есть для каждого ресурса теперь показываются прямые ссылки, обратные ссылки на него, есть другие, кто на него ссылается, и какие вольюмы к нему подцеплены, если это какая-нибудь там база данных, на каких вольюмах лежат данные, и все такое прочее, тоже полезно.
2498.04 2511.04 SPEAKER_01 Дальше я не очень понял кейс, но дашборд теперь поддерживает правильные корсы для кастомных локальных доменов, то есть, в общем, я так понимаю, что...
2511.04 2519.04 SPEAKER_01 В общем, через переменное окружение .net/dashboards/course-allowed-origins вы задаете нужные ориджины, и тогда из этих...
2519.04 2530.04 SPEAKER_01 те браузерные приложения, которые работают на этих доменах, смогут нормально посылать в дашборд аспаровский нужные телеметрии.
2530.04 2539.04 SPEAKER_01 Вот, видимо, нужно, чтобы как раз endpoints от дашборда возвращали правильный корс в заголовки для тех сайтов, которые работают на других доменах.
2539.04 2541.04 SPEAKER_01 Как раз эти домены указываются.
2541.04 2546.04 SPEAKER_01 В консольных логах появилась опция "Скачать все логи" или "Включить/выключить таймстемпы".
2546.04 2552.04 SPEAKER_01 Я не знаю, почему логи без таймстемпов читать странно, но они всегда, кажется, нужны.
2552.04 2554.04 SPEAKER_01 Ну, видимо, кому-то не нужны.
2554.04 2558.04 SPEAKER_01 Ну и разные мелкие UX-импрувменты, которые совсем по мелочи.
2558.04 2563.04 SPEAKER_01 С точки зрения фич, добавилось некоторые такие интересные штуки.
2563.04 2566.04 SPEAKER_01 Во-первых, можно стартовать теперь ресурсы по требованию.
2566.04 2577.04 SPEAKER_01 То есть раньше, напомню, что вы задаете какие-то ресурсы в апхосте, и когда стартует апхост, то он автоматически поднимает все ресурсы, которые указаны.
2577.04 2581.04 SPEAKER_01 Можно ресурсу указать с помощью функции "With explicit start".
2581.04 2585.04 SPEAKER_01 Тот факт, что его не нужно запускать автоматически.
2585.04 2592.04 SPEAKER_01 Он просто будет там, ну, его проверят, конфиг для него соберут, но запускаться он не будет, и запустить его можно руками в дэшборде.
2592.04 2601.04 SPEAKER_01 Может быть, полезно для каких-нибудь там тяжеловесных или еще каких-то штук, которые вы не хотите запускать каждый раз, но, может быть, нужны для каких-то сценариев.
2601.04 2607.04 SPEAKER_01 Дальше можно контролировать еще более точно какие докерфайлы генерятся чтобы все это запустилось.
2607.04 2609.04 SPEAKER_01 Для этого нужно использовать функцию "Publish as dockerfile".
2609.04 2612.04 SPEAKER_01 Она была и раньше, но она не для всех типов ресурсов поддерживалась.
2612.04 2614.04 SPEAKER_01 Теперь для всех, как я понял.
2614.04 2623.04 SPEAKER_01 В конце работы, когда все это завершается, происходит теперь более правильная очистка сетей в докере, чтобы не оставалось лишнего.
2623.04 2627.04 SPEAKER_01 Ну, и если вы пользуетесь дефконтейнерами, там тоже улучшили поддержку.
2627.04 2637.04 SPEAKER_01 В части интеграций это те самые плагины, да, ну, get-пакеты, которые позволяют внутри Aspire использовать всякие разные как раз-таки продукты.
2637.04 2645.04 SPEAKER_01 Ну, то есть настраивать, да, в вашем продукте использование тех или иных интеграций, поэтому они называются интеграциями.
2645.04 2656.04 SPEAKER_01 Добавилось некоторое количество эмуляторов для ажурных сервисов, то есть теперь можно локально запустить сервис ВАЗ, Космос DB, Linux-based, чтобы это не было, и SignalARM вместо ажурного.
2656.04 2661.04 SPEAKER_01 При этом появилась возможность использовать существующие ресурсы в ажуре.
2661.04 2672.04 SPEAKER_01 То есть раньше, как я понимаю, если вы использовали какие-то ажурные ресурсы, то обход, как при старте, за вас их всех поднимал, а потом, соответственно, обратно удалял.
2672.04 2675.04 SPEAKER_01 Теперь есть возможность поиспользовать уже готовый.
2675.04 2689.04 SPEAKER_01 То есть если у вас создан какой-то там сервис ВАЗ, и вы хотите всегда коннектиться к нему одному, вы просто указываете asExisting, по-моему, называется функция, указываете все нужные креды в конфиге, естественно, и все будет просто работать.
2689.04 2693.04 SPEAKER_01 Espire не будет за вас там поднимать, удалять те или иные сервисы.
2693.04 2699.04 SPEAKER_01 Ну и пообновляли разные версии, там RabbitMQ поновее стал, MongoDB драйвер поновее стал, ну и так далее.
2699.04 2709.04 SPEAKER_01 С точки зрения тестирования, напомню, что Espire поддерживает интеграционное тестирование, то есть можно писать тесты на все приложение, грубо говоря, на весь ваш продукт.
2709.04 2714.04 SPEAKER_01 Появилась опция выключить рандомизацию портов, чтобы были более предсказуемые.
2714.04 2719.04 SPEAKER_01 По дефолту в тесте, ну как я помню, дашборд выключен, теперь появилась опция его включить, если хотите.
2719.04 2722.04 SPEAKER_01 Ну и можно там с аргументами теперь.
2722.04 2726.04 SPEAKER_01 Видимо, раньше нельзя было передавать аргументы в обход, теперь можно.
2726.04 2728.04 SPEAKER_01 Вот какие-то такие изменения в Espire.
2728.04 2734.04 SPEAKER_01 То есть вроде бы ничего революционного, но пушат его довольно активно.
2734.04 2741.04 SPEAKER_01 То есть я не знаю, в Твиттере, по-моему, Fowler и James Newton King ни про что, кроме как Espire, не пишут.
2741.04 2745.04 SPEAKER_01 Как AI из каждого утюга, вот у них Espire из каждого утюга.
2745.04 2749.04 SPEAKER_01 Прям очень активно, не знаю.
2749.04 2755.04 SPEAKER_01 Видимо, у них стоит KPI, продвинуть Espire как можно шире.
2755.04 2761.04 SPEAKER_01 Заметь, что не просто активно, а именно активно с помощью самых крутых лидеров мнений, которые у них есть.
2761.04 2769.04 SPEAKER_01 То есть и Newton King, и Fowler, это как бы наше все.
2769.04 2776.04 SPEAKER_01 И набросили таких мастандонтов на этот проект, которые, опять же, не зарабатывают, в отличие от Azure, как-то отдельно.
2776.04 2784.04 SPEAKER_01 Не просто платформы универсальные, как, допустим, весь Runtime, или весь .NET, или какой-нибудь C#.
2784.04 2796.04 SPEAKER_01 То есть чисто такая пока, она такая какая-то узкая тулзень с узкой нишей, которая мало кому, грубо говоря, нужна, кроме .NET разработчиков, может быть.
2796.04 2800.04 SPEAKER_01 И вот все еще дофигища усилий укладывает.
2800.04 2805.04 SPEAKER_01 Ну, или, может быть, не обязательно .NET разработчиков, а тех, кто сидит на Azure.
2805.04 2809.04 SPEAKER_01 В принципе, в Azure можно не только .NET разработчикам.
2809.04 2813.04 SPEAKER_01 Это, наверное, не сказать, что странная комбинация.
2813.04 2822.04 SPEAKER_01 Понятно, что от .NET проекта, от .NET компаний, грубо говоря, то есть компаний, которые используют .NET, ты, может быть, даже и ожидаешь, что они с некоторой вероятностью будут в Azure.
2822.04 2835.04 SPEAKER_01 А вот если вы там, компания, которая пишет, не знаю, на Java, на Python, на Rust, на чем угодно, пойдете вы в Azure или в AWS, ну, я не говорю, что нельзя в Azure, но, наверное, это будет неочевидным выбором.
2835.04 2836.04 SPEAKER_01 Я бы так сказал.
2836.04 2842.04 SPEAKER_01 Вот, и, может быть, это их способ попытаться затащить еще больше кастомеров в Azure, которые как раз деньги уже приносят.
2842.04 2846.04 SPEAKER_01 Ну, может быть, но, если честно, способ довольно странный.
2846.04 2853.04 SPEAKER_01 Он мега затратный, он не дает никакого стопроцентного эффекта, и не очевидно, что именно это способ затаскивания в Azure, если честно.
2853.04 2854.04 SPEAKER_01 Может быть, может быть.
2854.04 2857.04 SPEAKER_01 Ну, поглядим, давай посмотрим, как это будет дальше развиваться.
2857.04 2861.04 SPEAKER_01 Наверняка на протяжении нескольких лет мы это все увидим.
2861.04 2863.04 SPEAKER_01 Надо только подождать.
2863.04 2874.04 SPEAKER_01 Да, согласен, что если у Microsoft есть какой-то тайный большой план, то уже как бы пора его вытаскивать наружу, потому что продукт уже вроде зарелизился, уже много всего умеет, хорошо развился, хорошо зарекламировался.
2874.04 2877.04 SPEAKER_01 Уже пора рассказывать, зачем они его вообще придумали.
2877.04 2879.04 SPEAKER_01 Ну, посмотрим, посмотрим.
2879.04 2891.04 SPEAKER_01 Так, давай-ка с тобой поговорим на такую халеварно-менеджерскую тему, потому что, знаешь, я, опять же, очень много сталкиваюсь с вопросом, а почему .NET не так популярен.
2891.04 2894.04 SPEAKER_01 Потому что, когда начинаешь копать глубже, язык гениальный.
2894.04 2899.04 SPEAKER_01 Самое лучшее, что есть вообще в мире, было придумано именно на C#.
2899.04 2903.04 SPEAKER_01 Сам рантайм прекрасно и развивается, там перформансом наш каждый релиз лезет.
2903.04 2908.04 SPEAKER_01 Все как раз платформенно, в комьюнити хорошее, Microsoft добрый, все открыто.
2908.04 2923.04 SPEAKER_01 Казалось бы, у .NET никаких минусов нет, но если посмотреть вокруг, все еще выстреливают какие-то или старинные языки, или глупые языки, или языки вообще, которые не должны были быть предназначены для enterprise разработки.
2923.04 2927.04 SPEAKER_01 Они все еще почему-то живы и не умирают, и .NET не захватывает C# весь мир.
2927.04 2947.04 SPEAKER_01 И когда начинаешь углубляться в этот вопрос, а почему, когда приходишь к людям и начинаешь задавать им вопрос, а почему вы не выбрали .NET, почему вы не выбрали C#, практически подавляющее большинство ответов наводит на мысль в том, что люди просто живут в мифах и стереотипах.
2947.04 2954.04 SPEAKER_01 То есть они полностью заблуждаются в каких-то своих вещах, и нужно их наставлять на путь истинный.
2954.04 2957.04 SPEAKER_01 Ну и кому как, не нашему подкасту это делать.
2957.04 2968.04 SPEAKER_01 Поэтому приходится хотя бы вещи, которые очевидны для всех .NET разработчиков, что C# - самый прекрасный язык на свете, приходится доносить, наверное, тем, кто почему-то в этом сомневается.
2968.04 2971.04 SPEAKER_01 Поэтому мне понравилась статья, которая была на хабре.
2971.04 2977.04 SPEAKER_01 Называется она "Импортозамещение ПО в России. Тенденции и перспективы после ухода Microsoft".
2977.04 2984.04 SPEAKER_01 Это как раз одна из тех страшилок, которые сидят в умах этих заскорудлых людей.
2984.04 2988.04 SPEAKER_01 У вас же Microsoft ушел. Что будет с .NET? Что будет с C#?
2988.04 2990.04 SPEAKER_01 Их же, наверное, сейчас закроют.
2990.04 2992.04 SPEAKER_01 Microsoft же проприетарный и злой.
2992.04 2995.04 SPEAKER_01 Он все закрывает, все отменяет, и вам, наверное, всем кранты.
2995.04 2999.04 SPEAKER_01 Давайте быстро переписывать все на какую-нибудь Java.
2999.04 3002.04 SPEAKER_01 То, что Oracle ушел, никого не волнует.
3002.04 3005.04 SPEAKER_01 То, что Google вместе с Go ушли, тоже никого не волнует.
3005.04 3010.04 SPEAKER_01 Ну, то есть такие выводы довольно неочевидные и далеко идущие.
3010.04 3012.04 SPEAKER_01 Вот давайте с этим и разберемся.
3012.04 3015.04 SPEAKER_01 Статью написал исполнительный директор компании DD Planet.
3015.04 3022.04 SPEAKER_01 Эта компания 20 лет уже существует на рынке и производит большие масштабные .NET решения.
3022.04 3027.04 SPEAKER_01 И является топ-5 интеграторов .NET, я так понимаю, в России.
3027.04 3031.04 SPEAKER_01 И с уходом Microsoft, естественно, они свой стек не поменяли.
3031.04 3033.04 SPEAKER_01 И вот в этой статье как раз рассказывается почему.
3033.04 3036.04 SPEAKER_01 Игорь, а ты знаешь компанию DD Planet?
3036.04 3042.04 SPEAKER_01 Честно говоря, первый раз слышу, но интегратор - это довольно специфический бизнес.
3042.04 3047.04 SPEAKER_01 И я, поскольку их клиентом не был, то, наверное, поэтому и не знаю.
3047.04 3055.04 SPEAKER_01 Все-таки интеграторы - это суровые B2B-интерпрайзные большие штуки, которые, наверное, я просто не пересекался.
3055.04 3059.04 SPEAKER_01 Не, ну я согласен, что по продуктам, наверное, мы с тобой не могли знать.
3059.04 3066.04 SPEAKER_01 Но если взять, что это топ-5 интегратор, у него очень много проектов, у него очень много разработчиков, то мы должны были ее знать по конференциям.
3066.04 3069.04 SPEAKER_01 Ну вот, например, Contour, Dodo, Ozone, Tinkoff.
3069.04 3073.04 SPEAKER_01 Все знают их внутри сообщества именно по докладам.
3073.04 3077.04 SPEAKER_01 Насколько я помню, из Планета у нас никого не было.
3077.04 3081.04 SPEAKER_01 В общем, товарищи DD Planet, если вы такие большие, крутые, ждем вас на конференциях.
3081.04 3085.04 SPEAKER_01 Мне кажется, интеграторы - это как раз те люди, которым очень есть что рассказать.
3085.04 3088.04 SPEAKER_01 Всегда много каких-то интересных живых историй.
3088.04 3089.04 SPEAKER_01 В общем, приходите.
3089.04 3091.04 SPEAKER_01 А мы вернемся к статье.
3091.04 3098.04 SPEAKER_01 Итак, в 2022 году компания Microsoft присоединилась к антироссийским санкциям и сбежала из России.
3098.04 3101.04 SPEAKER_01 Соответственно, она прекратила поддержку своего ПО.
3101.04 3111.04 SPEAKER_01 И перед многими компаниями встал вопрос, а стоит ли переходить, стоит ли переписывать все проекты, которые раньше были написаны на статье Microsoft, или не стоит.
3111.04 3117.04 SPEAKER_01 И здесь возникла куча всяких разных заблуждений.
3117.04 3122.04 SPEAKER_01 Например, посмотрим самый популярный - возможно, запрет на использование технологий в России.
3122.04 3129.04 SPEAKER_01 То есть, в связи с тем, что Microsoft ушел с рынка, будущее .NET стека вообще казалось туманным.
3129.04 3132.04 SPEAKER_01 И этот миф возник неспроста.
3132.04 3140.04 SPEAKER_01 Потому что до 2015 года .NET не был фреймворком с открытым исходным кодом.
3140.04 3142.04 SPEAKER_01 Он не являлся кроссплатформенным.
3142.04 3144.04 SPEAKER_01 Он работал только под Windows.
3144.04 3157.04 SPEAKER_01 И вот эта мантра, которая существовала до 2015 года, она до сих пор закрепилась в умах недалеких людей, что Microsoft не кроссплатформена, не открыта, только под Windows.
3157.04 3160.04 SPEAKER_01 И, естественно, когда Microsoft уходит, все это мгновенно схлопывается.
3160.04 3165.04 SPEAKER_01 Вот этот устаревший взгляд как раз-таки был очень распространен.
3165.04 3168.04 SPEAKER_01 Но, опять же, 2015 год, товарищи.
3168.04 3177.04 SPEAKER_01 Это было 10 лет назад. 10. Уже, наверное, родились .NET разработчики, которым уже меньше 10 лет.
3177.04 3179.04 SPEAKER_01 И они не знают ничего этого.
3179.04 3188.04 SPEAKER_01 А в сегодняшний день, если мы посмотрим и откроем глазки, хотя бы через 10 лет моргания откроем глазки, то мы увидим, что .NET - это открытый исходный код.
3188.04 3193.04 SPEAKER_01 Это кроссплатформенная разработка со всякими различными открытыми лицензиями.
3193.04 3196.04 SPEAKER_01 И запретить его в нашей стране не представляется возможным.
3196.04 3198.04 SPEAKER_01 Это технология с открытой лицензией.
3198.04 3201.04 SPEAKER_01 Запретить ее нельзя. Чисто физически.
3201.04 3204.04 SPEAKER_01 Поэтому ни от какой Microsoft это не зависит.
3204.04 3207.04 SPEAKER_01 Дальше. От отсутствия квалифицированной поддержки.
3207.04 3212.04 SPEAKER_01 То есть существует такой миф, что в настоящее время в России осуществляется исключительно поддержка силами сообществ.
3212.04 3215.04 SPEAKER_01 И официально от Microsoft вы ничего не добьетесь.
3215.04 3218.04 SPEAKER_01 То есть никто не гарантирует вам оперативное решение проблем.
3218.04 3220.04 SPEAKER_01 Ну, на самом деле, это действительно так.
3220.04 3225.04 SPEAKER_01 Если вдруг у вас в .NET или в C# будут какие-то проблемы, то никто вам оперативно их не решит.
3225.04 3232.04 SPEAKER_01 С другой стороны, мне кажется, даже когда Microsoft был в России, то никто вам их оперативно и не решал.
3232.04 3240.04 SPEAKER_01 Потому что это нужно быть очень платиновым партнером Microsoft, чтобы они пошли и начали что-то специально под вас в рантайме мутить.
3240.04 3245.04 SPEAKER_01 То есть мы знаем такие примеры, но, опять же, это дано абсолютно не всем компаниям.
3245.04 3250.04 SPEAKER_01 И поэтому в данном случае ничего сильно не изменится.
3250.04 3261.04 SPEAKER_01 Естественно, если вы пользуетесь какими-то платными инструментами Microsoft, не знаю, SharePoint, Active Directory, Ease, Power BI и еще что-то.
3261.04 3266.04 SPEAKER_01 Вот там да, там у вас есть проблемы, потому что саппорт таких инструментов прекращен.
3266.04 3275.04 SPEAKER_01 Но если мы говорим о C#, о .NET, о всех библиотеках, которые вокруг, то никакого саппорта Microsoft здесь нет, не было и, в принципе, и не нужно.
3275.04 3279.04 SPEAKER_01 Ошибки в релизах, да, бывают, как и в любом программном обеспечении.
3279.04 3289.04 SPEAKER_01 И как платформа мегапопулярная, то ошибки оперативно устраняются для всего мира, не только для России, и никакой специфики России здесь и в помине нет.
3289.04 3296.04 SPEAKER_01 Также существуют опасения, что могут быть закладки с вирусным программным обеспечением.
3296.04 3305.04 SPEAKER_01 У нас есть Nuget, и оттуда можно затащить какой-то код, который принесет вам вирус, и этот вирус заразит все ваше программное обеспечение.
3305.04 3313.04 SPEAKER_01 В общем, этот тезис, опять же, никак не связан с Microsoft, потому что Microsoft не контролирует антивирусные программы, которые сканирует Nuget.
3313.04 3315.04 SPEAKER_01 И вообще, в принципе, никак не связан с .NET.
3315.04 3329.04 SPEAKER_01 Мы знаем миллион примеров, когда любой язык программирования затаскивал в себя пакеты, содержащие Middleware, Mailware, вирусы, шифровальщика, взломщика, вообще все что угодно.
3329.04 3333.04 SPEAKER_01 В общем, риски все одинаковые, опять же, никак не связаны ни с Microsoft, ни с Россией, ничего такого здесь нет.
3333.04 3338.04 SPEAKER_01 В общем, такие основные опасения. Что же у нас можно сказать в пользу .NET?
3338.04 3351.04 SPEAKER_01 А в пользу .NET можно привести такие пункты, как у .NET существует активное сообщество, сообщество постоянно развивается, сообщество развивается со всех сторон и поддерживается разными компаниями, и это не только Microsoft.
3351.04 3357.04 SPEAKER_01 Действительно, Microsoft по-прежнему является самым большим двигателем и пин-кодователем для .NET стека.
3357.04 3370.04 SPEAKER_01 Но если мы посмотрим вокруг, то в Амазоне очень хорошее развитие .NET, там Samsung свою операционную систему пишет, написал, может быть, даже на .NET в Google очень хорошие были .NET библиотеки.
3370.04 3376.04 SPEAKER_01 То есть во многих компаниях вокруг в мире хорошая поддержка .NET есть и будет, и никуда она не денется.
3376.04 3380.04 SPEAKER_01 Ну и вокруг нас тоже, благодаря активному сообществу, происходит много всего интересного.
3380.04 3388.04 SPEAKER_01 Это конференции, курсы, книги, подкасты, которые вы сейчас слушаете, в конце-то концов, никуда мы не делись, не схлопнулись и меньше писаться от этого не стали.
3388.04 3404.04 SPEAKER_01 Автор выделяет также, что им в .NET стеке нравится эволюция, то, как развивается проект, как развивается вся технология, потому что за последние 10 лет, как он светует, с точки зрения развития языка программирования, Java, например, практически не изменилась.
3404.04 3407.04 SPEAKER_01 Добавляются какие-то рюшечки, но ничего интересного, ничего особенного.
3407.04 3412.04 SPEAKER_01 А разница между текущей версией .NET и .NET десятилетней давности, она просто колоссальная.
3412.04 3417.04 SPEAKER_01 Все время добавляются какие-то новые интересные фишки и языка, и рантайма, и платформы.
3417.04 3421.04 SPEAKER_01 И, в общем, здесь ему все нравится, все цветет и пахнет.
3421.04 3423.04 SPEAKER_01 Про интеграцию.
3423.04 3431.04 SPEAKER_01 Он говорит, что .NET легко интегрируется с другими продуктами, с любыми сервисами, а вот с Java иногда приходится приложить дополнительные усилия.
3431.04 3433.04 SPEAKER_01 Не знаю, не могу здесь привести примеров.
3433.04 3441.04 SPEAKER_01 Игорь, у тебя есть какие-то примеры, где интеграция Java с чем-то проходила плохо, а вот .NET прям залетел как надо?
3441.04 3444.04 SPEAKER_01 Да нет, и там, и там бывают проблемы.
3444.04 3446.04 SPEAKER_01 Есть и там, и там нормальная интеграция.
3446.04 3473.04 SPEAKER_01 То есть в Java мире могут быть, мне кажется, чуть больше проблем, потому что там бывает побольше выбор, в силу того, что многие продукты, ну там какая-нибудь Kafka или прочее, написаны на Java, и, соответственно, к ней или к такому продукту может быть просто некоторое количество разнообразных, не знаю, драйверов, подходов к работе или еще чего-то в таком духе, и надо повыбирать, а в .NET будет какой-нибудь один более-менее нормально работающий и уже хорошо.
3473.04 3476.04 SPEAKER_01 Наверное, может в этом какая-нибудь проблема быть.
3476.04 3482.04 SPEAKER_01 Но это не в том, что там, ну да, усилия надо приложить, выбрать, например.
3482.04 3490.04 SPEAKER_01 Я не встречался с какими-то прям особыми проблемами в Java с точки зрения прям интеграции.
3490.04 3509.04 SPEAKER_01 Может быть, если речь идет о каким-нибудь условно-бинарных интеграциях, то есть вот здесь я небольшой спец в Java в этом, но здесь я слышал про всякие там GNI и прочее, которые не так круты, конечно, как возможность .NET по вызову нативного кода.
3509.04 3512.04 SPEAKER_01 Но это такой специфический тип интеграции.
3512.04 3522.04 SPEAKER_01 Ну может действительно, правда, имеется в виду конфликт версий, знаешь, когда тебе, чтобы, например, запустить Spring, тебе нужен отдельный Spring Boot, который знает, какие версии на другом совместимы и что можно использовать.
3522.04 3527.04 SPEAKER_01 Вот это да, кстати, может быть, версионность тут есть какая-то, да.
3527.04 3530.04 SPEAKER_01 Хорошо, погнали дальше.
3530.04 3531.04 SPEAKER_01 Кроссплатформенность.
3531.04 3543.04 SPEAKER_01 Хороший .NET является хорошим кроссплатформенным нормальным фреймворком, который запускается не только на очевидных Linux, Mac и Windows, но и прекрасно покрывает мобилки, есть на телевизорах, на микроконтроллерах.
3543.04 3548.04 SPEAKER_01 ВебАСМ, я думаю, можно уже выделить как отдельная такая, знаешь, платформа, инфраструктура.
3548.04 3552.04 SPEAKER_01 То есть на WebAssembly мы появились одни из первых, и Blazor там до сих пор рулит и бибикает.
3552.04 3558.04 SPEAKER_01 В общем, сложно найти более кроссплатформенный язык, ну если не брать там C какие-нибудь.
3558.04 3561.04 SPEAKER_01 В общем, поэтому покрывается все довольно хорошо.
3561.04 3570.04 SPEAKER_01 Если брать про изводительность и оптимизации, то вообще высокий уровень производительности нам практически гарантирован, с каждым релизом он повышается и повышается.
3570.04 3579.04 SPEAKER_01 Тот же самый JIT и Just-In-Time Compilation компилируют с каждым разом лучше и красивше, и оптимизируют все ваши приложения прекрасно.
3579.04 3591.04 SPEAKER_01 Движение в сторону Ahead of Time Compilation тоже радует, которое нам помогает сделать из нашего интерпретируемого кода полностью компилируемый и ускорить таким образом стартап и потребление ресурсов.
3591.04 3595.04 SPEAKER_01 То есть в этом направлении много чего двигается и интересного происходит.
3595.04 3602.04 SPEAKER_01 Также можно отмечать, что Java зачастую уступает в тестах производительности, несмотря на все усилия, которые происходят в Hotspot GVM.
3602.04 3606.04 SPEAKER_01 Ну, здесь тоже у меня никаких конкретных ссылок и бенчмарков нет.
3606.04 3610.04 SPEAKER_01 Где он там уступает, а где не уступает, в принципе, непонятно.
3610.04 3614.04 SPEAKER_01 Кажется, что, наверное, на примерно том же уровне должны работать.
3614.04 3622.04 SPEAKER_01 Почему-то автор очень много с Java сравнивает, потому что как раз, наверное, у него основной вопрос перехода.
3622.04 3628.04 SPEAKER_01 Когда кто-то переходит в C#, обычно это все-таки переходит на Java как наиболее близко идеологический фреймворк.
3628.04 3631.04 SPEAKER_01 Вот почему, наверное, у него так много сравнений.
3631.04 3642.04 SPEAKER_01 И он отмечает, что как раз-таки исторически сложилось так, что в умах заскорлузлых фанатиков Java как раз-таки является бесплатной кросс-платформенной технологией для интерпрайза.
3642.04 3650.04 SPEAKER_01 И это, грубо говоря, большое заблуждение, потому что .NET по всем параметрам по этим намного лучше Java.
3650.04 3665.04 SPEAKER_01 И вот эта заскорлузлость, вот это незнание, что есть фреймворк, который по тем же самым параметрам в принципе везде круче, вот эта проблема, она и является причиной того, что .NET отстает в популярности.
3665.04 3683.04 SPEAKER_01 То есть популярность она как раз определилась не тем, что он хуже или медленнее или развивается плохо, а тем, что люди как раз не понимают, что .NET сейчас на той стадии развития, когда он является идеальным выбором для какого-нибудь кросс-платформенного open-source интерпрайз-решения.
3683.04 3690.04 SPEAKER_01 Так, а дальше автор рассказывает, а какие продукты Microsoft все-таки они не используют больше, то есть они решили отказаться.
3690.04 3692.04 SPEAKER_01 Нет, для начала, какие используют.
3692.04 3699.04 SPEAKER_01 Прежде всего хотелось бы отметить, что они используют Xamarin, который бывший Xamarin, теперь он .NET MyUI.
3699.04 3703.04 SPEAKER_01 Это кросс-платформенный фреймворк для мобилок и десктопных приложений.
3703.04 3717.04 SPEAKER_01 И интересно, что компания занимает лидирующие позиции по экспертизе в Xamarin, потому что там есть огромное число разработчиков Xamarin, и они поддерживают портал Xamarin.ru, на котором выходят новости, статьи и мнения экспертов.
3717.04 3721.04 SPEAKER_01 Поэтому если вы на MyUI и на Xamarin программируете, посмотрите на порталчик.
3721.04 3731.04 SPEAKER_01 И специально для нас я нашел там приложение, которое ребята делали, и на Xamarin сделаны госуслуги для мобильного телефончика.
3731.04 3735.04 SPEAKER_01 В нашей копилке, чего сделано на .NET, прибыло.
3735.04 3738.04 SPEAKER_01 Прикольно. Интересно, они до сих пор на нем?
3738.04 3741.04 SPEAKER_01 Наверное, да. Почему бы и нет?
3741.04 3744.04 SPEAKER_01 Ну, вроде да. Почему бы и нет?
3744.04 3748.04 SPEAKER_01 Здесь можно еще отметить, что существует фреймворк Avalon.
3748.04 3761.04 SPEAKER_01 Это, кажется, очень хороший кроссплатформенный фреймворк для написания UI, поэтому если вы вдруг рассматриваете какие-то UI, обязательно посмотрите на Avalon.
3761.04 3763.04 SPEAKER_01 А теперь все-таки, что же они заменяют?
3763.04 3775.04 SPEAKER_01 Мы сказали, что с уходом Microsoft все-таки коммерческие инструменты закрыты, потеряли поддержку и потеряли возможность продлить лицензию, поэтому некоторые пришлось заменить.
3775.04 3778.04 SPEAKER_01 И в качестве примера они приводят Blazor первой строчкой.
3778.04 3782.04 SPEAKER_01 Blazor они заменяют на React, Angular и Vue.
3782.04 3788.04 SPEAKER_01 Странное решение, опять же, с точки зрения ухода Open Source и всего такого.
3788.04 3793.04 SPEAKER_01 В общем, кажется, что тут должны быть какие-то другие причины замены Blazor.
3793.04 3796.04 SPEAKER_01 Следующий - это ORM Entity Framework.
3796.04 3799.04 SPEAKER_01 Entity Framework они заменяют на Dapper.
3799.04 3802.04 SPEAKER_01 Странное решение. Ладно, попозже вернемся к этому.
3802.04 3808.04 SPEAKER_01 Дальше они заменяют веб-сервера различные, такие как IIS, это понятно, и Kestrel, это непонятно.
3808.04 3811.04 SPEAKER_01 Заменяют они его на Haproxy и Nginx.
3811.04 3813.04 SPEAKER_01 Вот более очевидные вещи.
3813.04 3815.04 SPEAKER_01 MSSQL заменяется на Postgres.
3815.04 3820.04 SPEAKER_01 Это у всех стандартная миграция последние несколько лет, и это хорошо.
3820.04 3824.04 SPEAKER_01 MSMQ заменяется на Rebit и VKafka.
3824.04 3829.04 SPEAKER_01 Ну, это, наверное, стандартная миграция последние лет 20, наверное, поэтому это тоже хорошо.
3829.04 3831.04 SPEAKER_01 Странно, что так долго продержались.
3831.04 3833.04 SPEAKER_01 И MSBI заменяется на Grafana.
3833.04 3842.04 SPEAKER_01 Я бы не сказал, что Grafana покрывает полностью MSBI и наоборот, но, опять же, если в их разрезе этого хватает, то почему бы и нет.
3842.04 3845.04 SPEAKER_01 Причины замены вот этих инструментов называется несколько.
3845.04 3851.04 SPEAKER_01 Во-первых, большинство из них платные и являются с закрытым исходным кодом, не с открытым исходным кодом.
3851.04 3857.04 SPEAKER_01 И, во-вторых, это бесплатные аналоги, развиваются быстрее, имеют больше сообщества и имеют широкие возможности.
3857.04 3863.04 SPEAKER_01 Вот, кажется, вот эти две причины, но в эти две причины абсолютно не матчатся некоторые пункты.
3863.04 3873.04 SPEAKER_01 Ну, например, Blazor, за что пострадал бедный Blazor, ведь он и open source, он и с открытым исходным кодом, и развивается так, что как бы все бы так развивались.
3873.04 3877.04 SPEAKER_01 И является частью ISP.NET Core, а это MIT лицензия.
3877.04 3879.04 SPEAKER_01 То есть у него нормальная, хорошая лицензия.
3879.04 3882.04 SPEAKER_01 Понятно, зачем с него переходить на Angular.
3882.04 3894.04 SPEAKER_01 Многие переходят, конечно, потому что, не из-за лицензии, а потому что Angular разработчиков больше, React разработчиков больше, и легче найти на рынке специалистов именно по этим стэкам, поэтому Blazor пока не в фаворе.
3894.04 3900.04 SPEAKER_01 Дальше, как я уже упомянул, компания уходит от Kestrel, в пользу Nginx.
3900.04 3908.04 SPEAKER_01 Ну, тоже, Kestrel - это неотделимая часть от ISP.NET Core, и вы не сможете запустить ISP.NET Core приложение и не использовать Kestrel.
3908.04 3911.04 SPEAKER_01 Поэтому здесь, наверное, тоже какая-то ошибка, скорее всего, в документации.
3911.04 3916.04 SPEAKER_01 Ну, и с EF Core, то есть с EF, с EF мигрируют на Dapr.
3916.04 3923.04 SPEAKER_01 Я надеюсь, что они говорят просто про EF Framework, то есть старый, который Windows Only.
3923.04 3927.04 SPEAKER_01 Потому что с EF Core никакого смысла мигрировать под Dapr нет.
3927.04 3939.04 SPEAKER_01 Потому что EF Core - это MIT лицензия, опять же, open source, открыто, берите, не хочу, и переписывать все на EF Core намного легче с EF, чем на Dapr.
3939.04 3941.04 SPEAKER_01 Потому что возможности у них абсолютно несопоставимы.
3941.04 3946.04 SPEAKER_01 У Dapr не было и половины тех возможностей, которые есть у EF Core.
3946.04 3957.04 SPEAKER_01 Ну, ладно, это мелочи, так не будем придираться, это мы уже как-то пошли в технические дебри, статья все-таки больше про концептуальный смысл, а не про какую-то технику.
3957.04 3961.04 SPEAKER_01 Итак, почему же компания продолжает оставаться на .NET Stack, несмотря ни на что?
3961.04 3973.04 SPEAKER_01 Ну, во-первых, у них накопилась огромная экспертиза с 2012 года, как я уже сказал, топ-5 интеграторов, очень много разработчиков, много проектов, экспертиза ого-го, никакого смысла просто так ее выбрасывать нет.
3973.04 3981.04 SPEAKER_01 А это было бы именно просто так, потому что, как мы обсудили выше, никаких причин отказываться от .NET Stack нет.
3981.04 3986.04 SPEAKER_01 Нужно упомянуть, что .NET входит в реестр отечественного ПО от Минцифры.
3986.04 4002.04 SPEAKER_01 .NET Core одобрен, поэтому если вы захотите свое программное обеспечение зарегистрировать в реестр отечественного ПО, то милости просим. .NET Core, ASP, Postgres, Entity Framework, все там любят, все там принимают, проверено неоднократно.
4002.04 4009.04 SPEAKER_01 И почему-то весомым аргументом для автора стало то, что Министерство Цифрового Развития выпустило бесплатные курсы по .NET.
4009.04 4013.04 SPEAKER_01 Это было каким-то фактическим признанием .NET.
4013.04 4016.04 SPEAKER_01 Ну, допустим.
4016.04 4022.04 SPEAKER_01 Автор отмечает, что спрос на отстав специалистов не утихает, а только растет с каждым годом сильнее и сильнее.
4022.04 4030.04 SPEAKER_01 То есть запросы на .NET разработчиков поступают каждый день, и все компании хотят срочно иметь много .NET разработчиков.
4030.04 4038.04 SPEAKER_01 Дальше есть интересный блог с экспертами, среди которых хотелось бы отметить, конечно, Андрея Парамонова, техлида .NET Engineering.
4038.04 4045.04 SPEAKER_01 И он отметил, что проблемы есть, проблемы есть с Microsoft Azure, потому что отключили часть сервисов, не принимают плату и так далее.
4045.04 4051.04 SPEAKER_01 Но, как я уже сказал, как раз таки инструменты платные и закрытые действительно пострадали.
4051.04 4054.04 SPEAKER_01 Но это, опять же, проблема не только с Microsoft.
4054.04 4056.04 SPEAKER_01 Это проблема вообще с абсолютно всеми облаками.
4056.04 4058.04 SPEAKER_01 Как бы и ушел Microsoft, не ушел Microsoft.
4058.04 4062.04 SPEAKER_01 И у Google, и у AWS те же самые проблемы.
4062.04 4065.04 SPEAKER_01 Но это никак не повлияло на .NET.
4065.04 4073.04 SPEAKER_01 Как он был основным стеком программирования в .DOT, так он там и остался, и никто его менять не планирует, потому что все хорошо, не надо дергаться.
4073.04 4080.04 SPEAKER_01 Дальше автор приводит, что, согласно индексу TIOBI, C# входит в пятерку самых востребованных языков.
4080.04 4089.04 SPEAKER_01 Здесь нужно уточнить, конечно, что индекс TIOBI, это не то чтобы показывает востребность языков, этот индекс показывает на то, насколько языки часто ищут.
4089.04 4095.04 SPEAKER_01 И, наверное, больше показывает количество проблем, с которыми люди сталкиваются, раз они его ищут.
4095.04 4097.04 SPEAKER_01 Ну, там, какую-то корреляцию навести можно.
4097.04 4116.04 SPEAKER_01 Также он отвечает, что количество вакансий на HeadHunter исчисляются тысячами, и как бы тоже их меньше не становится, и вакансий намного больше, чем у нас есть в .NET разработчиков, поэтому спрос на разработчиков все еще велик, но при этом Java опережает по вакансиям в .NET почти в два раза.
4116.04 4119.04 SPEAKER_01 То есть, джависты нужны больше явно.
4119.04 4121.04 SPEAKER_01 Здесь это видно.
4121.04 4123.04 SPEAKER_01 Итак, какие же выводы мы можем сделать?
4123.04 4136.04 SPEAKER_01 Ну, во-первых, уход Microsoft именно для платформы .NET, для платформы C# и всех библиотек вокруг Nuget, Entity Framework и прочих expired не означает ровным счетом ничего.
4136.04 4144.04 SPEAKER_01 Как бы как Microsoft сильно на это не влияла для обычного разработчика, так она и не стала влиять.
4144.04 4148.04 SPEAKER_01 Для каких-то закрытых коммерческих и других продуктов, да, проблемы есть.
4148.04 4151.04 SPEAKER_01 Но с .NET и C# это вообще никак не связано.
4151.04 4161.04 SPEAKER_01 Есть проблемы с тем, что мы потеряли очень много работодателей, то есть очень большие конторы ушли, очень крупные конторы как раз переехали.
4161.04 4163.04 SPEAKER_01 И это проблема.
4163.04 4179.04 SPEAKER_01 Но на данном случае, как показывает автор, компаний хватает, специалистов в .NET в настоящее время, специалисты есть, и спрос на вакансии превышает предложения тех .NET разработчиков, у которых у нас есть на рынке.
4179.04 4184.04 SPEAKER_01 Поэтому пока с работой все хорошо, с вакансиями хорошо, зарплаты растут.
4184.04 4187.04 SPEAKER_01 Как мы тоже в одном из предыдущих выпусков обсуждали.
4187.04 4190.04 SPEAKER_01 Сообщество разрывается... Разрывается?
4190.04 4193.04 SPEAKER_01 Сообщество разрывается от счастья, как ему хорошо жить в .NET.
4193.04 4196.04 SPEAKER_01 Развивается сообщество, проходит конференция .NEXT.
4196.04 4212.04 SPEAKER_01 Я хочу отметить, что опять же работает .NET.Rule, то есть те подкасты, которые вы слушаете, те метапы, которые мы проводим ежемесячно, те материалы, которые мы выкладываем на наш YouTube-канал, те книги, которые мы переводим специально для вас, они не останавливаются ни на секунду, даже наоборот.
4212.04 4217.04 SPEAKER_01 У нас больше и больше подписчиков, больше и больше книг, интересных лекций и так далее.
4217.04 4220.04 SPEAKER_01 Поэтому все развиваются, все счастливы.
4220.04 4232.04 SPEAKER_01 И компания DigiPlanet продолжает успешно разрабатывать проекты и сервисы на .NET и уверенно смотрит в будущее, за что ей в принципе и огромное спасибо.
4232.04 4243.04 SPEAKER_01 Вот такая интересная статья, вроде прибавила оптимизма для тех, кто почему-то еще ждал каких-то проблем от ухода Microsoft, или от закрытия стэка, или от запрещения языка, или еще какой-то глупости.
4243.04 4254.04 SPEAKER_01 Ну да, мне кажется, что в целом действительно чувствуется уход работодателей, либо даже заказчиков в каком-то смысле, но .NET все еще есть.
4254.04 4274.04 SPEAKER_01 Странно, конечно, в сети вот от крупного интегратора видеть утверждение про переход с EF на Dapper, потому что лицензия или что-нибудь в таком духе, но да, может быть, что-то имелось в виду другое, просто сформулировано на самом деле не очень корректно.
4274.04 4277.04 SPEAKER_01 Да, не корректно выразили мысли просто, да и все.
4277.04 4279.04 SPEAKER_01 Понятно было.
4279.04 4281.04 SPEAKER_01 Так что так.
4281.04 4284.04 SPEAKER_01 Ну, у меня каких-то больше комментариев нет.
4284.04 4292.04 SPEAKER_01 В целом, не то чтобы все сломалось, живем, работаем, пытаемся что-то делать, писать на .NET.
4292.04 4293.04 SPEAKER_01 Отлично.
4293.04 4294.04 SPEAKER_01 Это главное.
4294.04 4297.04 SPEAKER_01 Новые версии выходят и нам доступны.
4297.04 4301.04 SPEAKER_01 Ну, чего, на сегодня, наверное, с новостями хватит и с статьями.
4301.04 4304.04 SPEAKER_01 Что у нас еще есть, что-нибудь какая-нибудь?
4304.04 4305.04 SPEAKER_01 В чем рассказать?
4305.04 4306.04 SPEAKER_01 У нас есть коротко о разном.
4306.04 4308.04 SPEAKER_01 Давай.
4308.04 4312.04 SPEAKER_01 Здесь тоже не то чтобы слишком много, мне понравился один выпуск из того, что было прослушано.
4312.04 4316.04 SPEAKER_01 Это подлодка 407, которая рассказывала про self-hosting.
4316.04 4320.04 SPEAKER_01 В гости пришел отличный эксперт, прям которого было очень приятно слушать.
4320.04 4328.04 SPEAKER_01 И он нам рассказал, что вообще что такое self-hosting, как им заниматься, как избавиться от этой привязки к облакам.
4328.04 4337.04 SPEAKER_01 Потому что я надеюсь, что в последнее время все поняли, что те облака, которые где-то там лежат, они абсолютно не 100% гарантируют вам доступ к вашей информации.
4337.04 4339.04 SPEAKER_01 С ними может случиться все, что угодно.
4339.04 4341.04 SPEAKER_01 И обычно случается все, что угодно.
4341.04 4344.04 SPEAKER_01 Поэтому самый надежный способ, как всегда, пойди и сделай сам.
4344.04 4349.04 SPEAKER_01 Домашний сервер или свой собственный, может быть, облачный сервер или еще что-то.
4349.04 4350.04 SPEAKER_01 Как все это поддержать?
4350.04 4351.04 SPEAKER_01 Это и есть self-hosting.
4351.04 4352.04 SPEAKER_01 Как сделать бэкапы?
4352.04 4354.04 SPEAKER_01 Как настроить трансляцию видосиков на всю семью?
4354.04 4358.04 SPEAKER_01 Как распространить шаринг между всеми членами вашей семьи?
4358.04 4373.04 SPEAKER_01 И много-много таких очень интересных вопросов, которые будут перед вами возникать, если вы вдруг озаботитесь, а где же мне хранить свою информацию таким образом, чтобы она у вас никуда не пропала, никто вас не украл, никто вас ее не заблокировал, чтобы вы сами владели своей собственной информацией.
4373.04 4379.04 SPEAKER_01 Все, начиная там от железок, конкретного программного обеспечения и самое главное, это богатый практически опыт автора.
4379.04 4381.04 SPEAKER_01 В общем, в выпуске отлично изложено.
4381.04 4386.04 SPEAKER_01 Поэтому всем, кому тема интересна или просто для общего развития, как я, в принципе, послушайте.
4386.04 4388.04 SPEAKER_01 Выпуск классный получился.
4388.04 4389.04 SPEAKER_01 Соглашусь.
4389.04 4391.04 SPEAKER_01 Слышал его тоже, да.
4391.04 4395.04 SPEAKER_01 Неплохо узнал какие-то несколько новых моментов для себя.
4395.04 4397.04 SPEAKER_01 Ну, а на этом будем заканчивать.
4397.04 4409.04 SPEAKER_01 Мы поговорили про первый превью десятого дотнета, мы поговорили про то, как правильно, ну, или про просто альтернативный подход к логированию эксепшенов, насколько это там правильно или удобно вам, смотрите сами.
4409.04 4419.04 SPEAKER_01 Поговорили про релиз Aspire 9.1, про то, что думают в России про уход Microsoft и как мы будем импорт замещать дотнет.
4419.04 4422.04 SPEAKER_01 Ну, и немножечко про...
4422.04 4424.04 SPEAKER_01 Радко-разно про self-hosting.
4424.04 4426.04 SPEAKER_01 Ссылочка на другой подкаст.
4426.04 4429.04 SPEAKER_01 На этом на сегодня все.
4429.04 4430.04 SPEAKER_01 Да, всем спасибо.
4430.04 4431.04 SPEAKER_01 До новых встреч.
4431.04 4432.04 SPEAKER_01 Шарь лайки, репосты.
4432.04 4433.04 SPEAKER_01 Мы вас всех любим.
4433.04 4434.04 SPEAKER_01 Пока.
4434.04 4435.04 SPEAKER_01 Пока.
